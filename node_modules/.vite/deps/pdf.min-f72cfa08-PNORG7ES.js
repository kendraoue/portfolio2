// node_modules/pdf-vue3/dist/pdf.min-f72cfa08.js
var vr = Object.defineProperty;
var br = (k2, d2, t2) => d2 in k2 ? vr(k2, d2, { enumerable: true, configurable: true, writable: true, value: t2 }) : k2[d2] = t2;
var It = (k2, d2, t2) => (br(k2, typeof d2 != "symbol" ? d2 + "" : d2, t2), t2);
var ye = (k2, d2, t2) => {
  if (!d2.has(k2))
    throw TypeError("Cannot " + t2);
};
var T = (k2, d2, t2) => (ye(k2, d2, "read from private field"), t2 ? t2.call(k2) : d2.get(k2));
var et = (k2, d2, t2) => {
  if (d2.has(k2))
    throw TypeError("Cannot add the same private member more than once");
  d2 instanceof WeakSet ? d2.add(k2) : d2.set(k2, t2);
};
var ut = (k2, d2, t2, e2) => (ye(k2, d2, "write to private field"), e2 ? e2.call(k2, t2) : d2.set(k2, t2), t2);
var ue = (k2, d2, t2, e2) => ({
  set _(a2) {
    ut(k2, d2, a2, t2);
  },
  get _() {
    return T(k2, d2, e2);
  }
});
var nt = (k2, d2, t2) => (ye(k2, d2, "access private method"), t2);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(k2) {
  return k2 && k2.__esModule && Object.prototype.hasOwnProperty.call(k2, "default") ? k2.default : k2;
}
function getAugmentedNamespace(k2) {
  if (k2.__esModule)
    return k2;
  var d2 = k2.default;
  if (typeof d2 == "function") {
    var t2 = function e2() {
      if (this instanceof e2) {
        var a2 = [null];
        a2.push.apply(a2, arguments);
        var y = Function.bind.apply(d2, a2);
        return new y();
      }
      return d2.apply(this, arguments);
    };
    t2.prototype = d2.prototype;
  } else
    t2 = {};
  return Object.defineProperty(t2, "__esModule", { value: true }), Object.keys(k2).forEach(function(e2) {
    var a2 = Object.getOwnPropertyDescriptor(k2, e2);
    Object.defineProperty(t2, e2, a2.get ? a2 : {
      enumerable: true,
      get: function() {
        return k2[e2];
      }
    });
  }), t2;
}
function commonjsRequire(k2) {
  throw new Error('Could not dynamically require "' + k2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdf_min$2 = { exports: {} };
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$6 = getAugmentedNamespace(__viteBrowserExternal$1);
var path2dPolyfill_min = {};
var hasRequiredPath2dPolyfill_min;
function requirePath2dPolyfill_min() {
  return hasRequiredPath2dPolyfill_min || (hasRequiredPath2dPolyfill_min = 1, function() {
    function k2(l2, c2, b2) {
      if (b2 || arguments.length === 2)
        for (var L2, m2 = 0, M = c2.length; m2 < M; m2++)
          !L2 && m2 in c2 || (L2 || (L2 = Array.prototype.slice.call(c2, 0, m2)), L2[m2] = c2[m2]);
      return l2.concat(L2 || Array.prototype.slice.call(c2));
    }
    var d2 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, t2 = /([astvzqmhlc])([^astvzqmhlc]*)/gi, e2 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
    function a2(l2) {
      var c2 = [], b2 = String(l2).trim();
      return b2[0] !== "M" && b2[0] !== "m" || b2.replace(t2, function(L2, m2, M) {
        var x2 = function(i2) {
          var A2 = i2.match(e2);
          return A2 ? A2.map(Number) : [];
        }(M), I2 = m2.toLowerCase(), v = m2;
        if (I2 === "m" && x2.length > 2 && (c2.push(k2([v], x2.splice(0, 2), true)), I2 = "l", v = v === "m" ? "l" : "L"), x2.length < d2[I2])
          return "";
        for (c2.push(k2([v], x2.splice(0, d2[I2]), true)); x2.length >= d2[I2] && x2.length && d2[I2]; )
          c2.push(k2([v], x2.splice(0, d2[I2]), true));
        return "";
      }), c2;
    }
    function y(l2, c2) {
      var b2 = l2.x * Math.cos(c2) - l2.y * Math.sin(c2), L2 = l2.y * Math.cos(c2) + l2.x * Math.sin(c2);
      l2.x = b2, l2.y = L2;
    }
    function w2(l2, c2) {
      l2.x *= c2, l2.y *= c2;
    }
    var O = function() {
      function l2(c2) {
        var b2;
        this.commands = [], c2 && c2 instanceof l2 ? (b2 = this.commands).push.apply(b2, c2.commands) : c2 && (this.commands = a2(c2));
      }
      return l2.prototype.addPath = function(c2) {
        var b2;
        c2 && c2 instanceof l2 && (b2 = this.commands).push.apply(b2, c2.commands);
      }, l2.prototype.moveTo = function(c2, b2) {
        this.commands.push(["M", c2, b2]);
      }, l2.prototype.lineTo = function(c2, b2) {
        this.commands.push(["L", c2, b2]);
      }, l2.prototype.arc = function(c2, b2, L2, m2, M, x2) {
        this.commands.push(["AC", c2, b2, L2, m2, M, !!x2]);
      }, l2.prototype.arcTo = function(c2, b2, L2, m2, M) {
        this.commands.push(["AT", c2, b2, L2, m2, M]);
      }, l2.prototype.ellipse = function(c2, b2, L2, m2, M, x2, I2, v) {
        this.commands.push(["E", c2, b2, L2, m2, M, x2, I2, !!v]);
      }, l2.prototype.closePath = function() {
        this.commands.push(["Z"]);
      }, l2.prototype.bezierCurveTo = function(c2, b2, L2, m2, M, x2) {
        this.commands.push(["C", c2, b2, L2, m2, M, x2]);
      }, l2.prototype.quadraticCurveTo = function(c2, b2, L2, m2) {
        this.commands.push(["Q", c2, b2, L2, m2]);
      }, l2.prototype.rect = function(c2, b2, L2, m2) {
        this.commands.push(["R", c2, b2, L2, m2]);
      }, l2.prototype.roundRect = function(c2, b2, L2, m2, M) {
        M === void 0 ? this.commands.push(["RR", c2, b2, L2, m2, 0]) : this.commands.push(["RR", c2, b2, L2, m2, M]);
      }, l2;
    }();
    function p2(l2, c2) {
      var b2, L2, m2, M, x2, I2, v, i2, A2, n2, s, r, u, C, D, o, F, z, q, J, $, S, f, P, g = 0, _ = 0, U = null, N = null, G = null, V = null, W = null, X = null;
      l2.beginPath();
      for (var K = 0; K < c2.length; ++K) {
        (z = c2[K][0]) !== "S" && z !== "s" && z !== "C" && z !== "c" && (U = null, N = null), z !== "T" && z !== "t" && z !== "Q" && z !== "q" && (G = null, V = null);
        var H = void 0;
        switch (z) {
          case "m":
          case "M":
            H = c2[K], z === "m" ? (g += H[1], _ += H[2]) : (g = H[1], _ = H[2]), z !== "M" && W || (W = { x: g, y: _ }), l2.moveTo(g, _);
            break;
          case "l":
            g += (H = c2[K])[1], _ += H[2], l2.lineTo(g, _);
            break;
          case "L":
            g = (H = c2[K])[1], _ = H[2], l2.lineTo(g, _);
            break;
          case "H":
            g = (H = c2[K])[1], l2.lineTo(g, _);
            break;
          case "h":
            g += (H = c2[K])[1], l2.lineTo(g, _);
            break;
          case "V":
            _ = (H = c2[K])[1], l2.lineTo(g, _);
            break;
          case "v":
            _ += (H = c2[K])[1], l2.lineTo(g, _);
            break;
          case "a":
          case "A":
            if (H = c2[K], X === null)
              throw new Error("This should never happen");
            z === "a" ? (g += H[6], _ += H[7]) : (g = H[6], _ = H[7]), C = H[1], D = H[2], v = H[3] * Math.PI / 180, m2 = !!H[4], M = !!H[5], x2 = { x: g, y: _ }, y(I2 = { x: (X.x - x2.x) / 2, y: (X.y - x2.y) / 2 }, -v), (i2 = I2.x * I2.x / (C * C) + I2.y * I2.y / (D * D)) > 1 && (C *= i2 = Math.sqrt(i2), D *= i2), A2 = C * C * D * D, n2 = C * C * I2.y * I2.y + D * D * I2.x * I2.x, w2(q = { x: C * I2.y / D, y: -D * I2.x / C }, M !== m2 ? Math.sqrt((A2 - n2) / n2) || 0 : -Math.sqrt((A2 - n2) / n2) || 0), L2 = Math.atan2((I2.y - q.y) / D, (I2.x - q.x) / C), b2 = Math.atan2(-(I2.y + q.y) / D, -(I2.x + q.x) / C), y(q, v), S = q, f = (x2.x + X.x) / 2, P = (x2.y + X.y) / 2, S.x += f, S.y += P, l2.save(), l2.translate(q.x, q.y), l2.rotate(v), l2.scale(C, D), l2.arc(0, 0, 1, L2, b2, !M), l2.restore();
            break;
          case "C":
            U = (H = c2[K])[3], N = H[4], g = H[5], _ = H[6], l2.bezierCurveTo(H[1], H[2], U, N, g, _);
            break;
          case "c":
            H = c2[K], l2.bezierCurveTo(H[1] + g, H[2] + _, H[3] + g, H[4] + _, H[5] + g, H[6] + _), U = H[3] + g, N = H[4] + _, g += H[5], _ += H[6];
            break;
          case "S":
            H = c2[K], U !== null && N !== null || (U = g, N = _), l2.bezierCurveTo(2 * g - U, 2 * _ - N, H[1], H[2], H[3], H[4]), U = H[1], N = H[2], g = H[3], _ = H[4];
            break;
          case "s":
            H = c2[K], U !== null && N !== null || (U = g, N = _), l2.bezierCurveTo(2 * g - U, 2 * _ - N, H[1] + g, H[2] + _, H[3] + g, H[4] + _), U = H[1] + g, N = H[2] + _, g += H[3], _ += H[4];
            break;
          case "Q":
            G = (H = c2[K])[1], V = H[2], g = H[3], _ = H[4], l2.quadraticCurveTo(G, V, g, _);
            break;
          case "q":
            G = (H = c2[K])[1] + g, V = H[2] + _, g += H[3], _ += H[4], l2.quadraticCurveTo(G, V, g, _);
            break;
          case "T":
            G !== null && V !== null || (G = g, V = _), G = 2 * g - G, V = 2 * _ - V, g = (H = c2[K])[1], _ = H[2], l2.quadraticCurveTo(G, V, g, _);
            break;
          case "t":
            G !== null && V !== null || (G = g, V = _), G = 2 * g - G, V = 2 * _ - V, g += (H = c2[K])[1], _ += H[2], l2.quadraticCurveTo(G, V, g, _);
            break;
          case "z":
          case "Z":
            W && (g = W.x, _ = W.y), W = null, l2.closePath();
            break;
          case "AC":
            g = (H = c2[K])[1], _ = H[2], u = H[3], L2 = H[4], b2 = H[5], J = H[6], l2.arc(g, _, u, L2, b2, J);
            break;
          case "AT":
            s = (H = c2[K])[1], r = H[2], g = H[3], _ = H[4], u = H[5], l2.arcTo(s, r, g, _, u);
            break;
          case "E":
            g = (H = c2[K])[1], _ = H[2], C = H[3], D = H[4], v = H[5], L2 = H[6], b2 = H[7], J = H[8], l2.save(), l2.translate(g, _), l2.rotate(v), l2.scale(C, D), l2.arc(0, 0, 1, L2, b2, J), l2.restore();
            break;
          case "R":
            g = (H = c2[K])[1], _ = H[2], o = H[3], F = H[4], W = { x: g, y: _ }, l2.rect(g, _, o, F);
            break;
          case "RR":
            g = (H = c2[K])[1], _ = H[2], o = H[3], F = H[4], $ = H[5], W = { x: g, y: _ }, l2.roundRect(g, _, o, F, $);
        }
        X ? (X.x = g, X.y = _) : X = { x: g, y: _ };
      }
    }
    function h2(l2, c2, b2, L2, m2) {
      var M = this;
      if (m2 === void 0 && (m2 = 0), typeof m2 == "number" && (m2 = [m2]), Array.isArray(m2)) {
        if (m2.length === 0 || m2.length > 4)
          throw new RangeError("Failed to execute 'roundRect' on '".concat(this.constructor.name, "': ").concat(m2.length, " radii provided. Between one and four radii are necessary."));
        if (m2.forEach(function(n2) {
          if (n2 < 0)
            throw new RangeError("Failed to execute 'roundRect' on '".concat(M.constructor.name, "': Radius value ").concat(n2, " is negative."));
        }), m2.length === 1 && m2[0] === 0)
          return this.rect(l2, c2, b2, L2);
        var x2, I2, v, i2 = Math.min(b2, L2) / 2, A2 = x2 = I2 = v = Math.min(i2, m2[0]);
        m2.length === 2 && (x2 = v = Math.min(i2, m2[1])), m2.length === 3 && (x2 = v = Math.min(i2, m2[1]), I2 = Math.min(i2, m2[2])), m2.length === 4 && (x2 = Math.min(i2, m2[1]), I2 = Math.min(i2, m2[2]), v = Math.min(i2, m2[3])), this.moveTo(l2, c2 + L2 - v), this.arcTo(l2, c2, l2 + A2, c2, A2), this.arcTo(l2 + b2, c2, l2 + b2, c2 + x2, x2), this.arcTo(l2 + b2, c2 + L2, l2 + b2 - I2, c2 + L2, I2), this.arcTo(l2, c2 + L2, l2, c2 + L2 - v, v), this.moveTo(l2, c2);
      }
    }
    (function(l2) {
      if (l2 && l2.CanvasRenderingContext2D && !l2.Path2D) {
        var c2 = l2.CanvasRenderingContext2D, b2 = c2.prototype.fill, L2 = c2.prototype.stroke, m2 = c2.prototype.isPointInPath;
        c2.prototype.fill = function() {
          for (var M = [], x2 = 0; x2 < arguments.length; x2++)
            M[x2] = arguments[x2];
          if (!(M[0] instanceof O))
            return v = M[0] || "nonzero", b2.apply(this, [v]);
          var I2 = M[0], v = M[1] || "nonzero";
          p2(this, I2.commands), b2.apply(this, [v]);
        }, c2.prototype.stroke = function(M) {
          M && p2(this, M.commands), L2.apply(this);
        }, c2.prototype.isPointInPath = function() {
          for (var M = [], x2 = 0; x2 < arguments.length; x2++)
            M[x2] = arguments[x2];
          if (M[0] instanceof O) {
            var I2 = M[0], v = M[1], i2 = M[2], A2 = M[3] || "nonzero";
            return p2(this, I2.commands), m2.apply(this, [v, i2, A2]);
          }
          return m2.apply(this, M);
        }, l2.Path2D = O;
      }
    })(window), function(l2) {
      if (l2 && l2.CanvasRenderingContext2D) {
        var c2 = l2.CanvasRenderingContext2D, b2 = l2.Path2D;
        c2 && !c2.prototype.roundRect && (c2.prototype.roundRect = h2), b2 && !b2.prototype.roundRect && (b2.prototype.roundRect = h2);
      }
    }(window);
  }()), path2dPolyfill_min;
}
(function(module, exports) {
  (function(d2, t2) {
    module.exports = t2();
  })(globalThis, () => (() => {
    var __webpack_modules__ = [, (k2, d2, t2) => {
      var x2, I2;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.VerbosityLevel = d2.Util = d2.UnknownErrorException = d2.UnexpectedResponseException = d2.TextRenderingMode = d2.RenderingIntentFlag = d2.PromiseCapability = d2.PermissionFlag = d2.PasswordResponses = d2.PasswordException = d2.PageActionEventType = d2.OPS = d2.MissingPDFException = d2.MAX_IMAGE_SIZE_TO_CACHE = d2.LINE_FACTOR = d2.LINE_DESCENT_FACTOR = d2.InvalidPDFException = d2.ImageKind = d2.IDENTITY_MATRIX = d2.FormatError = d2.FeatureTest = d2.FONT_IDENTITY_MATRIX = d2.DocumentActionEventType = d2.CMapCompressionType = d2.BaseException = d2.BASELINE_FACTOR = d2.AnnotationType = d2.AnnotationStateModelType = d2.AnnotationReviewState = d2.AnnotationReplyType = d2.AnnotationMode = d2.AnnotationMarkedState = d2.AnnotationFlag = d2.AnnotationFieldFlag = d2.AnnotationEditorType = d2.AnnotationEditorPrefix = d2.AnnotationEditorParamsType = d2.AnnotationBorderStyleType = d2.AnnotationActionEventType = d2.AbortException = void 0, d2.assert = function(i2, A2) {
        i2 || w2(A2);
      }, d2.bytesToString = function(i2) {
        typeof i2 == "object" && (i2 == null ? void 0 : i2.length) !== void 0 || w2("Invalid argument for bytesToString");
        const A2 = i2.length, n2 = 8192;
        if (A2 < n2)
          return String.fromCharCode.apply(null, i2);
        const s = [];
        for (let r = 0; r < A2; r += n2) {
          const u = Math.min(r + n2, A2), C = i2.subarray(r, u);
          s.push(String.fromCharCode.apply(null, C));
        }
        return s.join("");
      }, d2.createValidAbsoluteUrl = function(i2) {
        let A2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (!i2)
          return null;
        try {
          if (n2 && typeof i2 == "string") {
            if (n2.addDefaultProtocol && i2.startsWith("www.")) {
              const r = i2.match(/\./g);
              (r == null ? void 0 : r.length) >= 2 && (i2 = `http://${i2}`);
            }
            if (n2.tryConvertEncoding)
              try {
                i2 = L2(i2);
              } catch {
              }
          }
          const s = A2 ? new URL(i2, A2) : new URL(i2);
          if (function(u) {
            switch (u == null ? void 0 : u.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return true;
              default:
                return false;
            }
          }(s))
            return s;
        } catch {
        }
        return null;
      }, d2.getModificationDate = function() {
        let i2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
        return [i2.getUTCFullYear().toString(), (i2.getUTCMonth() + 1).toString().padStart(2, "0"), i2.getUTCDate().toString().padStart(2, "0"), i2.getUTCHours().toString().padStart(2, "0"), i2.getUTCMinutes().toString().padStart(2, "0"), i2.getUTCSeconds().toString().padStart(2, "0")].join("");
      }, d2.getVerbosityLevel = function() {
        return a2;
      }, d2.info = function(i2) {
        a2 >= e2.INFOS && console.log(`Info: ${i2}`);
      }, d2.isArrayBuffer = function(i2) {
        return typeof i2 == "object" && (i2 == null ? void 0 : i2.byteLength) !== void 0;
      }, d2.isArrayEqual = function(i2, A2) {
        if (i2.length !== A2.length)
          return false;
        for (let n2 = 0, s = i2.length; n2 < s; n2++)
          if (i2[n2] !== A2[n2])
            return false;
        return true;
      }, d2.normalizeUnicode = function(i2) {
        return m2 || (m2 = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, M = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), i2.replaceAll(m2, (A2, n2, s) => n2 ? n2.normalize("NFKC") : M.get(s));
      }, d2.objectFromMap = function(i2) {
        const A2 = /* @__PURE__ */ Object.create(null);
        for (const [n2, s] of i2)
          A2[n2] = s;
        return A2;
      }, d2.objectSize = function(i2) {
        return Object.keys(i2).length;
      }, d2.setVerbosityLevel = function(i2) {
        Number.isInteger(i2) && (a2 = i2);
      }, d2.shadow = O, d2.string32 = function(i2) {
        return String.fromCharCode(i2 >> 24 & 255, i2 >> 16 & 255, i2 >> 8 & 255, 255 & i2);
      }, d2.stringToBytes = h2, d2.stringToPDFString = function(i2) {
        if (i2[0] >= "ï") {
          let n2;
          if (i2[0] === "þ" && i2[1] === "ÿ" ? n2 = "utf-16be" : i2[0] === "ÿ" && i2[1] === "þ" ? n2 = "utf-16le" : i2[0] === "ï" && i2[1] === "»" && i2[2] === "¿" && (n2 = "utf-8"), n2)
            try {
              const s = new TextDecoder(n2, { fatal: true }), r = h2(i2);
              return s.decode(r);
            } catch (s) {
              y(`stringToPDFString: "${s}".`);
            }
        }
        const A2 = [];
        for (let n2 = 0, s = i2.length; n2 < s; n2++) {
          const r = b2[i2.charCodeAt(n2)];
          A2.push(r ? String.fromCharCode(r) : i2.charAt(n2));
        }
        return A2.join("");
      }, d2.stringToUTF8String = L2, d2.unreachable = w2, d2.utf8StringToString = function(i2) {
        return unescape(encodeURIComponent(i2));
      }, d2.warn = y, globalThis._pdfjsCompatibilityChecked || (globalThis._pdfjsCompatibilityChecked = true, t2(2)), d2.IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0], d2.FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0], d2.MAX_IMAGE_SIZE_TO_CACHE = 1e7, d2.LINE_FACTOR = 1.35, d2.LINE_DESCENT_FACTOR = 0.35, d2.BASELINE_FACTOR = 0.25925925925925924, d2.RenderingIntentFlag = { ANY: 1, DISPLAY: 2, PRINT: 4, SAVE: 8, ANNOTATIONS_FORMS: 16, ANNOTATIONS_STORAGE: 32, ANNOTATIONS_DISABLE: 64, OPLIST: 256 }, d2.AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }, d2.AnnotationEditorPrefix = "pdfjs_internal_editor_", d2.AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, INK: 15 }, d2.AnnotationEditorParamsType = { FREETEXT_SIZE: 1, FREETEXT_COLOR: 2, FREETEXT_OPACITY: 3, INK_COLOR: 11, INK_THICKNESS: 12, INK_OPACITY: 13 }, d2.PermissionFlag = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, d2.TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }, d2.ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }, d2.AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }, d2.AnnotationStateModelType = { MARKED: "Marked", REVIEW: "Review" }, d2.AnnotationMarkedState = { MARKED: "Marked", UNMARKED: "Unmarked" }, d2.AnnotationReviewState = { ACCEPTED: "Accepted", REJECTED: "Rejected", CANCELLED: "Cancelled", COMPLETED: "Completed", NONE: "None" }, d2.AnnotationReplyType = { GROUP: "Group", REPLY: "R" }, d2.AnnotationFlag = { INVISIBLE: 1, HIDDEN: 2, PRINT: 4, NOZOOM: 8, NOROTATE: 16, NOVIEW: 32, READONLY: 64, LOCKED: 128, TOGGLENOVIEW: 256, LOCKEDCONTENTS: 512 }, d2.AnnotationFieldFlag = { READONLY: 1, REQUIRED: 2, NOEXPORT: 4, MULTILINE: 4096, PASSWORD: 8192, NOTOGGLETOOFF: 16384, RADIO: 32768, PUSHBUTTON: 65536, COMBO: 131072, EDIT: 262144, SORT: 524288, FILESELECT: 1048576, MULTISELECT: 2097152, DONOTSPELLCHECK: 4194304, DONOTSCROLL: 8388608, COMB: 16777216, RICHTEXT: 33554432, RADIOSINUNISON: 33554432, COMMITONSELCHANGE: 67108864 }, d2.AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }, d2.AnnotationActionEventType = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" }, d2.DocumentActionEventType = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" }, d2.PageActionEventType = { O: "PageOpen", C: "PageClose" };
      const e2 = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
      d2.VerbosityLevel = e2, d2.CMapCompressionType = { NONE: 0, BINARY: 1 }, d2.OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }, d2.PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
      let a2 = e2.WARNINGS;
      function y(v) {
        a2 >= e2.WARNINGS && console.log(`Warning: ${v}`);
      }
      function w2(v) {
        throw new Error(v);
      }
      function O(v, i2, A2) {
        let n2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
        return Object.defineProperty(v, i2, { value: A2, enumerable: !n2, configurable: true, writable: false }), A2;
      }
      const p2 = function() {
        function i2(A2, n2) {
          this.constructor === i2 && w2("Cannot initialize BaseException."), this.message = A2, this.name = n2;
        }
        return i2.prototype = new Error(), i2.constructor = i2, i2;
      }();
      d2.BaseException = p2, d2.PasswordException = class extends p2 {
        constructor(i2, A2) {
          super(i2, "PasswordException"), this.code = A2;
        }
      }, d2.UnknownErrorException = class extends p2 {
        constructor(i2, A2) {
          super(i2, "UnknownErrorException"), this.details = A2;
        }
      }, d2.InvalidPDFException = class extends p2 {
        constructor(i2) {
          super(i2, "InvalidPDFException");
        }
      }, d2.MissingPDFException = class extends p2 {
        constructor(i2) {
          super(i2, "MissingPDFException");
        }
      }, d2.UnexpectedResponseException = class extends p2 {
        constructor(i2, A2) {
          super(i2, "UnexpectedResponseException"), this.status = A2;
        }
      }, d2.FormatError = class extends p2 {
        constructor(i2) {
          super(i2, "FormatError");
        }
      }, d2.AbortException = class extends p2 {
        constructor(i2) {
          super(i2, "AbortException");
        }
      };
      function h2(v) {
        typeof v != "string" && w2("Invalid argument for stringToBytes");
        const i2 = v.length, A2 = new Uint8Array(i2);
        for (let n2 = 0; n2 < i2; ++n2)
          A2[n2] = 255 & v.charCodeAt(n2);
        return A2;
      }
      d2.FeatureTest = class {
        static get isLittleEndian() {
          return O(this, "isLittleEndian", function() {
            const A2 = new Uint8Array(4);
            return A2[0] = 1, new Uint32Array(A2.buffer, 0, 1)[0] === 1;
          }());
        }
        static get isEvalSupported() {
          return O(this, "isEvalSupported", function() {
            try {
              return new Function(""), true;
            } catch {
              return false;
            }
          }());
        }
        static get isOffscreenCanvasSupported() {
          return O(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
        }
        static get platform() {
          return typeof navigator > "u" ? O(this, "platform", { isWin: false, isMac: false }) : O(this, "platform", { isWin: navigator.platform.includes("Win"), isMac: navigator.platform.includes("Mac") });
        }
      };
      const l2 = [...Array(256).keys()].map((v) => v.toString(16).padStart(2, "0"));
      class c2 {
        static makeHexColor(i2, A2, n2) {
          return `#${l2[i2]}${l2[A2]}${l2[n2]}`;
        }
        static scaleMinMax(i2, A2) {
          let n2;
          i2[0] ? (i2[0] < 0 && (n2 = A2[0], A2[0] = A2[1], A2[1] = n2), A2[0] *= i2[0], A2[1] *= i2[0], i2[3] < 0 && (n2 = A2[2], A2[2] = A2[3], A2[3] = n2), A2[2] *= i2[3], A2[3] *= i2[3]) : (n2 = A2[0], A2[0] = A2[2], A2[2] = n2, n2 = A2[1], A2[1] = A2[3], A2[3] = n2, i2[1] < 0 && (n2 = A2[2], A2[2] = A2[3], A2[3] = n2), A2[2] *= i2[1], A2[3] *= i2[1], i2[2] < 0 && (n2 = A2[0], A2[0] = A2[1], A2[1] = n2), A2[0] *= i2[2], A2[1] *= i2[2]), A2[0] += i2[4], A2[1] += i2[4], A2[2] += i2[5], A2[3] += i2[5];
        }
        static transform(i2, A2) {
          return [i2[0] * A2[0] + i2[2] * A2[1], i2[1] * A2[0] + i2[3] * A2[1], i2[0] * A2[2] + i2[2] * A2[3], i2[1] * A2[2] + i2[3] * A2[3], i2[0] * A2[4] + i2[2] * A2[5] + i2[4], i2[1] * A2[4] + i2[3] * A2[5] + i2[5]];
        }
        static applyTransform(i2, A2) {
          return [i2[0] * A2[0] + i2[1] * A2[2] + A2[4], i2[0] * A2[1] + i2[1] * A2[3] + A2[5]];
        }
        static applyInverseTransform(i2, A2) {
          const n2 = A2[0] * A2[3] - A2[1] * A2[2];
          return [(i2[0] * A2[3] - i2[1] * A2[2] + A2[2] * A2[5] - A2[4] * A2[3]) / n2, (-i2[0] * A2[1] + i2[1] * A2[0] + A2[4] * A2[1] - A2[5] * A2[0]) / n2];
        }
        static getAxialAlignedBoundingBox(i2, A2) {
          const n2 = c2.applyTransform(i2, A2), s = c2.applyTransform(i2.slice(2, 4), A2), r = c2.applyTransform([i2[0], i2[3]], A2), u = c2.applyTransform([i2[2], i2[1]], A2);
          return [Math.min(n2[0], s[0], r[0], u[0]), Math.min(n2[1], s[1], r[1], u[1]), Math.max(n2[0], s[0], r[0], u[0]), Math.max(n2[1], s[1], r[1], u[1])];
        }
        static inverseTransform(i2) {
          const A2 = i2[0] * i2[3] - i2[1] * i2[2];
          return [i2[3] / A2, -i2[1] / A2, -i2[2] / A2, i2[0] / A2, (i2[2] * i2[5] - i2[4] * i2[3]) / A2, (i2[4] * i2[1] - i2[5] * i2[0]) / A2];
        }
        static singularValueDecompose2dScale(i2) {
          const A2 = [i2[0], i2[2], i2[1], i2[3]], n2 = i2[0] * A2[0] + i2[1] * A2[2], s = i2[0] * A2[1] + i2[1] * A2[3], r = i2[2] * A2[0] + i2[3] * A2[2], u = i2[2] * A2[1] + i2[3] * A2[3], C = (n2 + u) / 2, D = Math.sqrt((n2 + u) ** 2 - 4 * (n2 * u - r * s)) / 2, o = C + D || 1, F = C - D || 1;
          return [Math.sqrt(o), Math.sqrt(F)];
        }
        static normalizeRect(i2) {
          const A2 = i2.slice(0);
          return i2[0] > i2[2] && (A2[0] = i2[2], A2[2] = i2[0]), i2[1] > i2[3] && (A2[1] = i2[3], A2[3] = i2[1]), A2;
        }
        static intersect(i2, A2) {
          const n2 = Math.max(Math.min(i2[0], i2[2]), Math.min(A2[0], A2[2])), s = Math.min(Math.max(i2[0], i2[2]), Math.max(A2[0], A2[2]));
          if (n2 > s)
            return null;
          const r = Math.max(Math.min(i2[1], i2[3]), Math.min(A2[1], A2[3])), u = Math.min(Math.max(i2[1], i2[3]), Math.max(A2[1], A2[3]));
          return r > u ? null : [n2, r, s, u];
        }
        static bezierBoundingBox(i2, A2, n2, s, r, u, C, D) {
          const o = [], F = [[], []];
          let z, q, J, $, S, f, P, g;
          for (let G = 0; G < 2; ++G)
            if (G === 0 ? (q = 6 * i2 - 12 * n2 + 6 * r, z = -3 * i2 + 9 * n2 - 9 * r + 3 * C, J = 3 * n2 - 3 * i2) : (q = 6 * A2 - 12 * s + 6 * u, z = -3 * A2 + 9 * s - 9 * u + 3 * D, J = 3 * s - 3 * A2), Math.abs(z) < 1e-12) {
              if (Math.abs(q) < 1e-12)
                continue;
              $ = -J / q, 0 < $ && $ < 1 && o.push($);
            } else
              P = q * q - 4 * J * z, g = Math.sqrt(P), P < 0 || (S = (-q + g) / (2 * z), 0 < S && S < 1 && o.push(S), f = (-q - g) / (2 * z), 0 < f && f < 1 && o.push(f));
          let _, U = o.length;
          const N = U;
          for (; U--; )
            $ = o[U], _ = 1 - $, F[0][U] = _ * _ * _ * i2 + 3 * _ * _ * $ * n2 + 3 * _ * $ * $ * r + $ * $ * $ * C, F[1][U] = _ * _ * _ * A2 + 3 * _ * _ * $ * s + 3 * _ * $ * $ * u + $ * $ * $ * D;
          return F[0][N] = i2, F[1][N] = A2, F[0][N + 1] = C, F[1][N + 1] = D, F[0].length = F[1].length = N + 2, [Math.min(...F[0]), Math.min(...F[1]), Math.max(...F[0]), Math.max(...F[1])];
        }
      }
      d2.Util = c2;
      const b2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
      function L2(v) {
        return decodeURIComponent(escape(v));
      }
      d2.PromiseCapability = (I2 = class {
        constructor() {
          et(this, x2, false);
          this.promise = new Promise((i2, A2) => {
            this.resolve = (n2) => {
              ut(this, x2, true), i2(n2);
            }, this.reject = (n2) => {
              ut(this, x2, true), A2(n2);
            };
          });
        }
        get settled() {
          return T(this, x2);
        }
      }, x2 = /* @__PURE__ */ new WeakMap(), I2);
      let m2 = null, M = null;
    }, (k2, d2, t2) => {
      var e2 = t2(3);
      (function() {
        !globalThis.DOMMatrix && e2.isNodeJS && (globalThis.DOMMatrix = require$$6.DOMMatrix);
      })(), function() {
        if (globalThis.Path2D || !e2.isNodeJS)
          return;
        const { CanvasRenderingContext2D: y } = require$$6, { polyfillPath2D: w2 } = requirePath2dPolyfill_min();
        globalThis.CanvasRenderingContext2D = y, w2(globalThis);
      }(), function() {
        Array.prototype.at || t2(4);
      }(), function() {
        Uint8Array.prototype.at || t2(78);
      }(), function() {
        globalThis.structuredClone || t2(90);
      }();
    }, (k2, d2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.isNodeJS = void 0;
      const t2 = !(typeof process != "object" || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && process.type !== "browser");
      d2.isNodeJS = t2;
    }, (k2, d2, t2) => {
      t2(5);
      var e2 = t2(77);
      k2.exports = e2("Array", "at");
    }, (k2, d2, t2) => {
      var e2 = t2(6), a2 = t2(43), y = t2(67), w2 = t2(65), O = t2(72);
      e2({ target: "Array", proto: true }, { at: function(h2) {
        var l2 = a2(this), c2 = y(l2), b2 = w2(h2), L2 = b2 >= 0 ? b2 : c2 + b2;
        return L2 < 0 || L2 >= c2 ? void 0 : l2[L2];
      } }), O("at");
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(8).f, y = t2(47), w2 = t2(51), O = t2(41), p2 = t2(59), h2 = t2(71);
      k2.exports = function(l2, c2) {
        var b2, L2, m2, M, x2, I2 = l2.target, v = l2.global, i2 = l2.stat;
        if (b2 = v ? e2 : i2 ? e2[I2] || O(I2, {}) : (e2[I2] || {}).prototype)
          for (L2 in c2) {
            if (M = c2[L2], m2 = l2.dontCallGetSet ? (x2 = a2(b2, L2)) && x2.value : b2[L2], !h2(v ? L2 : I2 + (i2 ? "." : "#") + L2, l2.forced) && m2 !== void 0) {
              if (typeof M == typeof m2)
                continue;
              p2(M, m2);
            }
            (l2.sham || m2 && m2.sham) && y(M, "sham", true), w2(b2, L2, M, l2);
          }
      };
    }, function(k2) {
      var d2 = function(t2) {
        return t2 && t2.Math == Math && t2;
      };
      k2.exports = d2(typeof globalThis == "object" && globalThis) || d2(typeof window == "object" && window) || d2(typeof self == "object" && self) || d2(typeof commonjsGlobal == "object" && commonjsGlobal) || /* @__PURE__ */ function() {
        return this;
      }() || this || Function("return this")();
    }, (k2, d2, t2) => {
      var e2 = t2(9), a2 = t2(11), y = t2(13), w2 = t2(14), O = t2(15), p2 = t2(21), h2 = t2(42), l2 = t2(45), c2 = Object.getOwnPropertyDescriptor;
      d2.f = e2 ? c2 : function(L2, m2) {
        if (L2 = O(L2), m2 = p2(m2), l2)
          try {
            return c2(L2, m2);
          } catch {
          }
        if (h2(L2, m2))
          return w2(!a2(y.f, L2, m2), L2[m2]);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(10);
      k2.exports = !e2(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      });
    }, (k2) => {
      k2.exports = function(d2) {
        try {
          return !!d2();
        } catch {
          return true;
        }
      };
    }, (k2, d2, t2) => {
      var e2 = t2(12), a2 = Function.prototype.call;
      k2.exports = e2 ? a2.bind(a2) : function() {
        return a2.apply(a2, arguments);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(10);
      k2.exports = !e2(function() {
        var a2 = (function() {
        }).bind();
        return typeof a2 != "function" || a2.hasOwnProperty("prototype");
      });
    }, (k2, d2) => {
      var t2 = {}.propertyIsEnumerable, e2 = Object.getOwnPropertyDescriptor, a2 = e2 && !t2.call({ 1: 2 }, 1);
      d2.f = a2 ? function(w2) {
        var O = e2(this, w2);
        return !!O && O.enumerable;
      } : t2;
    }, (k2) => {
      k2.exports = function(d2, t2) {
        return { enumerable: !(1 & d2), configurable: !(2 & d2), writable: !(4 & d2), value: t2 };
      };
    }, (k2, d2, t2) => {
      var e2 = t2(16), a2 = t2(19);
      k2.exports = function(y) {
        return e2(a2(y));
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = t2(10), y = t2(18), w2 = Object, O = e2("".split);
      k2.exports = a2(function() {
        return !w2("z").propertyIsEnumerable(0);
      }) ? function(p2) {
        return y(p2) == "String" ? O(p2, "") : w2(p2);
      } : w2;
    }, (k2, d2, t2) => {
      var e2 = t2(12), a2 = Function.prototype, y = a2.call, w2 = e2 && a2.bind.bind(y, y);
      k2.exports = e2 ? w2 : function(O) {
        return function() {
          return y.apply(O, arguments);
        };
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = e2({}.toString), y = e2("".slice);
      k2.exports = function(w2) {
        return y(a2(w2), 8, -1);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(20), a2 = TypeError;
      k2.exports = function(y) {
        if (e2(y))
          throw a2("Can't call method on " + y);
        return y;
      };
    }, (k2) => {
      k2.exports = function(d2) {
        return d2 == null;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(22), a2 = t2(26);
      k2.exports = function(y) {
        var w2 = e2(y, "string");
        return a2(w2) ? w2 : w2 + "";
      };
    }, (k2, d2, t2) => {
      var e2 = t2(11), a2 = t2(23), y = t2(26), w2 = t2(33), O = t2(36), p2 = t2(37), h2 = TypeError, l2 = p2("toPrimitive");
      k2.exports = function(c2, b2) {
        if (!a2(c2) || y(c2))
          return c2;
        var L2, m2 = w2(c2, l2);
        if (m2) {
          if (b2 === void 0 && (b2 = "default"), L2 = e2(m2, c2, b2), !a2(L2) || y(L2))
            return L2;
          throw h2("Can't convert object to primitive value");
        }
        return b2 === void 0 && (b2 = "number"), O(c2, b2);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(24), a2 = t2(25), y = a2.all;
      k2.exports = a2.IS_HTMLDDA ? function(w2) {
        return typeof w2 == "object" ? w2 !== null : e2(w2) || w2 === y;
      } : function(w2) {
        return typeof w2 == "object" ? w2 !== null : e2(w2);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(25), a2 = e2.all;
      k2.exports = e2.IS_HTMLDDA ? function(y) {
        return typeof y == "function" || y === a2;
      } : function(y) {
        return typeof y == "function";
      };
    }, (k2) => {
      var d2 = typeof document == "object" && document.all, t2 = d2 === void 0 && d2 !== void 0;
      k2.exports = { all: d2, IS_HTMLDDA: t2 };
    }, (k2, d2, t2) => {
      var e2 = t2(27), a2 = t2(24), y = t2(28), w2 = t2(29), O = Object;
      k2.exports = w2 ? function(p2) {
        return typeof p2 == "symbol";
      } : function(p2) {
        var h2 = e2("Symbol");
        return a2(h2) && y(h2.prototype, O(p2));
      };
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(24);
      k2.exports = function(y, w2) {
        return arguments.length < 2 ? (O = e2[y], a2(O) ? O : void 0) : e2[y] && e2[y][w2];
        var O;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17);
      k2.exports = e2({}.isPrototypeOf);
    }, (k2, d2, t2) => {
      var e2 = t2(30);
      k2.exports = e2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }, (k2, d2, t2) => {
      var e2 = t2(31), a2 = t2(10), y = t2(7).String;
      k2.exports = !!Object.getOwnPropertySymbols && !a2(function() {
        var w2 = Symbol();
        return !y(w2) || !(Object(w2) instanceof Symbol) || !Symbol.sham && e2 && e2 < 41;
      });
    }, (k2, d2, t2) => {
      var e2, a2, y = t2(7), w2 = t2(32), O = y.process, p2 = y.Deno, h2 = O && O.versions || p2 && p2.version, l2 = h2 && h2.v8;
      l2 && (a2 = (e2 = l2.split("."))[0] > 0 && e2[0] < 4 ? 1 : +(e2[0] + e2[1])), !a2 && w2 && (!(e2 = w2.match(/Edge\/(\d+)/)) || e2[1] >= 74) && (e2 = w2.match(/Chrome\/(\d+)/)) && (a2 = +e2[1]), k2.exports = a2;
    }, (k2) => {
      k2.exports = typeof navigator < "u" && String(navigator.userAgent) || "";
    }, (k2, d2, t2) => {
      var e2 = t2(34), a2 = t2(20);
      k2.exports = function(y, w2) {
        var O = y[w2];
        return a2(O) ? void 0 : e2(O);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(24), a2 = t2(35), y = TypeError;
      k2.exports = function(w2) {
        if (e2(w2))
          return w2;
        throw y(a2(w2) + " is not a function");
      };
    }, (k2) => {
      var d2 = String;
      k2.exports = function(t2) {
        try {
          return d2(t2);
        } catch {
          return "Object";
        }
      };
    }, (k2, d2, t2) => {
      var e2 = t2(11), a2 = t2(24), y = t2(23), w2 = TypeError;
      k2.exports = function(O, p2) {
        var h2, l2;
        if (p2 === "string" && a2(h2 = O.toString) && !y(l2 = e2(h2, O)) || a2(h2 = O.valueOf) && !y(l2 = e2(h2, O)) || p2 !== "string" && a2(h2 = O.toString) && !y(l2 = e2(h2, O)))
          return l2;
        throw w2("Can't convert object to primitive value");
      };
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(38), y = t2(42), w2 = t2(44), O = t2(30), p2 = t2(29), h2 = e2.Symbol, l2 = a2("wks"), c2 = p2 ? h2.for || h2 : h2 && h2.withoutSetter || w2;
      k2.exports = function(b2) {
        return y(l2, b2) || (l2[b2] = O && y(h2, b2) ? h2[b2] : c2("Symbol." + b2)), l2[b2];
      };
    }, (k2, d2, t2) => {
      var e2 = t2(39), a2 = t2(40);
      (k2.exports = function(y, w2) {
        return a2[y] || (a2[y] = w2 !== void 0 ? w2 : {});
      })("versions", []).push({ version: "3.30.2", mode: e2 ? "pure" : "global", copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE", source: "https://github.com/zloirock/core-js" });
    }, (k2) => {
      k2.exports = false;
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(41), y = "__core-js_shared__", w2 = e2[y] || a2(y, {});
      k2.exports = w2;
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = Object.defineProperty;
      k2.exports = function(y, w2) {
        try {
          a2(e2, y, { value: w2, configurable: true, writable: true });
        } catch {
          e2[y] = w2;
        }
        return w2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = t2(43), y = e2({}.hasOwnProperty);
      k2.exports = Object.hasOwn || function(O, p2) {
        return y(a2(O), p2);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(19), a2 = Object;
      k2.exports = function(y) {
        return a2(e2(y));
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = 0, y = Math.random(), w2 = e2(1 .toString);
      k2.exports = function(O) {
        return "Symbol(" + (O === void 0 ? "" : O) + ")_" + w2(++a2 + y, 36);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(9), a2 = t2(10), y = t2(46);
      k2.exports = !e2 && !a2(function() {
        return Object.defineProperty(y("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(23), y = e2.document, w2 = a2(y) && a2(y.createElement);
      k2.exports = function(O) {
        return w2 ? y.createElement(O) : {};
      };
    }, (k2, d2, t2) => {
      var e2 = t2(9), a2 = t2(48), y = t2(14);
      k2.exports = e2 ? function(w2, O, p2) {
        return a2.f(w2, O, y(1, p2));
      } : function(w2, O, p2) {
        return w2[O] = p2, w2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(9), a2 = t2(45), y = t2(49), w2 = t2(50), O = t2(21), p2 = TypeError, h2 = Object.defineProperty, l2 = Object.getOwnPropertyDescriptor, c2 = "enumerable", b2 = "configurable", L2 = "writable";
      d2.f = e2 ? y ? function(M, x2, I2) {
        if (w2(M), x2 = O(x2), w2(I2), typeof M == "function" && x2 === "prototype" && "value" in I2 && L2 in I2 && !I2[L2]) {
          var v = l2(M, x2);
          v && v[L2] && (M[x2] = I2.value, I2 = { configurable: b2 in I2 ? I2[b2] : v[b2], enumerable: c2 in I2 ? I2[c2] : v[c2], writable: false });
        }
        return h2(M, x2, I2);
      } : h2 : function(M, x2, I2) {
        if (w2(M), x2 = O(x2), w2(I2), a2)
          try {
            return h2(M, x2, I2);
          } catch {
          }
        if ("get" in I2 || "set" in I2)
          throw p2("Accessors not supported");
        return "value" in I2 && (M[x2] = I2.value), M;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(9), a2 = t2(10);
      k2.exports = e2 && a2(function() {
        return Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype != 42;
      });
    }, (k2, d2, t2) => {
      var e2 = t2(23), a2 = String, y = TypeError;
      k2.exports = function(w2) {
        if (e2(w2))
          return w2;
        throw y(a2(w2) + " is not an object");
      };
    }, (k2, d2, t2) => {
      var e2 = t2(24), a2 = t2(48), y = t2(52), w2 = t2(41);
      k2.exports = function(O, p2, h2, l2) {
        l2 || (l2 = {});
        var c2 = l2.enumerable, b2 = l2.name !== void 0 ? l2.name : p2;
        if (e2(h2) && y(h2, b2, l2), l2.global)
          c2 ? O[p2] = h2 : w2(p2, h2);
        else {
          try {
            l2.unsafe ? O[p2] && (c2 = true) : delete O[p2];
          } catch {
          }
          c2 ? O[p2] = h2 : a2.f(O, p2, { value: h2, enumerable: false, configurable: !l2.nonConfigurable, writable: !l2.nonWritable });
        }
        return O;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = t2(10), y = t2(24), w2 = t2(42), O = t2(9), p2 = t2(53).CONFIGURABLE, h2 = t2(54), l2 = t2(55), c2 = l2.enforce, b2 = l2.get, L2 = String, m2 = Object.defineProperty, M = e2("".slice), x2 = e2("".replace), I2 = e2([].join), v = O && !a2(function() {
        return m2(function() {
        }, "length", { value: 8 }).length !== 8;
      }), i2 = String(String).split("String"), A2 = k2.exports = function(n2, s, r) {
        M(L2(s), 0, 7) === "Symbol(" && (s = "[" + x2(L2(s), /^Symbol\(([^)]*)\)/, "$1") + "]"), r && r.getter && (s = "get " + s), r && r.setter && (s = "set " + s), (!w2(n2, "name") || p2 && n2.name !== s) && (O ? m2(n2, "name", { value: s, configurable: true }) : n2.name = s), v && r && w2(r, "arity") && n2.length !== r.arity && m2(n2, "length", { value: r.arity });
        try {
          r && w2(r, "constructor") && r.constructor ? O && m2(n2, "prototype", { writable: false }) : n2.prototype && (n2.prototype = void 0);
        } catch {
        }
        var u = c2(n2);
        return w2(u, "source") || (u.source = I2(i2, typeof s == "string" ? s : "")), n2;
      };
      Function.prototype.toString = A2(function() {
        return y(this) && b2(this).source || h2(this);
      }, "toString");
    }, (k2, d2, t2) => {
      var e2 = t2(9), a2 = t2(42), y = Function.prototype, w2 = e2 && Object.getOwnPropertyDescriptor, O = a2(y, "name"), p2 = O && (function() {
      }).name === "something", h2 = O && (!e2 || e2 && w2(y, "name").configurable);
      k2.exports = { EXISTS: O, PROPER: p2, CONFIGURABLE: h2 };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = t2(24), y = t2(40), w2 = e2(Function.toString);
      a2(y.inspectSource) || (y.inspectSource = function(O) {
        return w2(O);
      }), k2.exports = y.inspectSource;
    }, (k2, d2, t2) => {
      var e2, a2, y, w2 = t2(56), O = t2(7), p2 = t2(23), h2 = t2(47), l2 = t2(42), c2 = t2(40), b2 = t2(57), L2 = t2(58), m2 = "Object already initialized", M = O.TypeError, x2 = O.WeakMap;
      if (w2 || c2.state) {
        var I2 = c2.state || (c2.state = new x2());
        I2.get = I2.get, I2.has = I2.has, I2.set = I2.set, e2 = function(i2, A2) {
          if (I2.has(i2))
            throw M(m2);
          return A2.facade = i2, I2.set(i2, A2), A2;
        }, a2 = function(i2) {
          return I2.get(i2) || {};
        }, y = function(i2) {
          return I2.has(i2);
        };
      } else {
        var v = b2("state");
        L2[v] = true, e2 = function(i2, A2) {
          if (l2(i2, v))
            throw M(m2);
          return A2.facade = i2, h2(i2, v, A2), A2;
        }, a2 = function(i2) {
          return l2(i2, v) ? i2[v] : {};
        }, y = function(i2) {
          return l2(i2, v);
        };
      }
      k2.exports = { set: e2, get: a2, has: y, enforce: function(i2) {
        return y(i2) ? a2(i2) : e2(i2, {});
      }, getterFor: function(i2) {
        return function(A2) {
          var n2;
          if (!p2(A2) || (n2 = a2(A2)).type !== i2)
            throw M("Incompatible receiver, " + i2 + " required");
          return n2;
        };
      } };
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(24), y = e2.WeakMap;
      k2.exports = a2(y) && /native code/.test(String(y));
    }, (k2, d2, t2) => {
      var e2 = t2(38), a2 = t2(44), y = e2("keys");
      k2.exports = function(w2) {
        return y[w2] || (y[w2] = a2(w2));
      };
    }, (k2) => {
      k2.exports = {};
    }, (k2, d2, t2) => {
      var e2 = t2(42), a2 = t2(60), y = t2(8), w2 = t2(48);
      k2.exports = function(O, p2, h2) {
        for (var l2 = a2(p2), c2 = w2.f, b2 = y.f, L2 = 0; L2 < l2.length; L2++) {
          var m2 = l2[L2];
          e2(O, m2) || h2 && e2(h2, m2) || c2(O, m2, b2(p2, m2));
        }
      };
    }, (k2, d2, t2) => {
      var e2 = t2(27), a2 = t2(17), y = t2(61), w2 = t2(70), O = t2(50), p2 = a2([].concat);
      k2.exports = e2("Reflect", "ownKeys") || function(l2) {
        var c2 = y.f(O(l2)), b2 = w2.f;
        return b2 ? p2(c2, b2(l2)) : c2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(62), a2 = t2(69).concat("length", "prototype");
      d2.f = Object.getOwnPropertyNames || function(w2) {
        return e2(w2, a2);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = t2(42), y = t2(15), w2 = t2(63).indexOf, O = t2(58), p2 = e2([].push);
      k2.exports = function(h2, l2) {
        var c2, b2 = y(h2), L2 = 0, m2 = [];
        for (c2 in b2)
          !a2(O, c2) && a2(b2, c2) && p2(m2, c2);
        for (; l2.length > L2; )
          a2(b2, c2 = l2[L2++]) && (~w2(m2, c2) || p2(m2, c2));
        return m2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(15), a2 = t2(64), y = t2(67), w2 = function(O) {
        return function(p2, h2, l2) {
          var c2, b2 = e2(p2), L2 = y(b2), m2 = a2(l2, L2);
          if (O && h2 != h2) {
            for (; L2 > m2; )
              if ((c2 = b2[m2++]) != c2)
                return true;
          } else
            for (; L2 > m2; m2++)
              if ((O || m2 in b2) && b2[m2] === h2)
                return O || m2 || 0;
          return !O && -1;
        };
      };
      k2.exports = { includes: w2(true), indexOf: w2(false) };
    }, (k2, d2, t2) => {
      var e2 = t2(65), a2 = Math.max, y = Math.min;
      k2.exports = function(w2, O) {
        var p2 = e2(w2);
        return p2 < 0 ? a2(p2 + O, 0) : y(p2, O);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(66);
      k2.exports = function(a2) {
        var y = +a2;
        return y != y || y === 0 ? 0 : e2(y);
      };
    }, (k2) => {
      var d2 = Math.ceil, t2 = Math.floor;
      k2.exports = Math.trunc || function(a2) {
        var y = +a2;
        return (y > 0 ? t2 : d2)(y);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(68);
      k2.exports = function(a2) {
        return e2(a2.length);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(65), a2 = Math.min;
      k2.exports = function(y) {
        return y > 0 ? a2(e2(y), 9007199254740991) : 0;
      };
    }, (k2) => {
      k2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    }, (k2, d2) => {
      d2.f = Object.getOwnPropertySymbols;
    }, (k2, d2, t2) => {
      var e2 = t2(10), a2 = t2(24), y = /#|\.prototype\./, w2 = function(c2, b2) {
        var L2 = p2[O(c2)];
        return L2 == l2 || L2 != h2 && (a2(b2) ? e2(b2) : !!b2);
      }, O = w2.normalize = function(c2) {
        return String(c2).replace(y, ".").toLowerCase();
      }, p2 = w2.data = {}, h2 = w2.NATIVE = "N", l2 = w2.POLYFILL = "P";
      k2.exports = w2;
    }, (k2, d2, t2) => {
      var e2 = t2(37), a2 = t2(73), y = t2(48).f, w2 = e2("unscopables"), O = Array.prototype;
      O[w2] == null && y(O, w2, { configurable: true, value: a2(null) }), k2.exports = function(p2) {
        O[w2][p2] = true;
      };
    }, (k2, d2, t2) => {
      var e2, a2 = t2(50), y = t2(74), w2 = t2(69), O = t2(58), p2 = t2(76), h2 = t2(46), l2 = t2(57), c2 = "prototype", b2 = "script", L2 = l2("IE_PROTO"), m2 = function() {
      }, M = function(v) {
        return "<" + b2 + ">" + v + "</" + b2 + ">";
      }, x2 = function(v) {
        v.write(M("")), v.close();
        var i2 = v.parentWindow.Object;
        return v = null, i2;
      }, I2 = function() {
        try {
          e2 = new ActiveXObject("htmlfile");
        } catch {
        }
        I2 = typeof document < "u" ? document.domain && e2 ? x2(e2) : function() {
          var i2, A2 = h2("iframe"), n2 = "java" + b2 + ":";
          return A2.style.display = "none", p2.appendChild(A2), A2.src = String(n2), (i2 = A2.contentWindow.document).open(), i2.write(M("document.F=Object")), i2.close(), i2.F;
        }() : x2(e2);
        for (var v = w2.length; v--; )
          delete I2[c2][w2[v]];
        return I2();
      };
      O[L2] = true, k2.exports = Object.create || function(i2, A2) {
        var n2;
        return i2 !== null ? (m2[c2] = a2(i2), n2 = new m2(), m2[c2] = null, n2[L2] = i2) : n2 = I2(), A2 === void 0 ? n2 : y.f(n2, A2);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(9), a2 = t2(49), y = t2(48), w2 = t2(50), O = t2(15), p2 = t2(75);
      d2.f = e2 && !a2 ? Object.defineProperties : function(l2, c2) {
        w2(l2);
        for (var b2, L2 = O(c2), m2 = p2(c2), M = m2.length, x2 = 0; M > x2; )
          y.f(l2, b2 = m2[x2++], L2[b2]);
        return l2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(62), a2 = t2(69);
      k2.exports = Object.keys || function(w2) {
        return e2(w2, a2);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(27);
      k2.exports = e2("document", "documentElement");
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(17);
      k2.exports = function(y, w2) {
        return a2(e2[y].prototype[w2]);
      };
    }, (k2, d2, t2) => {
      t2(79);
    }, (k2, d2, t2) => {
      var e2 = t2(80), a2 = t2(67), y = t2(65), w2 = e2.aTypedArray;
      (0, e2.exportTypedArrayMethod)("at", function(p2) {
        var h2 = w2(this), l2 = a2(h2), c2 = y(p2), b2 = c2 >= 0 ? c2 : l2 + c2;
        return b2 < 0 || b2 >= l2 ? void 0 : h2[b2];
      });
    }, (k2, d2, t2) => {
      var e2, a2, y, w2 = t2(81), O = t2(9), p2 = t2(7), h2 = t2(24), l2 = t2(23), c2 = t2(42), b2 = t2(82), L2 = t2(35), m2 = t2(47), M = t2(51), x2 = t2(84), I2 = t2(28), v = t2(85), i2 = t2(87), A2 = t2(37), n2 = t2(44), s = t2(55), r = s.enforce, u = s.get, C = p2.Int8Array, D = C && C.prototype, o = p2.Uint8ClampedArray, F = o && o.prototype, z = C && v(C), q = D && v(D), J = Object.prototype, $ = p2.TypeError, S = A2("toStringTag"), f = n2("TYPED_ARRAY_TAG"), P = "TypedArrayConstructor", g = w2 && !!i2 && b2(p2.opera) !== "Opera", _ = false, U = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, N = { BigInt64Array: 8, BigUint64Array: 8 }, G = function(W) {
        var X = v(W);
        if (l2(X)) {
          var K = u(X);
          return K && c2(K, P) ? K[P] : G(X);
        }
      }, V = function(W) {
        if (!l2(W))
          return false;
        var X = b2(W);
        return c2(U, X) || c2(N, X);
      };
      for (e2 in U)
        (y = (a2 = p2[e2]) && a2.prototype) ? r(y)[P] = a2 : g = false;
      for (e2 in N)
        (y = (a2 = p2[e2]) && a2.prototype) && (r(y)[P] = a2);
      if ((!g || !h2(z) || z === Function.prototype) && (z = function() {
        throw $("Incorrect invocation");
      }, g))
        for (e2 in U)
          p2[e2] && i2(p2[e2], z);
      if ((!g || !q || q === J) && (q = z.prototype, g))
        for (e2 in U)
          p2[e2] && i2(p2[e2].prototype, q);
      if (g && v(F) !== q && i2(F, q), O && !c2(q, S)) {
        _ = true, x2(q, S, { configurable: true, get: function() {
          return l2(this) ? this[f] : void 0;
        } });
        for (e2 in U)
          p2[e2] && m2(p2[e2], f, e2);
      }
      k2.exports = { NATIVE_ARRAY_BUFFER_VIEWS: g, TYPED_ARRAY_TAG: _ && f, aTypedArray: function(W) {
        if (V(W))
          return W;
        throw $("Target is not a typed array");
      }, aTypedArrayConstructor: function(W) {
        if (h2(W) && (!i2 || I2(z, W)))
          return W;
        throw $(L2(W) + " is not a typed array constructor");
      }, exportTypedArrayMethod: function(W, X, K, H) {
        if (O) {
          if (K)
            for (var Z in U) {
              var dt = p2[Z];
              if (dt && c2(dt.prototype, W))
                try {
                  delete dt.prototype[W];
                } catch {
                  try {
                    dt.prototype[W] = X;
                  } catch {
                  }
                }
            }
          q[W] && !K || M(q, W, K ? X : g && D[W] || X, H);
        }
      }, exportTypedArrayStaticMethod: function(W, X, K) {
        var H, Z;
        if (O) {
          if (i2) {
            if (K) {
              for (H in U)
                if ((Z = p2[H]) && c2(Z, W))
                  try {
                    delete Z[W];
                  } catch {
                  }
            }
            if (z[W] && !K)
              return;
            try {
              return M(z, W, K ? X : g && z[W] || X);
            } catch {
            }
          }
          for (H in U)
            !(Z = p2[H]) || Z[W] && !K || M(Z, W, X);
        }
      }, getTypedArrayConstructor: G, isView: function(X) {
        if (!l2(X))
          return false;
        var K = b2(X);
        return K === "DataView" || c2(U, K) || c2(N, K);
      }, isTypedArray: V, TypedArray: z, TypedArrayPrototype: q };
    }, (k2) => {
      k2.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
    }, (k2, d2, t2) => {
      var e2 = t2(83), a2 = t2(24), y = t2(18), w2 = t2(37)("toStringTag"), O = Object, p2 = y(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments";
      k2.exports = e2 ? y : function(h2) {
        var l2, c2, b2;
        return h2 === void 0 ? "Undefined" : h2 === null ? "Null" : typeof (c2 = function(L2, m2) {
          try {
            return L2[m2];
          } catch {
          }
        }(l2 = O(h2), w2)) == "string" ? c2 : p2 ? y(l2) : (b2 = y(l2)) == "Object" && a2(l2.callee) ? "Arguments" : b2;
      };
    }, (k2, d2, t2) => {
      var e2 = {};
      e2[t2(37)("toStringTag")] = "z", k2.exports = String(e2) === "[object z]";
    }, (k2, d2, t2) => {
      var e2 = t2(52), a2 = t2(48);
      k2.exports = function(y, w2, O) {
        return O.get && e2(O.get, w2, { getter: true }), O.set && e2(O.set, w2, { setter: true }), a2.f(y, w2, O);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(42), a2 = t2(24), y = t2(43), w2 = t2(57), O = t2(86), p2 = w2("IE_PROTO"), h2 = Object, l2 = h2.prototype;
      k2.exports = O ? h2.getPrototypeOf : function(c2) {
        var b2 = y(c2);
        if (e2(b2, p2))
          return b2[p2];
        var L2 = b2.constructor;
        return a2(L2) && b2 instanceof L2 ? L2.prototype : b2 instanceof h2 ? l2 : null;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(10);
      k2.exports = !e2(function() {
        function a2() {
        }
        return a2.prototype.constructor = null, Object.getPrototypeOf(new a2()) !== a2.prototype;
      });
    }, (k2, d2, t2) => {
      var e2 = t2(88), a2 = t2(50), y = t2(89);
      k2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var w2, O = false, p2 = {};
        try {
          (w2 = e2(Object.prototype, "__proto__", "set"))(p2, []), O = p2 instanceof Array;
        } catch {
        }
        return function(l2, c2) {
          return a2(l2), y(c2), O ? w2(l2, c2) : l2.__proto__ = c2, l2;
        };
      }() : void 0);
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = t2(34);
      k2.exports = function(y, w2, O) {
        try {
          return e2(a2(Object.getOwnPropertyDescriptor(y, w2)[O]));
        } catch {
        }
      };
    }, (k2, d2, t2) => {
      var e2 = t2(24), a2 = String, y = TypeError;
      k2.exports = function(w2) {
        if (typeof w2 == "object" || e2(w2))
          return w2;
        throw y("Can't set " + a2(w2) + " as a prototype");
      };
    }, (k2, d2, t2) => {
      t2(91), t2(98), t2(100), t2(123), t2(125);
      var e2 = t2(137);
      k2.exports = e2.structuredClone;
    }, (k2, d2, t2) => {
      var e2 = t2(15), a2 = t2(72), y = t2(92), w2 = t2(55), O = t2(48).f, p2 = t2(93), h2 = t2(97), l2 = t2(39), c2 = t2(9), b2 = "Array Iterator", L2 = w2.set, m2 = w2.getterFor(b2);
      k2.exports = p2(Array, "Array", function(x2, I2) {
        L2(this, { type: b2, target: e2(x2), index: 0, kind: I2 });
      }, function() {
        var x2 = m2(this), I2 = x2.target, v = x2.kind, i2 = x2.index++;
        return !I2 || i2 >= I2.length ? (x2.target = void 0, h2(void 0, true)) : h2(v == "keys" ? i2 : v == "values" ? I2[i2] : [i2, I2[i2]], false);
      }, "values");
      var M = y.Arguments = y.Array;
      if (a2("keys"), a2("values"), a2("entries"), !l2 && c2 && M.name !== "values")
        try {
          O(M, "name", { value: "values" });
        } catch {
        }
    }, (k2) => {
      k2.exports = {};
    }, (k2, d2, t2) => {
      var e2 = t2(6), a2 = t2(11), y = t2(39), w2 = t2(53), O = t2(24), p2 = t2(94), h2 = t2(85), l2 = t2(87), c2 = t2(96), b2 = t2(47), L2 = t2(51), m2 = t2(37), M = t2(92), x2 = t2(95), I2 = w2.PROPER, v = w2.CONFIGURABLE, i2 = x2.IteratorPrototype, A2 = x2.BUGGY_SAFARI_ITERATORS, n2 = m2("iterator"), s = "keys", r = "values", u = "entries", C = function() {
        return this;
      };
      k2.exports = function(D, o, F, z, q, J, $) {
        p2(F, o, z);
        var S, f, P, g = function(X) {
          if (X === q && V)
            return V;
          if (!A2 && X in N)
            return N[X];
          switch (X) {
            case s:
              return function() {
                return new F(this, X);
              };
            case r:
              return function() {
                return new F(this, X);
              };
            case u:
              return function() {
                return new F(this, X);
              };
          }
          return function() {
            return new F(this);
          };
        }, _ = o + " Iterator", U = false, N = D.prototype, G = N[n2] || N["@@iterator"] || q && N[q], V = !A2 && G || g(q), W = o == "Array" && N.entries || G;
        if (W && (S = h2(W.call(new D()))) !== Object.prototype && S.next && (y || h2(S) === i2 || (l2 ? l2(S, i2) : O(S[n2]) || L2(S, n2, C)), c2(S, _, true, true), y && (M[_] = C)), I2 && q == r && G && G.name !== r && (!y && v ? b2(N, "name", r) : (U = true, V = function() {
          return a2(G, this);
        })), q)
          if (f = { values: g(r), keys: J ? V : g(s), entries: g(u) }, $)
            for (P in f)
              (A2 || U || !(P in N)) && L2(N, P, f[P]);
          else
            e2({ target: o, proto: true, forced: A2 || U }, f);
        return y && !$ || N[n2] === V || L2(N, n2, V, { name: q }), M[o] = V, f;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(95).IteratorPrototype, a2 = t2(73), y = t2(14), w2 = t2(96), O = t2(92), p2 = function() {
        return this;
      };
      k2.exports = function(h2, l2, c2, b2) {
        var L2 = l2 + " Iterator";
        return h2.prototype = a2(e2, { next: y(+!b2, c2) }), w2(h2, L2, false, true), O[L2] = p2, h2;
      };
    }, (k2, d2, t2) => {
      var e2, a2, y, w2 = t2(10), O = t2(24), p2 = t2(23), h2 = t2(73), l2 = t2(85), c2 = t2(51), b2 = t2(37), L2 = t2(39), m2 = b2("iterator"), M = false;
      [].keys && ("next" in (y = [].keys()) ? (a2 = l2(l2(y))) !== Object.prototype && (e2 = a2) : M = true), !p2(e2) || w2(function() {
        var x2 = {};
        return e2[m2].call(x2) !== x2;
      }) ? e2 = {} : L2 && (e2 = h2(e2)), O(e2[m2]) || c2(e2, m2, function() {
        return this;
      }), k2.exports = { IteratorPrototype: e2, BUGGY_SAFARI_ITERATORS: M };
    }, (k2, d2, t2) => {
      var e2 = t2(48).f, a2 = t2(42), y = t2(37)("toStringTag");
      k2.exports = function(w2, O, p2) {
        w2 && !p2 && (w2 = w2.prototype), w2 && !a2(w2, y) && e2(w2, y, { configurable: true, value: O });
      };
    }, (k2) => {
      k2.exports = function(d2, t2) {
        return { value: d2, done: t2 };
      };
    }, (k2, d2, t2) => {
      var e2 = t2(83), a2 = t2(51), y = t2(99);
      e2 || a2(Object.prototype, "toString", y, { unsafe: true });
    }, (k2, d2, t2) => {
      var e2 = t2(83), a2 = t2(82);
      k2.exports = e2 ? {}.toString : function() {
        return "[object " + a2(this) + "]";
      };
    }, (k2, d2, t2) => {
      t2(101);
    }, (k2, d2, t2) => {
      t2(102)("Map", function(e2) {
        return function() {
          return e2(this, arguments.length ? arguments[0] : void 0);
        };
      }, t2(120));
    }, (k2, d2, t2) => {
      var e2 = t2(6), a2 = t2(7), y = t2(17), w2 = t2(71), O = t2(51), p2 = t2(103), h2 = t2(110), l2 = t2(117), c2 = t2(24), b2 = t2(20), L2 = t2(23), m2 = t2(10), M = t2(118), x2 = t2(96), I2 = t2(119);
      k2.exports = function(v, i2, A2) {
        var n2 = v.indexOf("Map") !== -1, s = v.indexOf("Weak") !== -1, r = n2 ? "set" : "add", u = a2[v], C = u && u.prototype, D = u, o = {}, F = function(f) {
          var P = y(C[f]);
          O(C, f, f == "add" ? function(_) {
            return P(this, _ === 0 ? 0 : _), this;
          } : f == "delete" ? function(g) {
            return !(s && !L2(g)) && P(this, g === 0 ? 0 : g);
          } : f == "get" ? function(_) {
            return s && !L2(_) ? void 0 : P(this, _ === 0 ? 0 : _);
          } : f == "has" ? function(_) {
            return !(s && !L2(_)) && P(this, _ === 0 ? 0 : _);
          } : function(_, U) {
            return P(this, _ === 0 ? 0 : _, U), this;
          });
        };
        if (w2(v, !c2(u) || !(s || C.forEach && !m2(function() {
          new u().entries().next();
        }))))
          D = A2.getConstructor(i2, v, n2, r), p2.enable();
        else if (w2(v, true)) {
          var z = new D(), q = z[r](s ? {} : -0, 1) != z, J = m2(function() {
            z.has(1);
          }), $ = M(function(f) {
            new u(f);
          }), S = !s && m2(function() {
            for (var f = new u(), P = 5; P--; )
              f[r](P, P);
            return !f.has(-0);
          });
          $ || ((D = i2(function(f, P) {
            l2(f, C);
            var g = I2(new u(), f, D);
            return b2(P) || h2(P, g[r], { that: g, AS_ENTRIES: n2 }), g;
          })).prototype = C, C.constructor = D), (J || S) && (F("delete"), F("has"), n2 && F("get")), (S || q) && F(r), s && C.clear && delete C.clear;
        }
        return o[v] = D, e2({ global: true, constructor: true, forced: D != u }, o), x2(D, v), s || A2.setStrong(D, v, n2), D;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(6), a2 = t2(17), y = t2(58), w2 = t2(23), O = t2(42), p2 = t2(48).f, h2 = t2(61), l2 = t2(104), c2 = t2(107), b2 = t2(44), L2 = t2(109), m2 = false, M = b2("meta"), x2 = 0, I2 = function(i2) {
        p2(i2, M, { value: { objectID: "O" + x2++, weakData: {} } });
      }, v = k2.exports = { enable: function() {
        v.enable = function() {
        }, m2 = true;
        var i2 = h2.f, A2 = a2([].splice), n2 = {};
        n2[M] = 1, i2(n2).length && (h2.f = function(s) {
          for (var r = i2(s), u = 0, C = r.length; u < C; u++)
            if (r[u] === M) {
              A2(r, u, 1);
              break;
            }
          return r;
        }, e2({ target: "Object", stat: true, forced: true }, { getOwnPropertyNames: l2.f }));
      }, fastKey: function(i2, A2) {
        if (!w2(i2))
          return typeof i2 == "symbol" ? i2 : (typeof i2 == "string" ? "S" : "P") + i2;
        if (!O(i2, M)) {
          if (!c2(i2))
            return "F";
          if (!A2)
            return "E";
          I2(i2);
        }
        return i2[M].objectID;
      }, getWeakData: function(i2, A2) {
        if (!O(i2, M)) {
          if (!c2(i2))
            return true;
          if (!A2)
            return false;
          I2(i2);
        }
        return i2[M].weakData;
      }, onFreeze: function(i2) {
        return L2 && m2 && c2(i2) && !O(i2, M) && I2(i2), i2;
      } };
      y[M] = true;
    }, (k2, d2, t2) => {
      var e2 = t2(18), a2 = t2(15), y = t2(61).f, w2 = t2(105), O = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      k2.exports.f = function(h2) {
        return O && e2(h2) == "Window" ? function(l2) {
          try {
            return y(l2);
          } catch {
            return w2(O);
          }
        }(h2) : y(a2(h2));
      };
    }, (k2, d2, t2) => {
      var e2 = t2(64), a2 = t2(67), y = t2(106), w2 = Array, O = Math.max;
      k2.exports = function(p2, h2, l2) {
        for (var c2 = a2(p2), b2 = e2(h2, c2), L2 = e2(l2 === void 0 ? c2 : l2, c2), m2 = w2(O(L2 - b2, 0)), M = 0; b2 < L2; b2++, M++)
          y(m2, M, p2[b2]);
        return m2.length = M, m2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(21), a2 = t2(48), y = t2(14);
      k2.exports = function(w2, O, p2) {
        var h2 = e2(O);
        h2 in w2 ? a2.f(w2, h2, y(0, p2)) : w2[h2] = p2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(10), a2 = t2(23), y = t2(18), w2 = t2(108), O = Object.isExtensible, p2 = e2(function() {
      });
      k2.exports = p2 || w2 ? function(l2) {
        return !!a2(l2) && (!w2 || y(l2) != "ArrayBuffer") && (!O || O(l2));
      } : O;
    }, (k2, d2, t2) => {
      var e2 = t2(10);
      k2.exports = e2(function() {
        if (typeof ArrayBuffer == "function") {
          var a2 = new ArrayBuffer(8);
          Object.isExtensible(a2) && Object.defineProperty(a2, "a", { value: 8 });
        }
      });
    }, (k2, d2, t2) => {
      var e2 = t2(10);
      k2.exports = !e2(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      });
    }, (k2, d2, t2) => {
      var e2 = t2(111), a2 = t2(11), y = t2(50), w2 = t2(35), O = t2(113), p2 = t2(67), h2 = t2(28), l2 = t2(114), c2 = t2(115), b2 = t2(116), L2 = TypeError, m2 = function(x2, I2) {
        this.stopped = x2, this.result = I2;
      }, M = m2.prototype;
      k2.exports = function(x2, I2, v) {
        var i2, A2, n2, s, r, u, C, D = v && v.that, o = !(!v || !v.AS_ENTRIES), F = !(!v || !v.IS_RECORD), z = !(!v || !v.IS_ITERATOR), q = !(!v || !v.INTERRUPTED), J = e2(I2, D), $ = function(f) {
          return i2 && b2(i2, "normal", f), new m2(true, f);
        }, S = function(f) {
          return o ? (y(f), q ? J(f[0], f[1], $) : J(f[0], f[1])) : q ? J(f, $) : J(f);
        };
        if (F)
          i2 = x2.iterator;
        else if (z)
          i2 = x2;
        else {
          if (!(A2 = c2(x2)))
            throw L2(w2(x2) + " is not iterable");
          if (O(A2)) {
            for (n2 = 0, s = p2(x2); s > n2; n2++)
              if ((r = S(x2[n2])) && h2(M, r))
                return r;
            return new m2(false);
          }
          i2 = l2(x2, A2);
        }
        for (u = F ? x2.next : i2.next; !(C = a2(u, i2)).done; ) {
          try {
            r = S(C.value);
          } catch (f) {
            b2(i2, "throw", f);
          }
          if (typeof r == "object" && r && h2(M, r))
            return r;
        }
        return new m2(false);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(112), a2 = t2(34), y = t2(12), w2 = e2(e2.bind);
      k2.exports = function(O, p2) {
        return a2(O), p2 === void 0 ? O : y ? w2(O, p2) : function() {
          return O.apply(p2, arguments);
        };
      };
    }, (k2, d2, t2) => {
      var e2 = t2(18), a2 = t2(17);
      k2.exports = function(y) {
        if (e2(y) === "Function")
          return a2(y);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(37), a2 = t2(92), y = e2("iterator"), w2 = Array.prototype;
      k2.exports = function(O) {
        return O !== void 0 && (a2.Array === O || w2[y] === O);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(11), a2 = t2(34), y = t2(50), w2 = t2(35), O = t2(115), p2 = TypeError;
      k2.exports = function(h2, l2) {
        var c2 = arguments.length < 2 ? O(h2) : l2;
        if (a2(c2))
          return y(e2(c2, h2));
        throw p2(w2(h2) + " is not iterable");
      };
    }, (k2, d2, t2) => {
      var e2 = t2(82), a2 = t2(33), y = t2(20), w2 = t2(92), O = t2(37)("iterator");
      k2.exports = function(p2) {
        if (!y(p2))
          return a2(p2, O) || a2(p2, "@@iterator") || w2[e2(p2)];
      };
    }, (k2, d2, t2) => {
      var e2 = t2(11), a2 = t2(50), y = t2(33);
      k2.exports = function(w2, O, p2) {
        var h2, l2;
        a2(w2);
        try {
          if (!(h2 = y(w2, "return"))) {
            if (O === "throw")
              throw p2;
            return p2;
          }
          h2 = e2(h2, w2);
        } catch (c2) {
          l2 = true, h2 = c2;
        }
        if (O === "throw")
          throw p2;
        if (l2)
          throw h2;
        return a2(h2), p2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(28), a2 = TypeError;
      k2.exports = function(y, w2) {
        if (e2(w2, y))
          return y;
        throw a2("Incorrect invocation");
      };
    }, (k2, d2, t2) => {
      var e2 = t2(37)("iterator"), a2 = false;
      try {
        var y = 0, w2 = { next: function() {
          return { done: !!y++ };
        }, return: function() {
          a2 = true;
        } };
        w2[e2] = function() {
          return this;
        }, Array.from(w2, function() {
          throw 2;
        });
      } catch {
      }
      k2.exports = function(O, p2) {
        if (!p2 && !a2)
          return false;
        var h2 = false;
        try {
          var l2 = {};
          l2[e2] = function() {
            return { next: function() {
              return { done: h2 = true };
            } };
          }, O(l2);
        } catch {
        }
        return h2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(24), a2 = t2(23), y = t2(87);
      k2.exports = function(w2, O, p2) {
        var h2, l2;
        return y && e2(h2 = O.constructor) && h2 !== p2 && a2(l2 = h2.prototype) && l2 !== p2.prototype && y(w2, l2), w2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(73), a2 = t2(84), y = t2(121), w2 = t2(111), O = t2(117), p2 = t2(20), h2 = t2(110), l2 = t2(93), c2 = t2(97), b2 = t2(122), L2 = t2(9), m2 = t2(103).fastKey, M = t2(55), x2 = M.set, I2 = M.getterFor;
      k2.exports = { getConstructor: function(v, i2, A2, n2) {
        var s = v(function(o, F) {
          O(o, r), x2(o, { type: i2, index: e2(null), first: void 0, last: void 0, size: 0 }), L2 || (o.size = 0), p2(F) || h2(F, o[n2], { that: o, AS_ENTRIES: A2 });
        }), r = s.prototype, u = I2(i2), C = function(o, F, z) {
          var q, J, $ = u(o), S = D(o, F);
          return S ? S.value = z : ($.last = S = { index: J = m2(F, true), key: F, value: z, previous: q = $.last, next: void 0, removed: false }, $.first || ($.first = S), q && (q.next = S), L2 ? $.size++ : o.size++, J !== "F" && ($.index[J] = S)), o;
        }, D = function(o, F) {
          var z, q = u(o), J = m2(F);
          if (J !== "F")
            return q.index[J];
          for (z = q.first; z; z = z.next)
            if (z.key == F)
              return z;
        };
        return y(r, { clear: function() {
          for (var F = u(this), z = F.index, q = F.first; q; )
            q.removed = true, q.previous && (q.previous = q.previous.next = void 0), delete z[q.index], q = q.next;
          F.first = F.last = void 0, L2 ? F.size = 0 : this.size = 0;
        }, delete: function(o) {
          var F = this, z = u(F), q = D(F, o);
          if (q) {
            var J = q.next, $ = q.previous;
            delete z.index[q.index], q.removed = true, $ && ($.next = J), J && (J.previous = $), z.first == q && (z.first = J), z.last == q && (z.last = $), L2 ? z.size-- : F.size--;
          }
          return !!q;
        }, forEach: function(F) {
          for (var z, q = u(this), J = w2(F, arguments.length > 1 ? arguments[1] : void 0); z = z ? z.next : q.first; )
            for (J(z.value, z.key, this); z && z.removed; )
              z = z.previous;
        }, has: function(F) {
          return !!D(this, F);
        } }), y(r, A2 ? { get: function(F) {
          var z = D(this, F);
          return z && z.value;
        }, set: function(F, z) {
          return C(this, F === 0 ? 0 : F, z);
        } } : { add: function(F) {
          return C(this, F = F === 0 ? 0 : F, F);
        } }), L2 && a2(r, "size", { configurable: true, get: function() {
          return u(this).size;
        } }), s;
      }, setStrong: function(v, i2, A2) {
        var n2 = i2 + " Iterator", s = I2(i2), r = I2(n2);
        l2(v, i2, function(u, C) {
          x2(this, { type: n2, target: u, state: s(u), kind: C, last: void 0 });
        }, function() {
          for (var u = r(this), C = u.kind, D = u.last; D && D.removed; )
            D = D.previous;
          return !u.target || !(u.last = D = D ? D.next : u.state.first) ? (u.target = void 0, c2(void 0, true)) : c2(C == "keys" ? D.key : C == "values" ? D.value : [D.key, D.value], false);
        }, A2 ? "entries" : "values", !A2, true), b2(i2);
      } };
    }, (k2, d2, t2) => {
      var e2 = t2(51);
      k2.exports = function(a2, y, w2) {
        for (var O in y)
          e2(a2, O, y[O], w2);
        return a2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(27), a2 = t2(84), y = t2(37), w2 = t2(9), O = y("species");
      k2.exports = function(p2) {
        var h2 = e2(p2);
        w2 && h2 && !h2[O] && a2(h2, O, { configurable: true, get: function() {
          return this;
        } });
      };
    }, (k2, d2, t2) => {
      t2(124);
    }, (k2, d2, t2) => {
      t2(102)("Set", function(e2) {
        return function() {
          return e2(this, arguments.length ? arguments[0] : void 0);
        };
      }, t2(120));
    }, (k2, d2, t2) => {
      var e2, a2 = t2(39), y = t2(6), w2 = t2(7), O = t2(27), p2 = t2(17), h2 = t2(10), l2 = t2(44), c2 = t2(24), b2 = t2(126), L2 = t2(20), m2 = t2(23), M = t2(26), x2 = t2(110), I2 = t2(50), v = t2(82), i2 = t2(42), A2 = t2(106), n2 = t2(47), s = t2(67), r = t2(127), u = t2(128), C = t2(130), D = t2(131), o = t2(132), F = t2(133), z = w2.Object, q = w2.Array, J = w2.Date, $ = w2.Error, S = w2.EvalError, f = w2.RangeError, P = w2.ReferenceError, g = w2.SyntaxError, _ = w2.TypeError, U = w2.URIError, N = w2.PerformanceMark, G = w2.WebAssembly, V = G && G.CompileError || $, W = G && G.LinkError || $, X = G && G.RuntimeError || $, K = O("DOMException"), H = C.Map, Z = C.has, dt = C.get, lt = C.set, E = D.Set, R = D.add, j = O("Object", "keys"), B = p2([].push), Y = p2(true.valueOf), tt = p2(1 .valueOf), rt = p2("".valueOf), it = p2(J.prototype.getTime), At = l2("structuredClone"), ct = "DataCloneError", vt = "Transferring", ht = function(at) {
        return !h2(function() {
          var Pt = new w2.Set([7]), Et = at(Pt), Ut = at(z(7));
          return Et == Pt || !Et.has(7) || typeof Ut != "object" || Ut != 7;
        }) && at;
      }, mt = function(at, Pt) {
        return !h2(function() {
          var Et = new Pt(), Ut = at({ a: Et, b: Et });
          return !(Ut && Ut.a === Ut.b && Ut.a instanceof Pt && Ut.a.stack === Et.stack);
        });
      }, yt = w2.structuredClone, _t = a2 || !mt(yt, $) || !mt(yt, K) || (e2 = yt, !!h2(function() {
        var at = e2(new w2.AggregateError([1], At, { cause: 3 }));
        return at.name != "AggregateError" || at.errors[0] != 1 || at.message != At || at.cause != 3;
      })), Ct = !yt && ht(function(at) {
        return new N(At, { detail: at }).detail;
      }), Q = ht(yt) || Ct, pt = function(at) {
        throw new K("Uncloneable type: " + at, ct);
      }, xt = function(at, Pt) {
        throw new K((Pt || "Cloning") + " of " + at + " cannot be properly polyfilled in this engine", ct);
      }, Mt = function(at, Pt) {
        return Q || xt(Pt), Q(at);
      }, Ft = function(at, Pt) {
        if (M(at) && pt("Symbol"), !m2(at))
          return at;
        if (Pt) {
          if (Z(Pt, at))
            return dt(Pt, at);
        } else
          Pt = new H();
        var Et, Ut, St, te, Nt, Ht, Rt, Xt, Qt, st, ot, ft = v(at), gt = false;
        switch (ft) {
          case "Array":
            St = q(s(at)), gt = true;
            break;
          case "Object":
            St = {}, gt = true;
            break;
          case "Map":
            St = new H(), gt = true;
            break;
          case "Set":
            St = new E(), gt = true;
            break;
          case "RegExp":
            St = new RegExp(at.source, u(at));
            break;
          case "Error":
            switch (Ut = at.name) {
              case "AggregateError":
                St = O("AggregateError")([]);
                break;
              case "EvalError":
                St = S();
                break;
              case "RangeError":
                St = f();
                break;
              case "ReferenceError":
                St = P();
                break;
              case "SyntaxError":
                St = g();
                break;
              case "TypeError":
                St = _();
                break;
              case "URIError":
                St = U();
                break;
              case "CompileError":
                St = V();
                break;
              case "LinkError":
                St = W();
                break;
              case "RuntimeError":
                St = X();
                break;
              default:
                St = $();
            }
            gt = true;
            break;
          case "DOMException":
            St = new K(at.message, at.name), gt = true;
            break;
          case "DataView":
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array":
            Et = w2[ft], m2(Et) || xt(ft), St = new Et(Ft(at.buffer, Pt), at.byteOffset, ft === "DataView" ? at.byteLength : at.length);
            break;
          case "DOMQuad":
            try {
              St = new DOMQuad(Ft(at.p1, Pt), Ft(at.p2, Pt), Ft(at.p3, Pt), Ft(at.p4, Pt));
            } catch {
              St = Mt(at, ft);
            }
            break;
          case "File":
            if (Q)
              try {
                St = Q(at), v(St) !== ft && (St = void 0);
              } catch {
              }
            if (!St)
              try {
                St = new File([at], at.name, at);
              } catch {
              }
            St || xt(ft);
            break;
          case "FileList":
            if (te = function() {
              var bt;
              try {
                bt = new w2.DataTransfer();
              } catch {
                try {
                  bt = new w2.ClipboardEvent("").clipboardData;
                } catch {
                }
              }
              return bt && bt.items && bt.files ? bt : null;
            }()) {
              for (Nt = 0, Ht = s(at); Nt < Ht; Nt++)
                te.items.add(Ft(at[Nt], Pt));
              St = te.files;
            } else
              St = Mt(at, ft);
            break;
          case "ImageData":
            try {
              St = new ImageData(Ft(at.data, Pt), at.width, at.height, { colorSpace: at.colorSpace });
            } catch {
              St = Mt(at, ft);
            }
            break;
          default:
            if (Q)
              St = Q(at);
            else
              switch (ft) {
                case "BigInt":
                  St = z(at.valueOf());
                  break;
                case "Boolean":
                  St = z(Y(at));
                  break;
                case "Number":
                  St = z(tt(at));
                  break;
                case "String":
                  St = z(rt(at));
                  break;
                case "Date":
                  St = new J(it(at));
                  break;
                case "ArrayBuffer":
                  (Et = w2.DataView) || typeof at.slice == "function" || xt(ft);
                  try {
                    if (typeof at.slice != "function" || at.resizable)
                      for (Ht = at.byteLength, ot = ("maxByteLength" in at) ? { maxByteLength: at.maxByteLength } : void 0, St = new ArrayBuffer(Ht, ot), Qt = new Et(at), st = new Et(St), Nt = 0; Nt < Ht; Nt++)
                        st.setUint8(Nt, Qt.getUint8(Nt));
                    else
                      St = at.slice(0);
                  } catch {
                    throw new K("ArrayBuffer is detached", ct);
                  }
                  break;
                case "SharedArrayBuffer":
                  St = at;
                  break;
                case "Blob":
                  try {
                    St = at.slice(0, at.size, at.type);
                  } catch {
                    xt(ft);
                  }
                  break;
                case "DOMPoint":
                case "DOMPointReadOnly":
                  Et = w2[ft];
                  try {
                    St = Et.fromPoint ? Et.fromPoint(at) : new Et(at.x, at.y, at.z, at.w);
                  } catch {
                    xt(ft);
                  }
                  break;
                case "DOMRect":
                case "DOMRectReadOnly":
                  Et = w2[ft];
                  try {
                    St = Et.fromRect ? Et.fromRect(at) : new Et(at.x, at.y, at.width, at.height);
                  } catch {
                    xt(ft);
                  }
                  break;
                case "DOMMatrix":
                case "DOMMatrixReadOnly":
                  Et = w2[ft];
                  try {
                    St = Et.fromMatrix ? Et.fromMatrix(at) : new Et(at);
                  } catch {
                    xt(ft);
                  }
                  break;
                case "AudioData":
                case "VideoFrame":
                  c2(at.clone) || xt(ft);
                  try {
                    St = at.clone();
                  } catch {
                    pt(ft);
                  }
                  break;
                case "CropTarget":
                case "CryptoKey":
                case "FileSystemDirectoryHandle":
                case "FileSystemFileHandle":
                case "FileSystemHandle":
                case "GPUCompilationInfo":
                case "GPUCompilationMessage":
                case "ImageBitmap":
                case "RTCCertificate":
                case "WebAssembly.Module":
                  xt(ft);
                default:
                  pt(ft);
              }
        }
        if (lt(Pt, at, St), gt)
          switch (ft) {
            case "Array":
            case "Object":
              for (Rt = j(at), Nt = 0, Ht = s(Rt); Nt < Ht; Nt++)
                Xt = Rt[Nt], A2(St, Xt, Ft(at[Xt], Pt));
              break;
            case "Map":
              at.forEach(function(bt, wt) {
                lt(St, Ft(wt, Pt), Ft(bt, Pt));
              });
              break;
            case "Set":
              at.forEach(function(bt) {
                R(St, Ft(bt, Pt));
              });
              break;
            case "Error":
              n2(St, "message", Ft(at.message, Pt)), i2(at, "cause") && n2(St, "cause", Ft(at.cause, Pt)), Ut == "AggregateError" && (St.errors = Ft(at.errors, Pt));
            case "DOMException":
              o && n2(St, "stack", Ft(at.stack, Pt));
          }
        return St;
      };
      y({ global: true, enumerable: true, sham: !F, forced: _t }, { structuredClone: function(Pt) {
        var Et, Ut = r(arguments.length, 1) > 1 && !L2(arguments[1]) ? I2(arguments[1]) : void 0, St = Ut ? Ut.transfer : void 0;
        return St !== void 0 && function(te, Nt) {
          if (!m2(te))
            throw _("Transfer option cannot be converted to a sequence");
          var Ht = [];
          x2(te, function(wt) {
            B(Ht, I2(wt));
          });
          var Rt, Xt, Qt, st, ot, ft, gt = 0, bt = s(Ht);
          if (F)
            for (st = yt(Ht, { transfer: Ht }); gt < bt; )
              lt(Nt, Ht[gt], st[gt++]);
          else
            for (; gt < bt; ) {
              if (Rt = Ht[gt++], Z(Nt, Rt))
                throw new K("Duplicate transferable", ct);
              switch (Xt = v(Rt)) {
                case "ImageBitmap":
                  Qt = w2.OffscreenCanvas, b2(Qt) || xt(Xt, vt);
                  try {
                    (ft = new Qt(Rt.width, Rt.height)).getContext("bitmaprenderer").transferFromImageBitmap(Rt), ot = ft.transferToImageBitmap();
                  } catch {
                  }
                  break;
                case "AudioData":
                case "VideoFrame":
                  c2(Rt.clone) && c2(Rt.close) || xt(Xt, vt);
                  try {
                    ot = Rt.clone(), Rt.close();
                  } catch {
                  }
                  break;
                case "ArrayBuffer":
                  c2(Rt.transfer) || xt(Xt, vt), ot = Rt.transfer();
                  break;
                case "MediaSourceHandle":
                case "MessagePort":
                case "OffscreenCanvas":
                case "ReadableStream":
                case "TransformStream":
                case "WritableStream":
                  xt(Xt, vt);
              }
              if (ot === void 0)
                throw new K("This object cannot be transferred: " + Xt, ct);
              lt(Nt, Rt, ot);
            }
        }(St, Et = new H()), Ft(Pt, Et);
      } });
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = t2(10), y = t2(24), w2 = t2(82), O = t2(27), p2 = t2(54), h2 = function() {
      }, l2 = [], c2 = O("Reflect", "construct"), b2 = /^\s*(?:class|function)\b/, L2 = e2(b2.exec), m2 = !b2.exec(h2), M = function(v) {
        if (!y(v))
          return false;
        try {
          return c2(h2, l2, v), true;
        } catch {
          return false;
        }
      }, x2 = function(v) {
        if (!y(v))
          return false;
        switch (w2(v)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return m2 || !!L2(b2, p2(v));
        } catch {
          return true;
        }
      };
      x2.sham = true, k2.exports = !c2 || a2(function() {
        var I2;
        return M(M.call) || !M(Object) || !M(function() {
          I2 = true;
        }) || I2;
      }) ? x2 : M;
    }, (k2) => {
      var d2 = TypeError;
      k2.exports = function(t2, e2) {
        if (t2 < e2)
          throw d2("Not enough arguments");
        return t2;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(11), a2 = t2(42), y = t2(28), w2 = t2(129), O = RegExp.prototype;
      k2.exports = function(p2) {
        var h2 = p2.flags;
        return h2 !== void 0 || "flags" in O || a2(p2, "flags") || !y(O, p2) ? h2 : e2(w2, p2);
      };
    }, (k2, d2, t2) => {
      var e2 = t2(50);
      k2.exports = function() {
        var a2 = e2(this), y = "";
        return a2.hasIndices && (y += "d"), a2.global && (y += "g"), a2.ignoreCase && (y += "i"), a2.multiline && (y += "m"), a2.dotAll && (y += "s"), a2.unicode && (y += "u"), a2.unicodeSets && (y += "v"), a2.sticky && (y += "y"), y;
      };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = Map.prototype;
      k2.exports = { Map, set: e2(a2.set), get: e2(a2.get), has: e2(a2.has), remove: e2(a2.delete), proto: a2 };
    }, (k2, d2, t2) => {
      var e2 = t2(17), a2 = Set.prototype;
      k2.exports = { Set, add: e2(a2.add), has: e2(a2.has), remove: e2(a2.delete), proto: a2 };
    }, (k2, d2, t2) => {
      var e2 = t2(10), a2 = t2(14);
      k2.exports = !e2(function() {
        var y = Error("a");
        return "stack" in y ? (Object.defineProperty(y, "stack", a2(1, 7)), y.stack !== 7) : true;
      });
    }, (k2, d2, t2) => {
      var e2 = t2(7), a2 = t2(10), y = t2(31), w2 = t2(134), O = t2(135), p2 = t2(136), h2 = e2.structuredClone;
      k2.exports = !!h2 && !a2(function() {
        if (O && y > 92 || p2 && y > 94 || w2 && y > 97)
          return false;
        var l2 = new ArrayBuffer(8), c2 = h2(l2, { transfer: [l2] });
        return l2.byteLength != 0 || c2.byteLength != 8;
      });
    }, (k2, d2, t2) => {
      var e2 = t2(135), a2 = t2(136);
      k2.exports = !e2 && !a2 && typeof window == "object" && typeof document == "object";
    }, (k2) => {
      k2.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    }, (k2, d2, t2) => {
      var e2 = t2(18);
      k2.exports = typeof process < "u" && e2(process) == "process";
    }, (k2, d2, t2) => {
      var e2 = t2(7);
      k2.exports = e2;
    }, (__unused_webpack_module, exports, __w_pdfjs_require__) => {
      var k, t, e, a, re, w, pe, p, h, l, c, b, L, m, Ae, x, I, _e, i, A;
      Object.defineProperty(exports, "__esModule", { value: true }), exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, exports.getDocument = getDocument, exports.version = void 0;
      var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(139), _display_utils = __w_pdfjs_require__(142), _font_loader = __w_pdfjs_require__(145), _canvas = __w_pdfjs_require__(146), _worker_options = __w_pdfjs_require__(149), _is_node = __w_pdfjs_require__(3), _message_handler = __w_pdfjs_require__(150), _metadata = __w_pdfjs_require__(151), _optional_content_config = __w_pdfjs_require__(152), _transport_stream = __w_pdfjs_require__(153), _xfa_text = __w_pdfjs_require__(154);
      const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3;
      let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
      exports.DefaultCanvasFactory = DefaultCanvasFactory;
      let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
      exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
      let DefaultFilterFactory = _display_utils.DOMFilterFactory;
      exports.DefaultFilterFactory = DefaultFilterFactory;
      let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory, createPDFNetworkStream;
      if (exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory, _is_node.isNodeJS) {
        const { NodeCanvasFactory: s, NodeCMapReaderFactory: r, NodeFilterFactory: u, NodeStandardFontDataFactory: C } = __w_pdfjs_require__(155);
        exports.DefaultCanvasFactory = DefaultCanvasFactory = s, exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = r, exports.DefaultFilterFactory = DefaultFilterFactory = u, exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = C;
      }
      if (_is_node.isNodeJS) {
        const { PDFNodeStream: s } = __w_pdfjs_require__(156);
        createPDFNetworkStream = (r) => new s(r);
      } else {
        const { PDFNetworkStream: s } = __w_pdfjs_require__(159), { PDFFetchStream: r } = __w_pdfjs_require__(160);
        createPDFNetworkStream = (u) => (0, _display_utils.isValidFetchUrl)(u.url) ? new r(u) : new s(u);
      }
      function getDocument(s) {
        if (typeof s == "string" || s instanceof URL ? s = { url: s } : (0, _util.isArrayBuffer)(s) && (s = { data: s }), typeof s != "object")
          throw new Error("Invalid parameter in getDocument, need parameter object.");
        if (!s.url && !s.data && !s.range)
          throw new Error("Invalid parameter object: need either .data, .range or .url");
        const r = new PDFDocumentLoadingTask(), { docId: u } = r, C = s.url ? getUrlProp(s.url) : null, D = s.data ? getDataProp(s.data) : null, o = s.httpHeaders || null, F = s.withCredentials === true, z = s.password ?? null, q = s.range instanceof PDFDataRangeTransport ? s.range : null, J = Number.isInteger(s.rangeChunkSize) && s.rangeChunkSize > 0 ? s.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
        let $ = s.worker instanceof PDFWorker ? s.worker : null;
        const S = s.verbosity, f = typeof s.docBaseUrl != "string" || (0, _display_utils.isDataScheme)(s.docBaseUrl) ? null : s.docBaseUrl, P = typeof s.cMapUrl == "string" ? s.cMapUrl : null, g = s.cMapPacked !== false, _ = s.CMapReaderFactory || DefaultCMapReaderFactory, U = typeof s.standardFontDataUrl == "string" ? s.standardFontDataUrl : null, N = s.StandardFontDataFactory || DefaultStandardFontDataFactory, G = s.stopAtErrors !== true, V = Number.isInteger(s.maxImageSize) && s.maxImageSize > -1 ? s.maxImageSize : -1, W = s.isEvalSupported !== false, X = typeof s.isOffscreenCanvasSupported == "boolean" ? s.isOffscreenCanvasSupported : !_is_node.isNodeJS, K = Number.isInteger(s.canvasMaxAreaInBytes) ? s.canvasMaxAreaInBytes : -1, H = typeof s.disableFontFace == "boolean" ? s.disableFontFace : _is_node.isNodeJS, Z = s.fontExtraProperties === true, dt = s.enableXfa === true, lt = s.ownerDocument || globalThis.document, E = s.disableRange === true, R = s.disableStream === true, j = s.disableAutoFetch === true, B = s.pdfBug === true, Y = q ? q.length : s.length ?? NaN, tt = typeof s.useSystemFonts == "boolean" ? s.useSystemFonts : !_is_node.isNodeJS && !H, rt = typeof s.useWorkerFetch == "boolean" ? s.useWorkerFetch : _ === _display_utils.DOMCMapReaderFactory && N === _display_utils.DOMStandardFontDataFactory && (0, _display_utils.isValidFetchUrl)(P, document.baseURI) && (0, _display_utils.isValidFetchUrl)(U, document.baseURI), it = s.canvasFactory || new DefaultCanvasFactory({ ownerDocument: lt }), At = s.filterFactory || new DefaultFilterFactory({ docId: u, ownerDocument: lt });
        (0, _util.setVerbosityLevel)(S);
        const ct = { canvasFactory: it, filterFactory: At };
        if (rt || (ct.cMapReaderFactory = new _({ baseUrl: P, isCompressed: g }), ct.standardFontDataFactory = new N({ baseUrl: U })), !$) {
          const mt = { verbosity: S, port: _worker_options.GlobalWorkerOptions.workerPort };
          $ = mt.port ? PDFWorker.fromPort(mt) : new PDFWorker(mt), r._worker = $;
        }
        const vt = { docId: u, apiVersion: "3.7.107", data: D, password: z, disableAutoFetch: j, rangeChunkSize: J, length: Y, docBaseUrl: f, enableXfa: dt, evaluatorOptions: { maxImageSize: V, disableFontFace: H, ignoreErrors: G, isEvalSupported: W, isOffscreenCanvasSupported: X, canvasMaxAreaInBytes: K, fontExtraProperties: Z, useSystemFonts: tt, cMapUrl: rt ? P : null, standardFontDataUrl: rt ? U : null } }, ht = { ignoreErrors: G, isEvalSupported: W, disableFontFace: H, fontExtraProperties: Z, enableXfa: dt, ownerDocument: lt, disableAutoFetch: j, pdfBug: B, styleElement: null };
        return $.promise.then(function() {
          if (r.destroyed)
            throw new Error("Loading aborted");
          const mt = _fetchDocument($, vt), yt = new Promise(function(_t) {
            let Ct;
            q ? Ct = new _transport_stream.PDFDataTransportStream({ length: Y, initialData: q.initialData, progressiveDone: q.progressiveDone, contentDispositionFilename: q.contentDispositionFilename, disableRange: E, disableStream: R }, q) : D || (Ct = createPDFNetworkStream({ url: C, length: Y, httpHeaders: o, withCredentials: F, rangeChunkSize: J, disableRange: E, disableStream: R })), _t(Ct);
          });
          return Promise.all([mt, yt]).then(function(_t) {
            let [Ct, Q] = _t;
            if (r.destroyed)
              throw new Error("Loading aborted");
            const pt = new _message_handler.MessageHandler(u, Ct, $.port), xt = new WorkerTransport(pt, r, Q, ht, ct);
            r._transport = xt, pt.send("Ready", null);
          });
        }).catch(r._capability.reject), r;
      }
      async function _fetchDocument(s, r) {
        if (s.destroyed)
          throw new Error("Worker was destroyed");
        const u = await s.messageHandler.sendWithPromise("GetDocRequest", r, r.data ? [r.data.buffer] : null);
        if (s.destroyed)
          throw new Error("Worker was destroyed");
        return u;
      }
      function getUrlProp(s) {
        if (s instanceof URL)
          return s.href;
        try {
          return new URL(s, window.location).href;
        } catch {
          if (_is_node.isNodeJS && typeof s == "string")
            return s;
        }
        throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
      }
      function getDataProp(s) {
        if (_is_node.isNodeJS && typeof Buffer < "u" && s instanceof Buffer)
          return (0, _display_utils.deprecated)("Please provide binary data as `Uint8Array`, rather than `Buffer`."), new Uint8Array(s);
        if (s instanceof Uint8Array && s.byteLength === s.buffer.byteLength)
          return s;
        if (typeof s == "string")
          return (0, _util.stringToBytes)(s);
        if (typeof s == "object" && !isNaN(s == null ? void 0 : s.length) || (0, _util.isArrayBuffer)(s))
          return new Uint8Array(s);
        throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
      }
      const d = class {
        constructor() {
          this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = "d" + ue(d, k)._++, this.destroyed = false, this.onPassword = null, this.onProgress = null;
        }
        get promise() {
          return this._capability.promise;
        }
        async destroy() {
          var r;
          this.destroyed = true, await ((r = this._transport) === null || r === void 0 ? void 0 : r.destroy()), this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
        }
      };
      let PDFDocumentLoadingTask = d;
      k = /* @__PURE__ */ new WeakMap(), et(PDFDocumentLoadingTask, k, 0), exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
      class PDFDataRangeTransport {
        constructor(r, u) {
          let C = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], D = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          this.length = r, this.initialData = u, this.progressiveDone = C, this.contentDispositionFilename = D, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
        }
        addRangeListener(r) {
          this._rangeListeners.push(r);
        }
        addProgressListener(r) {
          this._progressListeners.push(r);
        }
        addProgressiveReadListener(r) {
          this._progressiveReadListeners.push(r);
        }
        addProgressiveDoneListener(r) {
          this._progressiveDoneListeners.push(r);
        }
        onDataRange(r, u) {
          for (const C of this._rangeListeners)
            C(r, u);
        }
        onDataProgress(r, u) {
          this._readyCapability.promise.then(() => {
            for (const C of this._progressListeners)
              C(r, u);
          });
        }
        onDataProgressiveRead(r) {
          this._readyCapability.promise.then(() => {
            for (const u of this._progressiveReadListeners)
              u(r);
          });
        }
        onDataProgressiveDone() {
          this._readyCapability.promise.then(() => {
            for (const r of this._progressiveDoneListeners)
              r();
          });
        }
        transportReady() {
          this._readyCapability.resolve();
        }
        requestDataRange(r, u) {
          (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
        }
        abort() {
        }
      }
      exports.PDFDataRangeTransport = PDFDataRangeTransport;
      class PDFDocumentProxy {
        constructor(r, u) {
          this._pdfInfo = r, this._transport = u;
        }
        get annotationStorage() {
          return this._transport.annotationStorage;
        }
        get filterFactory() {
          return this._transport.filterFactory;
        }
        get numPages() {
          return this._pdfInfo.numPages;
        }
        get fingerprints() {
          return this._pdfInfo.fingerprints;
        }
        get isPureXfa() {
          return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
        }
        get allXfaHtml() {
          return this._transport._htmlForXfa;
        }
        getPage(r) {
          return this._transport.getPage(r);
        }
        getPageIndex(r) {
          return this._transport.getPageIndex(r);
        }
        getDestinations() {
          return this._transport.getDestinations();
        }
        getDestination(r) {
          return this._transport.getDestination(r);
        }
        getPageLabels() {
          return this._transport.getPageLabels();
        }
        getPageLayout() {
          return this._transport.getPageLayout();
        }
        getPageMode() {
          return this._transport.getPageMode();
        }
        getViewerPreferences() {
          return this._transport.getViewerPreferences();
        }
        getOpenAction() {
          return this._transport.getOpenAction();
        }
        getAttachments() {
          return this._transport.getAttachments();
        }
        getJavaScript() {
          return this._transport.getJavaScript();
        }
        getJSActions() {
          return this._transport.getDocJSActions();
        }
        getOutline() {
          return this._transport.getOutline();
        }
        getOptionalContentConfig() {
          return this._transport.getOptionalContentConfig();
        }
        getPermissions() {
          return this._transport.getPermissions();
        }
        getMetadata() {
          return this._transport.getMetadata();
        }
        getMarkInfo() {
          return this._transport.getMarkInfo();
        }
        getData() {
          return this._transport.getData();
        }
        saveDocument() {
          return this._transport.saveDocument();
        }
        getDownloadInfo() {
          return this._transport.downloadInfoCapability.promise;
        }
        cleanup() {
          let r = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          return this._transport.startCleanup(r || this.isPureXfa);
        }
        destroy() {
          return this.loadingTask.destroy();
        }
        get loadingParams() {
          return this._transport.loadingParams;
        }
        get loadingTask() {
          return this._transport.loadingTask;
        }
        getFieldObjects() {
          return this._transport.getFieldObjects();
        }
        hasJSActions() {
          return this._transport.hasJSActions();
        }
        getCalculationOrderIds() {
          return this._transport.getCalculationOrderIds();
        }
      }
      exports.PDFDocumentProxy = PDFDocumentProxy;
      class PDFPageProxy {
        constructor(r, u, C) {
          et(this, a);
          et(this, w);
          et(this, t, null);
          et(this, e, false);
          let D = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
          this._pageIndex = r, this._pageInfo = u, this._transport = C, this._stats = D ? new _display_utils.StatTimer() : null, this._pdfBug = D, this.commonObjs = C.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = false, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = false;
        }
        get pageNumber() {
          return this._pageIndex + 1;
        }
        get rotate() {
          return this._pageInfo.rotate;
        }
        get ref() {
          return this._pageInfo.ref;
        }
        get userUnit() {
          return this._pageInfo.userUnit;
        }
        get view() {
          return this._pageInfo.view;
        }
        getViewport() {
          let { scale: r, rotation: u = this.rotate, offsetX: C = 0, offsetY: D = 0, dontFlip: o = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return new _display_utils.PageViewport({ viewBox: this.view, scale: r, rotation: u, offsetX: C, offsetY: D, dontFlip: o });
        }
        getAnnotations() {
          let { intent: r = "display" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const u = this._transport.getRenderingIntent(r);
          return this._transport.getAnnotations(this._pageIndex, u.renderingIntent);
        }
        getJSActions() {
          return this._transport.getPageJSActions(this._pageIndex);
        }
        get isPureXfa() {
          return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
        }
        async getXfa() {
          var r;
          return ((r = this._transport._htmlForXfa) === null || r === void 0 ? void 0 : r.children[this._pageIndex]) || null;
        }
        render(r) {
          var u, C;
          let { canvasContext: D, viewport: o, intent: F = "display", annotationMode: z = _util.AnnotationMode.ENABLE, transform: q = null, background: J = null, optionalContentConfigPromise: $ = null, annotationCanvasMap: S = null, pageColors: f = null, printAnnotationStorage: P = null } = r;
          if ((u = arguments[0]) !== null && u !== void 0 && u.canvasFactory)
            throw new Error("render no longer accepts the `canvasFactory`-option, please pass it to the `getDocument`-function instead.");
          (C = this._stats) === null || C === void 0 || C.time("Overall");
          const g = this._transport.getRenderingIntent(F, z, P);
          ut(this, e, false), nt(this, w, pe).call(this), $ || ($ = this._transport.getOptionalContentConfig());
          let _ = this._intentStates.get(g.cacheKey);
          _ || (_ = /* @__PURE__ */ Object.create(null), this._intentStates.set(g.cacheKey, _)), _.streamReaderCancelTimeout && (clearTimeout(_.streamReaderCancelTimeout), _.streamReaderCancelTimeout = null);
          const U = !!(g.renderingIntent & _util.RenderingIntentFlag.PRINT);
          if (!_.displayReadyCapability) {
            var N;
            _.displayReadyCapability = new _util.PromiseCapability(), _.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, (N = this._stats) === null || N === void 0 || N.time("Page Request"), this._pumpOperatorList(g);
          }
          const G = (X) => {
            var K, H;
            _.renderTasks.delete(V), (this._maybeCleanupAfterRender || U) && ut(this, e, true), nt(this, a, re).call(this, !U), X ? (V.capability.reject(X), this._abortOperatorList({ intentState: _, reason: X instanceof Error ? X : new Error(X) })) : V.capability.resolve(), (K = this._stats) === null || K === void 0 || K.timeEnd("Rendering"), (H = this._stats) === null || H === void 0 || H.timeEnd("Overall");
          }, V = new InternalRenderTask({ callback: G, params: { canvasContext: D, viewport: o, transform: q, background: J }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: S, operatorList: _.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !U, pdfBug: this._pdfBug, pageColors: f });
          (_.renderTasks || (_.renderTasks = /* @__PURE__ */ new Set())).add(V);
          const W = V.task;
          return Promise.all([_.displayReadyCapability.promise, $]).then((X) => {
            var K;
            let [H, Z] = X;
            T(this, e) ? G() : ((K = this._stats) === null || K === void 0 || K.time("Rendering"), V.initializeGraphics({ transparency: H, optionalContentConfig: Z }), V.operatorListChanged());
          }).catch(G), W;
        }
        getOperatorList() {
          let { intent: r = "display", annotationMode: u = _util.AnnotationMode.ENABLE, printAnnotationStorage: C = null } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const D = this._transport.getRenderingIntent(r, u, C, true);
          let o, F = this._intentStates.get(D.cacheKey);
          if (F || (F = /* @__PURE__ */ Object.create(null), this._intentStates.set(D.cacheKey, F)), !F.opListReadCapability) {
            var z;
            o = /* @__PURE__ */ Object.create(null), o.operatorListChanged = function() {
              F.operatorList.lastChunk && (F.opListReadCapability.resolve(F.operatorList), F.renderTasks.delete(o));
            }, F.opListReadCapability = new _util.PromiseCapability(), (F.renderTasks || (F.renderTasks = /* @__PURE__ */ new Set())).add(o), F.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, (z = this._stats) === null || z === void 0 || z.time("Page Request"), this._pumpOperatorList(D);
          }
          return F.opListReadCapability.promise;
        }
        streamTextContent() {
          let { includeMarkedContent: r = false, disableNormalization: u = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: r === true, disableNormalization: u === true }, { highWaterMark: 100, size: (C) => C.items.length });
        }
        getTextContent() {
          let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (this._transport._htmlForXfa)
            return this.getXfa().then((C) => _xfa_text.XfaText.textContent(C));
          const u = this.streamTextContent(r);
          return new Promise(function(C, D) {
            const o = u.getReader(), F = { items: [], styles: /* @__PURE__ */ Object.create(null) };
            (function z() {
              o.read().then(function(q) {
                let { value: J, done: $ } = q;
                $ ? C(F) : (Object.assign(F.styles, J.styles), F.items.push(...J.items), z());
              }, D);
            })();
          });
        }
        getStructTree() {
          return this._transport.getStructTree(this._pageIndex);
        }
        _destroy() {
          this.destroyed = true;
          const r = [];
          for (const u of this._intentStates.values())
            if (this._abortOperatorList({ intentState: u, reason: new Error("Page was destroyed."), force: true }), !u.opListReadCapability)
              for (const C of u.renderTasks)
                r.push(C.completed), C.cancel();
          return this.objs.clear(), ut(this, e, false), nt(this, w, pe).call(this), Promise.all(r);
        }
        cleanup() {
          let r = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          ut(this, e, true);
          const u = nt(this, a, re).call(this, false);
          return r && u && this._stats && (this._stats = new _display_utils.StatTimer()), u;
        }
        _startRenderPage(r, u) {
          var C, D;
          const o = this._intentStates.get(u);
          o && ((C = this._stats) === null || C === void 0 || C.timeEnd("Page Request"), (D = o.displayReadyCapability) === null || D === void 0 || D.resolve(r));
        }
        _renderPageChunk(r, u) {
          for (let C = 0, D = r.length; C < D; C++)
            u.operatorList.fnArray.push(r.fnArray[C]), u.operatorList.argsArray.push(r.argsArray[C]);
          u.operatorList.lastChunk = r.lastChunk, u.operatorList.separateAnnots = r.separateAnnots;
          for (const C of u.renderTasks)
            C.operatorListChanged();
          r.lastChunk && nt(this, a, re).call(this, true);
        }
        _pumpOperatorList(r) {
          let { renderingIntent: u, cacheKey: C, annotationStorageMap: D } = r;
          const o = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: u, cacheKey: C, annotationStorage: D }).getReader(), F = this._intentStates.get(C);
          F.streamReader = o;
          const z = () => {
            o.read().then((q) => {
              let { value: J, done: $ } = q;
              $ ? F.streamReader = null : this._transport.destroyed || (this._renderPageChunk(J, F), z());
            }, (q) => {
              if (F.streamReader = null, !this._transport.destroyed) {
                if (F.operatorList) {
                  F.operatorList.lastChunk = true;
                  for (const J of F.renderTasks)
                    J.operatorListChanged();
                  nt(this, a, re).call(this, true);
                }
                if (F.displayReadyCapability)
                  F.displayReadyCapability.reject(q);
                else {
                  if (!F.opListReadCapability)
                    throw q;
                  F.opListReadCapability.reject(q);
                }
              }
            });
          };
          z();
        }
        _abortOperatorList(r) {
          let { intentState: u, reason: C, force: D = false } = r;
          if (u.streamReader) {
            if (u.streamReaderCancelTimeout && (clearTimeout(u.streamReaderCancelTimeout), u.streamReaderCancelTimeout = null), !D) {
              if (u.renderTasks.size > 0)
                return;
              if (C instanceof _display_utils.RenderingCancelledException) {
                let o = RENDERING_CANCELLED_TIMEOUT;
                C.extraDelay > 0 && C.extraDelay < 1e3 && (o += C.extraDelay), u.streamReaderCancelTimeout = setTimeout(() => {
                  u.streamReaderCancelTimeout = null, this._abortOperatorList({ intentState: u, reason: C, force: true });
                }, o);
                return;
              }
            }
            if (u.streamReader.cancel(new _util.AbortException(C.message)).catch(() => {
            }), u.streamReader = null, !this._transport.destroyed) {
              for (const [o, F] of this._intentStates)
                if (F === u) {
                  this._intentStates.delete(o);
                  break;
                }
              this.cleanup();
            }
          }
        }
        get stats() {
          return this._stats;
        }
      }
      t = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakSet(), re = function() {
        let r = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
        if (nt(this, w, pe).call(this), !T(this, e))
          return false;
        if (r)
          return ut(this, t, setTimeout(() => {
            ut(this, t, null), nt(this, a, re).call(this, false);
          }, DELAYED_CLEANUP_TIMEOUT)), false;
        for (const { renderTasks: u, operatorList: C } of this._intentStates.values())
          if (u.size > 0 || !C.lastChunk)
            return false;
        return this._intentStates.clear(), this.objs.clear(), ut(this, e, false), true;
      }, w = /* @__PURE__ */ new WeakSet(), pe = function() {
        T(this, t) && (clearTimeout(T(this, t)), ut(this, t, null));
      }, exports.PDFPageProxy = PDFPageProxy;
      class LoopbackPort {
        constructor() {
          et(this, p, /* @__PURE__ */ new Set());
          et(this, h, Promise.resolve());
        }
        postMessage(r, u) {
          const C = { data: structuredClone(r, null) };
          T(this, h).then(() => {
            for (const D of T(this, p))
              D.call(this, C);
          });
        }
        addEventListener(r, u) {
          T(this, p).add(u);
        }
        removeEventListener(r, u) {
          T(this, p).delete(u);
        }
        terminate() {
          T(this, p).clear();
        }
      }
      p = /* @__PURE__ */ new WeakMap(), h = /* @__PURE__ */ new WeakMap(), exports.LoopbackPort = LoopbackPort;
      const PDFWorkerUtil = { isWorkerDisabled: false, fallbackWorkerSrc: null, fakeWorkerId: 0 };
      if (exports.PDFWorkerUtil = PDFWorkerUtil, _is_node.isNodeJS && typeof commonjsRequire == "function")
        PDFWorkerUtil.isWorkerDisabled = true, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
      else if (typeof document == "object") {
        var _document, _document$currentScri;
        const s = (_document = document) === null || _document === void 0 || (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;
        s && (PDFWorkerUtil.fallbackWorkerSrc = s.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
      }
      PDFWorkerUtil.isSameOrigin = function(s, r) {
        let u;
        try {
          if (u = new URL(s), !u.origin || u.origin === "null")
            return false;
        } catch {
          return false;
        }
        const C = new URL(r, u);
        return u.origin === C.origin;
      }, PDFWorkerUtil.createCDNWrapper = function(s) {
        const r = `importScripts("${s}");`;
        return URL.createObjectURL(new Blob([r]));
      };
      const _PDFWorker = class {
        constructor() {
          let { name: s = null, port: r = null, verbosity: u = (0, _util.getVerbosityLevel)() } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (r && T(_PDFWorker, l).has(r))
            throw new Error("Cannot use more than one PDFWorker per port.");
          this.name = s, this.destroyed = false, this.verbosity = u, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, r ? (T(_PDFWorker, l).set(r, this), this._initializeFromPort(r)) : this._initialize();
        }
        get promise() {
          return this._readyCapability.promise;
        }
        get port() {
          return this._port;
        }
        get messageHandler() {
          return this._messageHandler;
        }
        _initializeFromPort(s) {
          this._port = s, this._messageHandler = new _message_handler.MessageHandler("main", "worker", s), this._messageHandler.on("ready", function() {
          }), this._readyCapability.resolve(), this._messageHandler.send("configure", { verbosity: this.verbosity });
        }
        _initialize() {
          if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
            let { workerSrc: s } = _PDFWorker;
            try {
              PDFWorkerUtil.isSameOrigin(window.location.href, s) || (s = PDFWorkerUtil.createCDNWrapper(new URL(s, window.location).href));
              const r = new Worker(s), u = new _message_handler.MessageHandler("main", "worker", r), C = () => {
                r.removeEventListener("error", D), u.destroy(), r.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
              }, D = () => {
                this._webWorker || C();
              };
              r.addEventListener("error", D), u.on("test", (F) => {
                r.removeEventListener("error", D), this.destroyed ? C() : F ? (this._messageHandler = u, this._port = r, this._webWorker = r, this._readyCapability.resolve(), u.send("configure", { verbosity: this.verbosity })) : (this._setupFakeWorker(), u.destroy(), r.terminate());
              }), u.on("ready", (F) => {
                if (r.removeEventListener("error", D), this.destroyed)
                  C();
                else
                  try {
                    o();
                  } catch {
                    this._setupFakeWorker();
                  }
              });
              const o = () => {
                const F = new Uint8Array();
                u.send("test", F, [F.buffer]);
              };
              o();
              return;
            } catch {
              (0, _util.info)("The worker has been disabled.");
            }
          }
          this._setupFakeWorker();
        }
        _setupFakeWorker() {
          PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = true), _PDFWorker._setupFakeWorkerGlobal.then((s) => {
            if (this.destroyed) {
              this._readyCapability.reject(new Error("Worker was destroyed"));
              return;
            }
            const r = new LoopbackPort();
            this._port = r;
            const u = "fake" + PDFWorkerUtil.fakeWorkerId++, C = new _message_handler.MessageHandler(u + "_worker", u, r);
            s.setup(C, r);
            const D = new _message_handler.MessageHandler(u, u + "_worker", r);
            this._messageHandler = D, this._readyCapability.resolve(), D.send("configure", { verbosity: this.verbosity });
          }).catch((s) => {
            this._readyCapability.reject(new Error(`Setting up fake worker failed: "${s.message}".`));
          });
        }
        destroy() {
          this.destroyed = true, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), T(_PDFWorker, l).delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
        }
        static fromPort(s) {
          if (s == null || !s.port)
            throw new Error("PDFWorker.fromPort - invalid method signature.");
          return T(this, l).has(s.port) ? T(this, l).get(s.port) : new _PDFWorker(s);
        }
        static get workerSrc() {
          if (_worker_options.GlobalWorkerOptions.workerSrc)
            return _worker_options.GlobalWorkerOptions.workerSrc;
          if (PDFWorkerUtil.fallbackWorkerSrc !== null)
            return _is_node.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
          throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
        }
        static get _mainThreadWorkerMessageHandler() {
          try {
            var s;
            return ((s = globalThis.pdfjsWorker) === null || s === void 0 ? void 0 : s.WorkerMessageHandler) || null;
          } catch {
            return null;
          }
        }
        static get _setupFakeWorkerGlobal() {
          const loader = async () => {
            const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
            if (mainWorkerMessageHandler)
              return mainWorkerMessageHandler;
            if (_is_node.isNodeJS && typeof commonjsRequire == "function") {
              const worker = eval("require")(this.workerSrc);
              return worker.WorkerMessageHandler;
            }
            return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
          };
          return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
        }
      };
      let PDFWorker = _PDFWorker;
      l = /* @__PURE__ */ new WeakMap(), et(PDFWorker, l, /* @__PURE__ */ new WeakMap()), exports.PDFWorker = PDFWorker;
      class WorkerTransport {
        constructor(r, u, C, D, o) {
          et(this, m);
          et(this, c, /* @__PURE__ */ new Map());
          et(this, b, /* @__PURE__ */ new Map());
          et(this, L, /* @__PURE__ */ new Map());
          this.messageHandler = r, this.loadingTask = u, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({ ownerDocument: D.ownerDocument, styleElement: D.styleElement }), this._params = D, this.canvasFactory = o.canvasFactory, this.filterFactory = o.filterFactory, this.cMapReaderFactory = o.cMapReaderFactory, this.standardFontDataFactory = o.standardFontDataFactory, this.destroyed = false, this.destroyCapability = null, this._passwordCapability = null, this._networkStream = C, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
        }
        get annotationStorage() {
          return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
        }
        getRenderingIntent(r) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _util.AnnotationMode.ENABLE, C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, D = arguments.length > 3 && arguments[3] !== void 0 && arguments[3], o = _util.RenderingIntentFlag.DISPLAY, F = null;
          switch (r) {
            case "any":
              o = _util.RenderingIntentFlag.ANY;
              break;
            case "display":
              break;
            case "print":
              o = _util.RenderingIntentFlag.PRINT;
              break;
            default:
              (0, _util.warn)(`getRenderingIntent - invalid intent: ${r}`);
          }
          switch (u) {
            case _util.AnnotationMode.DISABLE:
              o += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
              break;
            case _util.AnnotationMode.ENABLE:
              break;
            case _util.AnnotationMode.ENABLE_FORMS:
              o += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
              break;
            case _util.AnnotationMode.ENABLE_STORAGE:
              o += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, F = (o & _util.RenderingIntentFlag.PRINT && C instanceof _annotation_storage.PrintAnnotationStorage ? C : this.annotationStorage).serializable;
              break;
            default:
              (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${u}`);
          }
          return D && (o += _util.RenderingIntentFlag.OPLIST), { renderingIntent: o, cacheKey: `${o}_${_annotation_storage.AnnotationStorage.getHash(F)}`, annotationStorageMap: F };
        }
        destroy() {
          if (this.destroyCapability)
            return this.destroyCapability.promise;
          this.destroyed = true, this.destroyCapability = new _util.PromiseCapability(), this._passwordCapability && this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
          const r = [];
          for (const C of T(this, b).values())
            r.push(C._destroy());
          T(this, b).clear(), T(this, L).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
          const u = this.messageHandler.sendWithPromise("Terminate", null);
          return r.push(u), Promise.all(r).then(() => {
            this.commonObjs.clear(), this.fontLoader.clear(), T(this, c).clear(), this.filterFactory.destroy(), this._networkStream && this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
          }, this.destroyCapability.reject), this.destroyCapability.promise;
        }
        setupMessageHandler() {
          const { messageHandler: r, loadingTask: u } = this;
          r.on("GetReader", (C, D) => {
            (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (o) => {
              this._lastProgress = { loaded: o.loaded, total: o.total };
            }, D.onPull = () => {
              this._fullReader.read().then(function(o) {
                let { value: F, done: z } = o;
                z ? D.close() : ((0, _util.assert)(F instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), D.enqueue(new Uint8Array(F), 1, [F]));
              }).catch((o) => {
                D.error(o);
              });
            }, D.onCancel = (o) => {
              this._fullReader.cancel(o), D.ready.catch((F) => {
                if (!this.destroyed)
                  throw F;
              });
            };
          }), r.on("ReaderHeadersReady", (C) => {
            const D = new _util.PromiseCapability(), o = this._fullReader;
            return o.headersReady.then(() => {
              if (!o.isStreamingSupported || !o.isRangeSupported) {
                if (this._lastProgress) {
                  var F;
                  (F = u.onProgress) === null || F === void 0 || F.call(u, this._lastProgress);
                }
                o.onProgress = (z) => {
                  var q;
                  (q = u.onProgress) === null || q === void 0 || q.call(u, { loaded: z.loaded, total: z.total });
                };
              }
              D.resolve({ isStreamingSupported: o.isStreamingSupported, isRangeSupported: o.isRangeSupported, contentLength: o.contentLength });
            }, D.reject), D.promise;
          }), r.on("GetRangeReader", (C, D) => {
            (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
            const o = this._networkStream.getRangeReader(C.begin, C.end);
            o ? (D.onPull = () => {
              o.read().then(function(F) {
                let { value: z, done: q } = F;
                q ? D.close() : ((0, _util.assert)(z instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), D.enqueue(new Uint8Array(z), 1, [z]));
              }).catch((F) => {
                D.error(F);
              });
            }, D.onCancel = (F) => {
              o.cancel(F), D.ready.catch((z) => {
                if (!this.destroyed)
                  throw z;
              });
            }) : D.close();
          }), r.on("GetDoc", (C) => {
            let { pdfInfo: D } = C;
            this._numPages = D.numPages, this._htmlForXfa = D.htmlForXfa, delete D.htmlForXfa, u._capability.resolve(new PDFDocumentProxy(D, this));
          }), r.on("DocException", function(C) {
            let D;
            switch (C.name) {
              case "PasswordException":
                D = new _util.PasswordException(C.message, C.code);
                break;
              case "InvalidPDFException":
                D = new _util.InvalidPDFException(C.message);
                break;
              case "MissingPDFException":
                D = new _util.MissingPDFException(C.message);
                break;
              case "UnexpectedResponseException":
                D = new _util.UnexpectedResponseException(C.message, C.status);
                break;
              case "UnknownErrorException":
                D = new _util.UnknownErrorException(C.message, C.details);
                break;
              default:
                (0, _util.unreachable)("DocException - expected a valid Error.");
            }
            u._capability.reject(D);
          }), r.on("PasswordRequest", (C) => {
            if (this._passwordCapability = new _util.PromiseCapability(), u.onPassword) {
              const D = (o) => {
                o instanceof Error ? this._passwordCapability.reject(o) : this._passwordCapability.resolve({ password: o });
              };
              try {
                u.onPassword(D, C.code);
              } catch (o) {
                this._passwordCapability.reject(o);
              }
            } else
              this._passwordCapability.reject(new _util.PasswordException(C.message, C.code));
            return this._passwordCapability.promise;
          }), r.on("DataLoaded", (C) => {
            var D;
            (D = u.onProgress) === null || D === void 0 || D.call(u, { loaded: C.length, total: C.length }), this.downloadInfoCapability.resolve(C);
          }), r.on("StartRenderPage", (C) => {
            this.destroyed || T(this, b).get(C.pageIndex)._startRenderPage(C.transparency, C.cacheKey);
          }), r.on("commonobj", (C) => {
            var D;
            let [o, F, z] = C;
            if (!this.destroyed && !this.commonObjs.has(o))
              switch (F) {
                case "Font":
                  const q = this._params;
                  if ("error" in z) {
                    const S = z.error;
                    (0, _util.warn)(`Error during font loading: ${S}`), this.commonObjs.resolve(o, S);
                    break;
                  }
                  const J = q.pdfBug && (D = globalThis.FontInspector) !== null && D !== void 0 && D.enabled ? (S, f) => globalThis.FontInspector.fontAdded(S, f) : null, $ = new _font_loader.FontFaceObject(z, { isEvalSupported: q.isEvalSupported, disableFontFace: q.disableFontFace, ignoreErrors: q.ignoreErrors, inspectFont: J });
                  this.fontLoader.bind($).catch((S) => r.sendWithPromise("FontFallback", { id: o })).finally(() => {
                    !q.fontExtraProperties && $.data && ($.data = null), this.commonObjs.resolve(o, $);
                  });
                  break;
                case "FontPath":
                case "Image":
                case "Pattern":
                  this.commonObjs.resolve(o, z);
                  break;
                default:
                  throw new Error(`Got unknown common object type ${F}`);
              }
          }), r.on("obj", (C) => {
            let [D, o, F, z] = C;
            if (this.destroyed)
              return;
            const q = T(this, b).get(o);
            if (!q.objs.has(D))
              switch (F) {
                case "Image":
                  if (q.objs.resolve(D, z), z) {
                    let $;
                    if (z.bitmap) {
                      const { width: S, height: f } = z;
                      $ = S * f * 4;
                    } else {
                      var J;
                      $ = ((J = z.data) === null || J === void 0 ? void 0 : J.length) || 0;
                    }
                    $ > _util.MAX_IMAGE_SIZE_TO_CACHE && (q._maybeCleanupAfterRender = true);
                  }
                  break;
                case "Pattern":
                  q.objs.resolve(D, z);
                  break;
                default:
                  throw new Error(`Got unknown object type ${F}`);
              }
          }), r.on("DocProgress", (C) => {
            var D;
            this.destroyed || (D = u.onProgress) === null || D === void 0 || D.call(u, { loaded: C.loaded, total: C.total });
          }), r.on("FetchBuiltInCMap", (C) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(C) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), r.on("FetchStandardFontData", (C) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(C) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
        }
        getData() {
          return this.messageHandler.sendWithPromise("GetData", null);
        }
        saveDocument() {
          var r;
          return this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead."), this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: this.annotationStorage.serializable, filename: ((r = this._fullReader) === null || r === void 0 ? void 0 : r.filename) ?? null }).finally(() => {
            this.annotationStorage.resetModified();
          });
        }
        getPage(r) {
          if (!Number.isInteger(r) || r <= 0 || r > this._numPages)
            return Promise.reject(new Error("Invalid page request."));
          const u = r - 1, C = T(this, L).get(u);
          if (C)
            return C;
          const D = this.messageHandler.sendWithPromise("GetPage", { pageIndex: u }).then((o) => {
            if (this.destroyed)
              throw new Error("Transport destroyed");
            const F = new PDFPageProxy(u, o, this, this._params.pdfBug);
            return T(this, b).set(u, F), F;
          });
          return T(this, L).set(u, D), D;
        }
        getPageIndex(r) {
          return typeof r != "object" || r === null || !Number.isInteger(r.num) || r.num < 0 || !Number.isInteger(r.gen) || r.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", { num: r.num, gen: r.gen });
        }
        getAnnotations(r, u) {
          return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: r, intent: u });
        }
        getFieldObjects() {
          return nt(this, m, Ae).call(this, "GetFieldObjects");
        }
        hasJSActions() {
          return nt(this, m, Ae).call(this, "HasJSActions");
        }
        getCalculationOrderIds() {
          return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
        }
        getDestinations() {
          return this.messageHandler.sendWithPromise("GetDestinations", null);
        }
        getDestination(r) {
          return typeof r != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: r });
        }
        getPageLabels() {
          return this.messageHandler.sendWithPromise("GetPageLabels", null);
        }
        getPageLayout() {
          return this.messageHandler.sendWithPromise("GetPageLayout", null);
        }
        getPageMode() {
          return this.messageHandler.sendWithPromise("GetPageMode", null);
        }
        getViewerPreferences() {
          return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
        }
        getOpenAction() {
          return this.messageHandler.sendWithPromise("GetOpenAction", null);
        }
        getAttachments() {
          return this.messageHandler.sendWithPromise("GetAttachments", null);
        }
        getJavaScript() {
          return this.messageHandler.sendWithPromise("GetJavaScript", null);
        }
        getDocJSActions() {
          return this.messageHandler.sendWithPromise("GetDocJSActions", null);
        }
        getPageJSActions(r) {
          return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: r });
        }
        getStructTree(r) {
          return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: r });
        }
        getOutline() {
          return this.messageHandler.sendWithPromise("GetOutline", null);
        }
        getOptionalContentConfig() {
          return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((r) => new _optional_content_config.OptionalContentConfig(r));
        }
        getPermissions() {
          return this.messageHandler.sendWithPromise("GetPermissions", null);
        }
        getMetadata() {
          const r = "GetMetadata", u = T(this, c).get(r);
          if (u)
            return u;
          const C = this.messageHandler.sendWithPromise(r, null).then((D) => {
            var o, F;
            return { info: D[0], metadata: D[1] ? new _metadata.Metadata(D[1]) : null, contentDispositionFilename: ((o = this._fullReader) === null || o === void 0 ? void 0 : o.filename) ?? null, contentLength: ((F = this._fullReader) === null || F === void 0 ? void 0 : F.contentLength) ?? null };
          });
          return T(this, c).set(r, C), C;
        }
        getMarkInfo() {
          return this.messageHandler.sendWithPromise("GetMarkInfo", null);
        }
        async startCleanup() {
          let r = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          if (!this.destroyed) {
            await this.messageHandler.sendWithPromise("Cleanup", null);
            for (const u of T(this, b).values())
              if (!u.cleanup())
                throw new Error(`startCleanup: Page ${u.pageNumber} is currently rendering.`);
            this.commonObjs.clear(), r || this.fontLoader.clear(), T(this, c).clear(), this.filterFactory.destroy(true);
          }
        }
        get loadingParams() {
          const { disableAutoFetch: r, enableXfa: u } = this._params;
          return (0, _util.shadow)(this, "loadingParams", { disableAutoFetch: r, enableXfa: u });
        }
      }
      c = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakSet(), Ae = function(r) {
        let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        const C = T(this, c).get(r);
        if (C)
          return C;
        const D = this.messageHandler.sendWithPromise(r, u);
        return T(this, c).set(r, D), D;
      };
      class PDFObjects {
        constructor() {
          et(this, I);
          et(this, x, /* @__PURE__ */ Object.create(null));
        }
        get(r) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          if (u) {
            const D = nt(this, I, _e).call(this, r);
            return D.capability.promise.then(() => u(D.data)), null;
          }
          const C = T(this, x)[r];
          if (C == null || !C.capability.settled)
            throw new Error(`Requesting object that isn't resolved yet ${r}.`);
          return C.data;
        }
        has(r) {
          const u = T(this, x)[r];
          return (u == null ? void 0 : u.capability.settled) || false;
        }
        resolve(r) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          const C = nt(this, I, _e).call(this, r);
          C.data = u, C.capability.resolve();
        }
        clear() {
          for (const u in T(this, x)) {
            var r;
            const { data: C } = T(this, x)[u];
            C == null || (r = C.bitmap) === null || r === void 0 || r.close();
          }
          ut(this, x, /* @__PURE__ */ Object.create(null));
        }
      }
      x = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakSet(), _e = function(r) {
        return T(this, x)[r] || (T(this, x)[r] = { capability: new _util.PromiseCapability(), data: null });
      };
      class RenderTask {
        constructor(r) {
          et(this, i, null);
          ut(this, i, r), this.onContinue = null;
        }
        get promise() {
          return T(this, i).capability.promise;
        }
        cancel() {
          let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          T(this, i).cancel(null, r);
        }
        get separateAnnots() {
          const { separateAnnots: r } = T(this, i).operatorList;
          if (!r)
            return false;
          const { annotationCanvasMap: u } = T(this, i);
          return r.form || r.canvas && (u == null ? void 0 : u.size) > 0;
        }
      }
      i = /* @__PURE__ */ new WeakMap(), exports.RenderTask = RenderTask;
      const n = class {
        constructor(r) {
          let { callback: u, params: C, objs: D, commonObjs: o, annotationCanvasMap: F, operatorList: z, pageIndex: q, canvasFactory: J, filterFactory: $, useRequestAnimationFrame: S = false, pdfBug: f = false, pageColors: P = null } = r;
          this.callback = u, this.params = C, this.objs = D, this.commonObjs = o, this.annotationCanvasMap = F, this.operatorListIdx = null, this.operatorList = z, this._pageIndex = q, this.canvasFactory = J, this.filterFactory = $, this._pdfBug = f, this.pageColors = P, this.running = false, this.graphicsReadyCallback = null, this.graphicsReady = false, this._useRequestAnimationFrame = S === true && typeof window < "u", this.cancelled = false, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = C.canvasContext.canvas;
        }
        get completed() {
          return this.capability.promise.catch(function() {
          });
        }
        initializeGraphics(r) {
          var u, C;
          let { transparency: D = false, optionalContentConfig: o } = r;
          if (this.cancelled)
            return;
          if (this._canvas) {
            if (T(n, A).has(this._canvas))
              throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
            T(n, A).add(this._canvas);
          }
          this._pdfBug && (u = globalThis.StepperManager) !== null && u !== void 0 && u.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
          const { canvasContext: F, viewport: z, transform: q, background: J } = this.params;
          this.gfx = new _canvas.CanvasGraphics(F, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: o }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({ transform: q, viewport: z, transparency: D, background: J }), this.operatorListIdx = 0, this.graphicsReady = true, (C = this.graphicsReadyCallback) === null || C === void 0 || C.call(this);
        }
        cancel() {
          var r;
          let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          this.running = false, this.cancelled = true, (r = this.gfx) === null || r === void 0 || r.endDrawing(), this._canvas && T(n, A).delete(this._canvas), this.callback(u || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas", C));
        }
        operatorListChanged() {
          var r;
          this.graphicsReady ? ((r = this.stepper) === null || r === void 0 || r.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
        }
        _continue() {
          this.running = true, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
        }
        _scheduleNext() {
          this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
            this._nextBound().catch(this._cancelBound);
          }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
        }
        async _next() {
          this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = false, this.operatorList.lastChunk && (this.gfx.endDrawing(this.pageColors), this._canvas && T(n, A).delete(this._canvas), this.callback())));
        }
      };
      let InternalRenderTask = n;
      A = /* @__PURE__ */ new WeakMap(), et(InternalRenderTask, A, /* @__PURE__ */ new WeakSet());
      const version = "3.7.107";
      exports.version = version;
      const build = "036f855dc";
      exports.build = build;
    }, (k2, d2, t2) => {
      var p2, h2, l2, We, b2;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.PrintAnnotationStorage = d2.AnnotationStorage = void 0;
      var e2 = t2(1), a2 = t2(140), y = t2(144);
      class w2 {
        constructor() {
          et(this, l2);
          et(this, p2, false);
          et(this, h2, /* @__PURE__ */ new Map());
          this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
        }
        getValue(m2, M) {
          const x2 = T(this, h2).get(m2);
          return x2 === void 0 ? M : Object.assign(M, x2);
        }
        getRawValue(m2) {
          return T(this, h2).get(m2);
        }
        remove(m2) {
          if (T(this, h2).delete(m2), T(this, h2).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
            for (const M of T(this, h2).values())
              if (M instanceof a2.AnnotationEditor)
                return;
            this.onAnnotationEditor(null);
          }
        }
        setValue(m2, M) {
          const x2 = T(this, h2).get(m2);
          let I2 = false;
          if (x2 !== void 0)
            for (const [v, i2] of Object.entries(M))
              x2[v] !== i2 && (I2 = true, x2[v] = i2);
          else
            I2 = true, T(this, h2).set(m2, M);
          I2 && nt(this, l2, We).call(this), M instanceof a2.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(M.constructor._type);
        }
        has(m2) {
          return T(this, h2).has(m2);
        }
        getAll() {
          return T(this, h2).size > 0 ? (0, e2.objectFromMap)(T(this, h2)) : null;
        }
        setAll(m2) {
          for (const [M, x2] of Object.entries(m2))
            this.setValue(M, x2);
        }
        get size() {
          return T(this, h2).size;
        }
        resetModified() {
          T(this, p2) && (ut(this, p2, false), typeof this.onResetModified == "function" && this.onResetModified());
        }
        get print() {
          return new O(this);
        }
        get serializable() {
          if (T(this, h2).size === 0)
            return null;
          const m2 = /* @__PURE__ */ new Map();
          for (const [M, x2] of T(this, h2)) {
            const I2 = x2 instanceof a2.AnnotationEditor ? x2.serialize() : x2;
            I2 && m2.set(M, I2);
          }
          return m2;
        }
        static getHash(m2) {
          if (!m2)
            return "";
          const M = new y.MurmurHash3_64();
          for (const [x2, I2] of m2)
            M.update(`${x2}:${JSON.stringify(I2)}`);
          return M.hexdigest();
        }
      }
      p2 = /* @__PURE__ */ new WeakMap(), h2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakSet(), We = function() {
        T(this, p2) || (ut(this, p2, true), typeof this.onSetModified == "function" && this.onSetModified());
      }, d2.AnnotationStorage = w2;
      class O extends w2 {
        constructor(M) {
          super();
          et(this, b2, null);
          ut(this, b2, structuredClone(M.serializable));
        }
        get print() {
          (0, e2.unreachable)("Should not call PrintAnnotationStorage.print");
        }
        get serializable() {
          return T(this, b2);
        }
      }
      b2 = /* @__PURE__ */ new WeakMap(), d2.PrintAnnotationStorage = O;
    }, (k2, d2, t2) => {
      var w2, O, p2, h2, l2, c2;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.AnnotationEditor = void 0;
      var e2 = t2(141), a2 = t2(1);
      const b2 = class {
        constructor(m2) {
          et(this, w2, this.focusin.bind(this));
          et(this, O, this.focusout.bind(this));
          et(this, p2, false);
          et(this, h2, false);
          et(this, l2, false);
          It(this, "_uiManager", null);
          et(this, c2, b2._zIndex++);
          this.constructor === b2 && (0, a2.unreachable)("Cannot initialize AnnotationEditor."), this.parent = m2.parent, this.id = m2.id, this.width = this.height = null, this.pageIndex = m2.parent.pageIndex, this.name = m2.name, this.div = null, this._uiManager = m2.uiManager;
          const { rotation: M, rawDims: { pageWidth: x2, pageHeight: I2, pageX: v, pageY: i2 } } = this.parent.viewport;
          this.rotation = M, this.pageRotation = (360 + M - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [x2, I2], this.pageTranslation = [v, i2];
          const [A2, n2] = this.parentDimensions;
          this.x = m2.x / A2, this.y = m2.y / n2, this.isAttachedToDOM = false;
        }
        static get _defaultLineColor() {
          return (0, a2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
        }
        addCommands(m2) {
          this._uiManager.addCommands(m2);
        }
        get currentLayer() {
          return this._uiManager.currentLayer;
        }
        setInBackground() {
          this.div.style.zIndex = 0;
        }
        setInForeground() {
          this.div.style.zIndex = T(this, c2);
        }
        setParent(m2) {
          m2 !== null && (this.pageIndex = m2.pageIndex, this.pageDimensions = m2.pageDimensions), this.parent = m2;
        }
        focusin(m2) {
          T(this, p2) ? ut(this, p2, false) : this.parent.setSelected(this);
        }
        focusout(m2) {
          var M;
          if (!this.isAttachedToDOM)
            return;
          const x2 = m2.relatedTarget;
          (x2 == null || !x2.closest(`#${this.id}`)) && (m2.preventDefault(), (M = this.parent) !== null && M !== void 0 && M.isMultipleSelection || this.commitOrRemove());
        }
        commitOrRemove() {
          this.isEmpty() ? this.remove() : this.commit();
        }
        commit() {
          this.addToAnnotationStorage();
        }
        addToAnnotationStorage() {
          this._uiManager.addToAnnotationStorage(this);
        }
        dragstart(m2) {
          const M = this.parent.div.getBoundingClientRect();
          this.startX = m2.clientX - M.x, this.startY = m2.clientY - M.y, m2.dataTransfer.setData("text/plain", this.id), m2.dataTransfer.effectAllowed = "move";
        }
        setAt(m2, M, x2, I2) {
          const [v, i2] = this.parentDimensions;
          [x2, I2] = this.screenToPageTranslation(x2, I2), this.x = (m2 + x2) / v, this.y = (M + I2) / i2, this.div.style.left = 100 * this.x + "%", this.div.style.top = 100 * this.y + "%";
        }
        translate(m2, M) {
          const [x2, I2] = this.parentDimensions;
          [m2, M] = this.screenToPageTranslation(m2, M), this.x += m2 / x2, this.y += M / I2, this.div.style.left = 100 * this.x + "%", this.div.style.top = 100 * this.y + "%";
        }
        screenToPageTranslation(m2, M) {
          switch (this.parentRotation) {
            case 90:
              return [M, -m2];
            case 180:
              return [-m2, -M];
            case 270:
              return [-M, m2];
            default:
              return [m2, M];
          }
        }
        get parentScale() {
          return this._uiManager.viewParameters.realScale;
        }
        get parentRotation() {
          return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
        }
        get parentDimensions() {
          const { realScale: m2 } = this._uiManager.viewParameters, [M, x2] = this.pageDimensions;
          return [M * m2, x2 * m2];
        }
        setDims(m2, M) {
          const [x2, I2] = this.parentDimensions;
          this.div.style.width = 100 * m2 / x2 + "%", this.div.style.height = 100 * M / I2 + "%";
        }
        fixDims() {
          const { style: m2 } = this.div, { height: M, width: x2 } = m2, I2 = x2.endsWith("%"), v = M.endsWith("%");
          if (I2 && v)
            return;
          const [i2, A2] = this.parentDimensions;
          I2 || (m2.width = 100 * parseFloat(x2) / i2 + "%"), v || (m2.height = 100 * parseFloat(M) / A2 + "%");
        }
        getInitialTranslation() {
          return [0, 0];
        }
        render() {
          this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", T(this, w2)), this.div.addEventListener("focusout", T(this, O));
          const [m2, M] = this.getInitialTranslation();
          return this.translate(m2, M), (0, e2.bindEvents)(this, this.div, ["dragstart", "pointerdown"]), this.div;
        }
        pointerdown(m2) {
          const { isMac: M } = a2.FeatureTest.platform;
          m2.button !== 0 || m2.ctrlKey && M ? m2.preventDefault() : (m2.ctrlKey && !M || m2.shiftKey || m2.metaKey && M ? this.parent.toggleSelected(this) : this.parent.setSelected(this), ut(this, p2, true));
        }
        getRect(m2, M) {
          const x2 = this.parentScale, [I2, v] = this.pageDimensions, [i2, A2] = this.pageTranslation, n2 = m2 / x2, s = M / x2, r = this.x * I2, u = this.y * v, C = this.width * I2, D = this.height * v;
          switch (this.rotation) {
            case 0:
              return [r + n2 + i2, v - u - s - D + A2, r + n2 + C + i2, v - u - s + A2];
            case 90:
              return [r + s + i2, v - u + n2 + A2, r + s + D + i2, v - u + n2 + C + A2];
            case 180:
              return [r - n2 - C + i2, v - u + s + A2, r - n2 + i2, v - u + s + D + A2];
            case 270:
              return [r - s - D + i2, v - u - n2 - C + A2, r - s + i2, v - u - n2 + A2];
            default:
              throw new Error("Invalid rotation");
          }
        }
        getRectInCurrentCoords(m2, M) {
          const [x2, I2, v, i2] = m2, A2 = v - x2, n2 = i2 - I2;
          switch (this.rotation) {
            case 0:
              return [x2, M - i2, A2, n2];
            case 90:
              return [x2, M - I2, n2, A2];
            case 180:
              return [v, M - I2, A2, n2];
            case 270:
              return [v, M - i2, n2, A2];
            default:
              throw new Error("Invalid rotation");
          }
        }
        onceAdded() {
        }
        isEmpty() {
          return false;
        }
        enableEditMode() {
          ut(this, l2, true);
        }
        disableEditMode() {
          ut(this, l2, false);
        }
        isInEditMode() {
          return T(this, l2);
        }
        shouldGetKeyboardEvents() {
          return false;
        }
        needsToBeRebuilt() {
          return this.div && !this.isAttachedToDOM;
        }
        rebuild() {
          var m2;
          (m2 = this.div) === null || m2 === void 0 || m2.addEventListener("focusin", T(this, w2));
        }
        serialize() {
          (0, a2.unreachable)("An editor must be serializable");
        }
        static deserialize(m2, M, x2) {
          const I2 = new this.prototype.constructor({ parent: M, id: M.getNextId(), uiManager: x2 });
          I2.rotation = m2.rotation;
          const [v, i2] = I2.pageDimensions, [A2, n2, s, r] = I2.getRectInCurrentCoords(m2.rect, i2);
          return I2.x = A2 / v, I2.y = n2 / i2, I2.width = s / v, I2.height = r / i2, I2;
        }
        remove() {
          this.div.removeEventListener("focusin", T(this, w2)), this.div.removeEventListener("focusout", T(this, O)), this.isEmpty() || this.commit(), this.parent.remove(this);
        }
        select() {
          var m2;
          (m2 = this.div) === null || m2 === void 0 || m2.classList.add("selectedEditor");
        }
        unselect() {
          var m2;
          (m2 = this.div) === null || m2 === void 0 || m2.classList.remove("selectedEditor");
        }
        updateParams(m2, M) {
        }
        disableEditing() {
        }
        enableEditing() {
        }
        get propertiesToUpdate() {
          return {};
        }
        get contentDiv() {
          return this.div;
        }
        get isEditing() {
          return T(this, h2);
        }
        set isEditing(m2) {
          ut(this, h2, m2), m2 ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null);
        }
      };
      let y = b2;
      w2 = /* @__PURE__ */ new WeakMap(), O = /* @__PURE__ */ new WeakMap(), p2 = /* @__PURE__ */ new WeakMap(), h2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), c2 = /* @__PURE__ */ new WeakMap(), It(y, "_colorManager", new e2.ColorManager()), It(y, "_zIndex", 1), d2.AnnotationEditor = y;
    }, (k2, d2, t2) => {
      var l2, c2, b2, L2, m2, M, Ge, v, i2, A2, n2, s, r, u, C, D, o, F, z, q, J, $, S, f, P, g, _, U, N, G, V, He, X, Se, H, ze, dt, Ve, E, $t, j, ae, Y, $e, rt, Xe, At, xe, vt, oe, mt, Ce;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.KeyboardManager = d2.CommandManager = d2.ColorManager = d2.AnnotationEditorUIManager = void 0, d2.bindEvents = function(Q, pt, xt) {
        for (const Mt of xt)
          pt.addEventListener(Mt, Q[Mt].bind(Q));
      }, d2.opacityToHex = function(Q) {
        return Math.round(Math.min(255, Math.max(1, 255 * Q))).toString(16).padStart(2, "0");
      };
      var e2 = t2(1), a2 = t2(142);
      class y {
        constructor() {
          et(this, l2, 0);
        }
        getId() {
          return `${e2.AnnotationEditorPrefix}${ue(this, l2)._++}`;
        }
      }
      l2 = /* @__PURE__ */ new WeakMap();
      class w2 {
        constructor() {
          et(this, c2, []);
          et(this, b2, false);
          et(this, L2, void 0);
          et(this, m2, -1);
          let Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;
          ut(this, L2, Q);
        }
        add(Q) {
          let { cmd: pt, undo: xt, mustExec: Mt, type: Ft = NaN, overwriteIfSameType: at = false, keepUndo: Pt = false } = Q;
          if (Mt && pt(), T(this, b2))
            return;
          const Et = { cmd: pt, undo: xt, type: Ft };
          if (T(this, m2) === -1) {
            T(this, c2).length > 0 && (T(this, c2).length = 0), ut(this, m2, 0), T(this, c2).push(Et);
            return;
          }
          if (at && T(this, c2)[T(this, m2)].type === Ft) {
            Pt && (Et.undo = T(this, c2)[T(this, m2)].undo), T(this, c2)[T(this, m2)] = Et;
            return;
          }
          const Ut = T(this, m2) + 1;
          Ut === T(this, L2) ? T(this, c2).splice(0, 1) : (ut(this, m2, Ut), Ut < T(this, c2).length && T(this, c2).splice(Ut)), T(this, c2).push(Et);
        }
        undo() {
          T(this, m2) !== -1 && (ut(this, b2, true), T(this, c2)[T(this, m2)].undo(), ut(this, b2, false), ut(this, m2, T(this, m2) - 1));
        }
        redo() {
          T(this, m2) < T(this, c2).length - 1 && (ut(this, m2, T(this, m2) + 1), ut(this, b2, true), T(this, c2)[T(this, m2)].cmd(), ut(this, b2, false));
        }
        hasSomethingToUndo() {
          return T(this, m2) !== -1;
        }
        hasSomethingToRedo() {
          return T(this, m2) < T(this, c2).length - 1;
        }
        destroy() {
          ut(this, c2, null);
        }
      }
      c2 = /* @__PURE__ */ new WeakMap(), b2 = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap(), m2 = /* @__PURE__ */ new WeakMap(), d2.CommandManager = w2;
      class O {
        constructor(Q) {
          et(this, M);
          this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
          const { isMac: pt } = e2.FeatureTest.platform;
          for (const [xt, Mt] of Q)
            for (const Ft of xt) {
              const at = Ft.startsWith("mac+");
              pt && at ? (this.callbacks.set(Ft.slice(4), Mt), this.allKeys.add(Ft.split("+").at(-1))) : !pt && !at && (this.callbacks.set(Ft, Mt), this.allKeys.add(Ft.split("+").at(-1)));
            }
        }
        exec(Q, pt) {
          if (!this.allKeys.has(pt.key))
            return;
          const xt = this.callbacks.get(nt(this, M, Ge).call(this, pt));
          xt && (xt.bind(Q)(), pt.stopPropagation(), pt.preventDefault());
        }
      }
      M = /* @__PURE__ */ new WeakSet(), Ge = function(Q) {
        Q.altKey && this.buffer.push("alt"), Q.ctrlKey && this.buffer.push("ctrl"), Q.metaKey && this.buffer.push("meta"), Q.shiftKey && this.buffer.push("shift"), this.buffer.push(Q.key);
        const pt = this.buffer.join("+");
        return this.buffer.length = 0, pt;
      }, d2.KeyboardManager = O;
      const I2 = class {
        get _colors() {
          const Q = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
          return (0, a2.getColorValues)(Q), (0, e2.shadow)(this, "_colors", Q);
        }
        convert(Q) {
          const pt = (0, a2.getRGB)(Q);
          if (!window.matchMedia("(forced-colors: active)").matches)
            return pt;
          for (const [xt, Mt] of this._colors)
            if (Mt.every((Ft, at) => Ft === pt[at]))
              return I2._colorsMapping.get(xt);
          return pt;
        }
        getHexCode(Q) {
          const pt = this._colors.get(Q);
          return pt ? e2.Util.makeHexColor(...pt) : Q;
        }
      };
      let p2 = I2;
      It(p2, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]])), d2.ColorManager = p2;
      const _t = class {
        constructor(Q, pt, xt) {
          et(this, V);
          et(this, X);
          et(this, H);
          et(this, dt);
          et(this, E);
          et(this, j);
          et(this, Y);
          et(this, rt);
          et(this, At);
          et(this, vt);
          et(this, mt);
          et(this, v, null);
          et(this, i2, /* @__PURE__ */ new Map());
          et(this, A2, /* @__PURE__ */ new Map());
          et(this, n2, null);
          et(this, s, new w2());
          et(this, r, 0);
          et(this, u, null);
          et(this, C, /* @__PURE__ */ new Set());
          et(this, D, null);
          et(this, o, new y());
          et(this, F, false);
          et(this, z, e2.AnnotationEditorType.NONE);
          et(this, q, /* @__PURE__ */ new Set());
          et(this, J, this.copy.bind(this));
          et(this, $, this.cut.bind(this));
          et(this, S, this.paste.bind(this));
          et(this, f, this.keydown.bind(this));
          et(this, P, this.onEditingAction.bind(this));
          et(this, g, this.onPageChanging.bind(this));
          et(this, _, this.onScaleChanging.bind(this));
          et(this, U, this.onRotationChanging.bind(this));
          et(this, N, { isEditing: false, isEmpty: true, hasSomethingToUndo: false, hasSomethingToRedo: false, hasSelectedEditor: false });
          et(this, G, null);
          ut(this, G, Q), ut(this, D, pt), T(this, D)._on("editingaction", T(this, P)), T(this, D)._on("pagechanging", T(this, g)), T(this, D)._on("scalechanging", T(this, _)), T(this, D)._on("rotationchanging", T(this, U)), ut(this, n2, xt), this.viewParameters = { realScale: a2.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 };
        }
        destroy() {
          nt(this, X, Se).call(this), T(this, D)._off("editingaction", T(this, P)), T(this, D)._off("pagechanging", T(this, g)), T(this, D)._off("scalechanging", T(this, _)), T(this, D)._off("rotationchanging", T(this, U));
          for (const Q of T(this, A2).values())
            Q.destroy();
          T(this, A2).clear(), T(this, i2).clear(), T(this, C).clear(), ut(this, v, null), T(this, q).clear(), T(this, s).destroy();
        }
        onPageChanging(Q) {
          let { pageNumber: pt } = Q;
          ut(this, r, pt - 1);
        }
        focusMainContainer() {
          T(this, G).focus();
        }
        addShouldRescale(Q) {
          T(this, C).add(Q);
        }
        removeShouldRescale(Q) {
          T(this, C).delete(Q);
        }
        onScaleChanging(Q) {
          let { scale: pt } = Q;
          this.commitOrRemove(), this.viewParameters.realScale = pt * a2.PixelsPerInch.PDF_TO_CSS_UNITS;
          for (const xt of T(this, C))
            xt.onScaleChanging();
        }
        onRotationChanging(Q) {
          let { pagesRotation: pt } = Q;
          this.commitOrRemove(), this.viewParameters.rotation = pt;
        }
        addToAnnotationStorage(Q) {
          Q.isEmpty() || !T(this, n2) || T(this, n2).has(Q.id) || T(this, n2).setValue(Q.id, Q);
        }
        copy(Q) {
          if (Q.preventDefault(), T(this, v) && T(this, v).commitOrRemove(), !this.hasSelection)
            return;
          const pt = [];
          for (const xt of T(this, q))
            xt.isEmpty() || pt.push(xt.serialize());
          pt.length !== 0 && Q.clipboardData.setData("application/pdfjs", JSON.stringify(pt));
        }
        cut(Q) {
          this.copy(Q), this.delete();
        }
        paste(Q) {
          Q.preventDefault();
          let pt = Q.clipboardData.getData("application/pdfjs");
          if (!pt)
            return;
          try {
            pt = JSON.parse(pt);
          } catch (Mt) {
            (0, e2.warn)(`paste: "${Mt.message}".`);
            return;
          }
          if (!Array.isArray(pt))
            return;
          this.unselectAll();
          const xt = T(this, A2).get(T(this, r));
          try {
            const Mt = [];
            for (const Pt of pt) {
              const Et = xt.deserialize(Pt);
              if (!Et)
                return;
              Mt.push(Et);
            }
            const Ft = () => {
              for (const Pt of Mt)
                nt(this, At, xe).call(this, Pt);
              nt(this, mt, Ce).call(this, Mt);
            }, at = () => {
              for (const Pt of Mt)
                Pt.remove();
            };
            this.addCommands({ cmd: Ft, undo: at, mustExec: true });
          } catch (Mt) {
            (0, e2.warn)(`paste: "${Mt.message}".`);
          }
        }
        keydown(Q) {
          var pt;
          (pt = this.getActive()) !== null && pt !== void 0 && pt.shouldGetKeyboardEvents() || _t._keyboardManager.exec(this, Q);
        }
        onEditingAction(Q) {
          ["undo", "redo", "delete", "selectAll"].includes(Q.name) && this[Q.name]();
        }
        setEditingState(Q) {
          Q ? (nt(this, V, He).call(this), nt(this, H, ze).call(this), nt(this, E, $t).call(this, { isEditing: T(this, z) !== e2.AnnotationEditorType.NONE, isEmpty: nt(this, vt, oe).call(this), hasSomethingToUndo: T(this, s).hasSomethingToUndo(), hasSomethingToRedo: T(this, s).hasSomethingToRedo(), hasSelectedEditor: false })) : (nt(this, X, Se).call(this), nt(this, dt, Ve).call(this), nt(this, E, $t).call(this, { isEditing: false }));
        }
        registerEditorTypes(Q) {
          if (!T(this, u)) {
            ut(this, u, Q);
            for (const pt of T(this, u))
              nt(this, j, ae).call(this, pt.defaultPropertiesToUpdate);
          }
        }
        getId() {
          return T(this, o).getId();
        }
        get currentLayer() {
          return T(this, A2).get(T(this, r));
        }
        get currentPageIndex() {
          return T(this, r);
        }
        addLayer(Q) {
          T(this, A2).set(Q.pageIndex, Q), T(this, F) ? Q.enable() : Q.disable();
        }
        removeLayer(Q) {
          T(this, A2).delete(Q.pageIndex);
        }
        updateMode(Q) {
          if (ut(this, z, Q), Q === e2.AnnotationEditorType.NONE)
            this.setEditingState(false), nt(this, rt, Xe).call(this);
          else {
            this.setEditingState(true), nt(this, Y, $e).call(this);
            for (const pt of T(this, A2).values())
              pt.updateMode(Q);
          }
        }
        updateToolbar(Q) {
          Q !== T(this, z) && T(this, D).dispatch("switchannotationeditormode", { source: this, mode: Q });
        }
        updateParams(Q, pt) {
          if (T(this, u)) {
            for (const xt of T(this, q))
              xt.updateParams(Q, pt);
            for (const xt of T(this, u))
              xt.updateDefaultParams(Q, pt);
          }
        }
        getEditors(Q) {
          const pt = [];
          for (const xt of T(this, i2).values())
            xt.pageIndex === Q && pt.push(xt);
          return pt;
        }
        getEditor(Q) {
          return T(this, i2).get(Q);
        }
        addEditor(Q) {
          T(this, i2).set(Q.id, Q);
        }
        removeEditor(Q) {
          var pt;
          T(this, i2).delete(Q.id), this.unselect(Q), (pt = T(this, n2)) === null || pt === void 0 || pt.remove(Q.id);
        }
        setActiveEditor(Q) {
          T(this, v) !== Q && (ut(this, v, Q), Q && nt(this, j, ae).call(this, Q.propertiesToUpdate));
        }
        toggleSelected(Q) {
          T(this, q).has(Q) ? (T(this, q).delete(Q), Q.unselect(), nt(this, E, $t).call(this, { hasSelectedEditor: this.hasSelection })) : (T(this, q).add(Q), Q.select(), nt(this, j, ae).call(this, Q.propertiesToUpdate), nt(this, E, $t).call(this, { hasSelectedEditor: true }));
        }
        setSelected(Q) {
          for (const pt of T(this, q))
            pt !== Q && pt.unselect();
          T(this, q).clear(), T(this, q).add(Q), Q.select(), nt(this, j, ae).call(this, Q.propertiesToUpdate), nt(this, E, $t).call(this, { hasSelectedEditor: true });
        }
        isSelected(Q) {
          return T(this, q).has(Q);
        }
        unselect(Q) {
          Q.unselect(), T(this, q).delete(Q), nt(this, E, $t).call(this, { hasSelectedEditor: this.hasSelection });
        }
        get hasSelection() {
          return T(this, q).size !== 0;
        }
        undo() {
          T(this, s).undo(), nt(this, E, $t).call(this, { hasSomethingToUndo: T(this, s).hasSomethingToUndo(), hasSomethingToRedo: true, isEmpty: nt(this, vt, oe).call(this) });
        }
        redo() {
          T(this, s).redo(), nt(this, E, $t).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: T(this, s).hasSomethingToRedo(), isEmpty: nt(this, vt, oe).call(this) });
        }
        addCommands(Q) {
          T(this, s).add(Q), nt(this, E, $t).call(this, { hasSomethingToUndo: true, hasSomethingToRedo: false, isEmpty: nt(this, vt, oe).call(this) });
        }
        delete() {
          if (this.commitOrRemove(), !this.hasSelection)
            return;
          const Q = [...T(this, q)];
          this.addCommands({ cmd: () => {
            for (const pt of Q)
              pt.remove();
          }, undo: () => {
            for (const pt of Q)
              nt(this, At, xe).call(this, pt);
          }, mustExec: true });
        }
        commitOrRemove() {
          var Q;
          (Q = T(this, v)) === null || Q === void 0 || Q.commitOrRemove();
        }
        selectAll() {
          for (const Q of T(this, q))
            Q.commit();
          nt(this, mt, Ce).call(this, T(this, i2).values());
        }
        unselectAll() {
          if (T(this, v))
            T(this, v).commitOrRemove();
          else if (T(this, q).size !== 0) {
            for (const Q of T(this, q))
              Q.unselect();
            T(this, q).clear(), nt(this, E, $t).call(this, { hasSelectedEditor: false });
          }
        }
        isActive(Q) {
          return T(this, v) === Q;
        }
        getActive() {
          return T(this, v);
        }
        getMode() {
          return T(this, z);
        }
      };
      let h2 = _t;
      v = /* @__PURE__ */ new WeakMap(), i2 = /* @__PURE__ */ new WeakMap(), A2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), z = /* @__PURE__ */ new WeakMap(), q = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), $ = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakSet(), He = function() {
        T(this, G).addEventListener("keydown", T(this, f));
      }, X = /* @__PURE__ */ new WeakSet(), Se = function() {
        T(this, G).removeEventListener("keydown", T(this, f));
      }, H = /* @__PURE__ */ new WeakSet(), ze = function() {
        document.addEventListener("copy", T(this, J)), document.addEventListener("cut", T(this, $)), document.addEventListener("paste", T(this, S));
      }, dt = /* @__PURE__ */ new WeakSet(), Ve = function() {
        document.removeEventListener("copy", T(this, J)), document.removeEventListener("cut", T(this, $)), document.removeEventListener("paste", T(this, S));
      }, E = /* @__PURE__ */ new WeakSet(), $t = function(Q) {
        Object.entries(Q).some((pt) => {
          let [xt, Mt] = pt;
          return T(this, N)[xt] !== Mt;
        }) && T(this, D).dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(T(this, N), Q) });
      }, j = /* @__PURE__ */ new WeakSet(), ae = function(Q) {
        T(this, D).dispatch("annotationeditorparamschanged", { source: this, details: Q });
      }, Y = /* @__PURE__ */ new WeakSet(), $e = function() {
        if (!T(this, F)) {
          ut(this, F, true);
          for (const Q of T(this, A2).values())
            Q.enable();
        }
      }, rt = /* @__PURE__ */ new WeakSet(), Xe = function() {
        if (this.unselectAll(), T(this, F)) {
          ut(this, F, false);
          for (const Q of T(this, A2).values())
            Q.disable();
        }
      }, At = /* @__PURE__ */ new WeakSet(), xe = function(Q) {
        const pt = T(this, A2).get(Q.pageIndex);
        pt ? pt.addOrRebuild(Q) : this.addEditor(Q);
      }, vt = /* @__PURE__ */ new WeakSet(), oe = function() {
        if (T(this, i2).size === 0)
          return true;
        if (T(this, i2).size === 1)
          for (const Q of T(this, i2).values())
            return Q.isEmpty();
        return false;
      }, mt = /* @__PURE__ */ new WeakSet(), Ce = function(Q) {
        T(this, q).clear();
        for (const pt of Q)
          pt.isEmpty() || (T(this, q).add(pt), pt.select());
        nt(this, E, $t).call(this, { hasSelectedEditor: true });
      }, It(h2, "_keyboardManager", new O([[["ctrl+a", "mac+meta+a"], _t.prototype.selectAll], [["ctrl+z", "mac+meta+z"], _t.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], _t.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], _t.prototype.delete], [["Escape", "mac+Escape"], _t.prototype.unselectAll]])), d2.AnnotationEditorUIManager = h2;
    }, (k2, d2, t2) => {
      var A2, n2, s, r, u, C, D, o, F, se, q, Jt, $, Yt;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.StatTimer = d2.RenderingCancelledException = d2.PixelsPerInch = d2.PageViewport = d2.PDFDateString = d2.DOMStandardFontDataFactory = d2.DOMSVGFactory = d2.DOMFilterFactory = d2.DOMCanvasFactory = d2.DOMCMapReaderFactory = d2.AnnotationPrefix = void 0, d2.deprecated = function(P) {
        console.log("Deprecated API usage: " + P);
      }, d2.getColorValues = function(P) {
        const g = document.createElement("span");
        g.style.visibility = "hidden", document.body.append(g);
        for (const _ of P.keys()) {
          g.style.color = _;
          const U = window.getComputedStyle(g).color;
          P.set(_, v(U));
        }
        g.remove();
      }, d2.getCurrentTransform = function(P) {
        const { a: g, b: _, c: U, d: N, e: G, f: V } = P.getTransform();
        return [g, _, U, N, G, V];
      }, d2.getCurrentTransformInverse = function(P) {
        const { a: g, b: _, c: U, d: N, e: G, f: V } = P.getTransform().invertSelf();
        return [g, _, U, N, G, V];
      }, d2.getFilenameFromUrl = function(P) {
        return arguments.length > 1 && arguments[1] !== void 0 && arguments[1] || ([P] = P.split(/[#?]/, 1)), P.substring(P.lastIndexOf("/") + 1);
      }, d2.getPdfFilenameFromUrl = function(P) {
        let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "document.pdf";
        if (typeof P != "string")
          return g;
        if (M(P))
          return (0, a2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), g;
        const _ = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, U = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(P);
        let N = _.exec(U[1]) || _.exec(U[2]) || _.exec(U[3]);
        if (N && (N = N[0], N.includes("%")))
          try {
            N = _.exec(decodeURIComponent(N))[0];
          } catch {
          }
        return N || g;
      }, d2.getRGB = v, d2.getXfaPageViewport = function(P, g) {
        let { scale: _ = 1, rotation: U = 0 } = g;
        const { width: N, height: G } = P.attributes.style, V = [0, 0, parseInt(N), parseInt(G)];
        return new L2({ viewBox: V, scale: _, rotation: U });
      }, d2.isDataScheme = M, d2.isPdfFile = function(P) {
        return typeof P == "string" && /\.pdf$/i.test(P);
      }, d2.isValidFetchUrl = x2, d2.loadScript = function(P) {
        let g = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        return new Promise((_, U) => {
          const N = document.createElement("script");
          N.src = P, N.onload = function(G) {
            g && N.remove(), _(G);
          }, N.onerror = function() {
            U(new Error(`Cannot load script at: ${N.src}`));
          }, (document.head || document.documentElement).append(N);
        });
      }, d2.setLayerDimensions = function(P, g) {
        let _ = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], U = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
        if (g instanceof L2) {
          const { pageWidth: N, pageHeight: G } = g.rawDims, { style: V } = P, W = `calc(var(--scale-factor) * ${N}px)`, X = `calc(var(--scale-factor) * ${G}px)`;
          _ && g.rotation % 180 != 0 ? (V.width = X, V.height = W) : (V.width = W, V.height = X);
        }
        U && P.setAttribute("data-main-rotation", g.rotation);
      };
      var e2 = t2(143), a2 = t2(1);
      const y = "http://www.w3.org/2000/svg";
      d2.AnnotationPrefix = "pdfjs_internal_id_";
      const i2 = class {
      };
      let w2 = i2;
      It(w2, "CSS", 96), It(w2, "PDF", 72), It(w2, "PDF_TO_CSS_UNITS", i2.CSS / i2.PDF), d2.PixelsPerInch = w2;
      class O extends e2.BaseFilterFactory {
        constructor() {
          let { docId: g, ownerDocument: _ = globalThis.document } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super();
          et(this, F);
          et(this, q);
          et(this, $);
          et(this, A2, void 0);
          et(this, n2, void 0);
          et(this, s, void 0);
          et(this, r, void 0);
          et(this, u, void 0);
          et(this, C, void 0);
          et(this, D, void 0);
          et(this, o, 0);
          ut(this, s, g), ut(this, r, _);
        }
        addFilter(g) {
          if (!g)
            return "none";
          let _, U, N, G, V = T(this, F, se).get(g);
          if (V)
            return V;
          if (g.length === 1) {
            const Z = g[0], dt = new Array(256);
            for (let lt = 0; lt < 256; lt++)
              dt[lt] = Z[lt] / 255;
            G = _ = U = N = dt.join(",");
          } else {
            const [Z, dt, lt] = g, E = new Array(256), R = new Array(256), j = new Array(256);
            for (let B = 0; B < 256; B++)
              E[B] = Z[B] / 255, R[B] = dt[B] / 255, j[B] = lt[B] / 255;
            _ = E.join(","), U = R.join(","), N = j.join(","), G = `${_}${U}${N}`;
          }
          if (V = T(this, F, se).get(G), V)
            return T(this, F, se).set(g, V), V;
          const W = `g_${T(this, s)}_transfer_map_${ue(this, o)._++}`, X = `url(#${W})`;
          T(this, F, se).set(g, X), T(this, F, se).set(G, X);
          const K = T(this, r).createElementNS(y, "filter", y);
          K.setAttribute("id", W), K.setAttribute("color-interpolation-filters", "sRGB");
          const H = T(this, r).createElementNS(y, "feComponentTransfer");
          return K.append(H), nt(this, $, Yt).call(this, H, "feFuncR", _), nt(this, $, Yt).call(this, H, "feFuncG", U), nt(this, $, Yt).call(this, H, "feFuncB", N), T(this, q, Jt).append(K), X;
        }
        addHCMFilter(g, _) {
          var U;
          const N = `${g}-${_}`;
          if (T(this, C) === N)
            return T(this, D);
          if (ut(this, C, N), ut(this, D, "none"), (U = T(this, u)) === null || U === void 0 || U.remove(), !g || !_)
            return T(this, D);
          T(this, q, Jt).style.color = g;
          const G = v(g = getComputedStyle(T(this, q, Jt)).getPropertyValue("color"));
          g = a2.Util.makeHexColor(...G), T(this, q, Jt).style.color = _;
          const V = v(_ = getComputedStyle(T(this, q, Jt)).getPropertyValue("color"));
          if (_ = a2.Util.makeHexColor(...V), T(this, q, Jt).style.color = "", g === "#000000" && _ === "#ffffff" || g === _)
            return T(this, D);
          const W = new Array(256);
          for (let E = 0; E <= 255; E++) {
            const R = E / 255;
            W[E] = R <= 0.03928 ? R / 12.92 : ((R + 0.055) / 1.055) ** 2.4;
          }
          const X = W.join(","), K = `g_${T(this, s)}_hcm_filter`, H = ut(this, u, T(this, r).createElementNS(y, "filter", y));
          H.setAttribute("id", K), H.setAttribute("color-interpolation-filters", "sRGB");
          let Z = T(this, r).createElementNS(y, "feComponentTransfer");
          H.append(Z), nt(this, $, Yt).call(this, Z, "feFuncR", X), nt(this, $, Yt).call(this, Z, "feFuncG", X), nt(this, $, Yt).call(this, Z, "feFuncB", X);
          const dt = T(this, r).createElementNS(y, "feColorMatrix");
          dt.setAttribute("type", "matrix"), dt.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), H.append(dt), Z = T(this, r).createElementNS(y, "feComponentTransfer"), H.append(Z);
          const lt = (E, R) => {
            const j = G[E] / 255, B = V[E] / 255, Y = new Array(R + 1);
            for (let tt = 0; tt <= R; tt++)
              Y[tt] = j + tt / R * (B - j);
            return Y.join(",");
          };
          return nt(this, $, Yt).call(this, Z, "feFuncR", lt(0, 5)), nt(this, $, Yt).call(this, Z, "feFuncG", lt(1, 5)), nt(this, $, Yt).call(this, Z, "feFuncB", lt(2, 5)), T(this, q, Jt).append(H), ut(this, D, `url(#${K})`), T(this, D);
        }
        destroy() {
          (!(arguments.length > 0 && arguments[0] !== void 0 && arguments[0]) || !T(this, D)) && (T(this, n2) && (T(this, n2).parentNode.parentNode.remove(), ut(this, n2, null)), T(this, A2) && (T(this, A2).clear(), ut(this, A2, null)), ut(this, o, 0));
        }
      }
      A2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakSet(), se = function() {
        return T(this, A2) || ut(this, A2, /* @__PURE__ */ new Map());
      }, q = /* @__PURE__ */ new WeakSet(), Jt = function() {
        if (!T(this, n2)) {
          const g = T(this, r).createElement("div"), { style: _ } = g;
          _.visibility = "hidden", _.contain = "strict", _.width = _.height = 0, _.position = "absolute", _.top = _.left = 0, _.zIndex = -1;
          const U = T(this, r).createElementNS(y, "svg");
          U.setAttribute("width", 0), U.setAttribute("height", 0), ut(this, n2, T(this, r).createElementNS(y, "defs")), g.append(U), U.append(T(this, n2)), T(this, r).body.append(g);
        }
        return T(this, n2);
      }, $ = /* @__PURE__ */ new WeakSet(), Yt = function(g, _, U) {
        const N = T(this, r).createElementNS(y, _);
        N.setAttribute("type", "discrete"), N.setAttribute("tableValues", U), g.append(N);
      }, d2.DOMFilterFactory = O;
      class p2 extends e2.BaseCanvasFactory {
        constructor() {
          let { ownerDocument: P = globalThis.document } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super(), this._document = P;
        }
        _createCanvas(P, g) {
          const _ = this._document.createElement("canvas");
          return _.width = P, _.height = g, _;
        }
      }
      d2.DOMCanvasFactory = p2;
      async function h2(f) {
        let P = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        if (x2(f, document.baseURI)) {
          const g = await fetch(f);
          if (!g.ok)
            throw new Error(g.statusText);
          return P ? new Uint8Array(await g.arrayBuffer()) : (0, a2.stringToBytes)(await g.text());
        }
        return new Promise((g, _) => {
          const U = new XMLHttpRequest();
          U.open("GET", f, true), P && (U.responseType = "arraybuffer"), U.onreadystatechange = () => {
            if (U.readyState === XMLHttpRequest.DONE) {
              if (U.status === 200 || U.status === 0) {
                let N;
                if (P && U.response ? N = new Uint8Array(U.response) : !P && U.responseText && (N = (0, a2.stringToBytes)(U.responseText)), N) {
                  g(N);
                  return;
                }
              }
              _(new Error(U.statusText));
            }
          }, U.send(null);
        });
      }
      class l2 extends e2.BaseCMapReaderFactory {
        _fetchData(P, g) {
          return h2(P, this.isCompressed).then((_) => ({ cMapData: _, compressionType: g }));
        }
      }
      d2.DOMCMapReaderFactory = l2;
      class c2 extends e2.BaseStandardFontDataFactory {
        _fetchData(P) {
          return h2(P, true);
        }
      }
      d2.DOMStandardFontDataFactory = c2;
      class b2 extends e2.BaseSVGFactory {
        _createSVG(P) {
          return document.createElementNS(y, P);
        }
      }
      d2.DOMSVGFactory = b2;
      class L2 {
        constructor(P) {
          let { viewBox: g, scale: _, rotation: U, offsetX: N = 0, offsetY: G = 0, dontFlip: V = false } = P;
          this.viewBox = g, this.scale = _, this.rotation = U, this.offsetX = N, this.offsetY = G;
          const W = (g[2] + g[0]) / 2, X = (g[3] + g[1]) / 2;
          let K, H, Z, dt, lt, E, R, j;
          switch (U %= 360, U < 0 && (U += 360), U) {
            case 180:
              K = -1, H = 0, Z = 0, dt = 1;
              break;
            case 90:
              K = 0, H = 1, Z = 1, dt = 0;
              break;
            case 270:
              K = 0, H = -1, Z = -1, dt = 0;
              break;
            case 0:
              K = 1, H = 0, Z = 0, dt = -1;
              break;
            default:
              throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
          }
          V && (Z = -Z, dt = -dt), K === 0 ? (lt = Math.abs(X - g[1]) * _ + N, E = Math.abs(W - g[0]) * _ + G, R = (g[3] - g[1]) * _, j = (g[2] - g[0]) * _) : (lt = Math.abs(W - g[0]) * _ + N, E = Math.abs(X - g[1]) * _ + G, R = (g[2] - g[0]) * _, j = (g[3] - g[1]) * _), this.transform = [K * _, H * _, Z * _, dt * _, lt - K * _ * W - Z * _ * X, E - H * _ * W - dt * _ * X], this.width = R, this.height = j;
        }
        get rawDims() {
          const { viewBox: P } = this;
          return (0, a2.shadow)(this, "rawDims", { pageWidth: P[2] - P[0], pageHeight: P[3] - P[1], pageX: P[0], pageY: P[1] });
        }
        clone() {
          let { scale: P = this.scale, rotation: g = this.rotation, offsetX: _ = this.offsetX, offsetY: U = this.offsetY, dontFlip: N = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return new L2({ viewBox: this.viewBox.slice(), scale: P, rotation: g, offsetX: _, offsetY: U, dontFlip: N });
        }
        convertToViewportPoint(P, g) {
          return a2.Util.applyTransform([P, g], this.transform);
        }
        convertToViewportRectangle(P) {
          const g = a2.Util.applyTransform([P[0], P[1]], this.transform), _ = a2.Util.applyTransform([P[2], P[3]], this.transform);
          return [g[0], g[1], _[0], _[1]];
        }
        convertToPdfPoint(P, g) {
          return a2.Util.applyInverseTransform([P, g], this.transform);
        }
      }
      d2.PageViewport = L2;
      class m2 extends a2.BaseException {
        constructor(P, g) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          super(P, "RenderingCancelledException"), this.type = g, this.extraDelay = _;
        }
      }
      d2.RenderingCancelledException = m2;
      function M(f) {
        const P = f.length;
        let g = 0;
        for (; g < P && f[g].trim() === ""; )
          g++;
        return f.substring(g, g + 5).toLowerCase() === "data:";
      }
      d2.StatTimer = class {
        constructor() {
          It(this, "started", /* @__PURE__ */ Object.create(null));
          It(this, "times", []);
        }
        time(P) {
          P in this.started && (0, a2.warn)(`Timer is already running for ${P}`), this.started[P] = Date.now();
        }
        timeEnd(P) {
          P in this.started || (0, a2.warn)(`Timer has not been started for ${P}`), this.times.push({ name: P, start: this.started[P], end: Date.now() }), delete this.started[P];
        }
        toString() {
          const P = [];
          let g = 0;
          for (const { name: _ } of this.times)
            g = Math.max(_.length, g);
          for (const { name: _, start: U, end: N } of this.times)
            P.push(`${_.padEnd(g)} ${N - U}ms
`);
          return P.join("");
        }
      };
      function x2(f, P) {
        try {
          const { protocol: g } = P ? new URL(f, P) : new URL(f);
          return g === "http:" || g === "https:";
        } catch {
          return false;
        }
      }
      let I2;
      d2.PDFDateString = class {
        static toDateObject(P) {
          if (!P || typeof P != "string")
            return null;
          I2 || (I2 = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
          const g = I2.exec(P);
          if (!g)
            return null;
          const _ = parseInt(g[1], 10);
          let U = parseInt(g[2], 10);
          U = U >= 1 && U <= 12 ? U - 1 : 0;
          let N = parseInt(g[3], 10);
          N = N >= 1 && N <= 31 ? N : 1;
          let G = parseInt(g[4], 10);
          G = G >= 0 && G <= 23 ? G : 0;
          let V = parseInt(g[5], 10);
          V = V >= 0 && V <= 59 ? V : 0;
          let W = parseInt(g[6], 10);
          W = W >= 0 && W <= 59 ? W : 0;
          const X = g[7] || "Z";
          let K = parseInt(g[8], 10);
          K = K >= 0 && K <= 23 ? K : 0;
          let H = parseInt(g[9], 10) || 0;
          return H = H >= 0 && H <= 59 ? H : 0, X === "-" ? (G += K, V += H) : X === "+" && (G -= K, V -= H), new Date(Date.UTC(_, U, N, G, V, W));
        }
      };
      function v(f) {
        if (f.startsWith("#")) {
          const P = parseInt(f.slice(1), 16);
          return [(16711680 & P) >> 16, (65280 & P) >> 8, 255 & P];
        }
        return f.startsWith("rgb(") ? f.slice(4, -1).split(",").map((P) => parseInt(P)) : f.startsWith("rgba(") ? f.slice(5, -1).split(",").map((P) => parseInt(P)).slice(0, 3) : ((0, a2.warn)(`Not a valid color format: "${f}"`), [0, 0, 0]);
      }
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.BaseStandardFontDataFactory = d2.BaseSVGFactory = d2.BaseFilterFactory = d2.BaseCanvasFactory = d2.BaseCMapReaderFactory = void 0;
      var e2 = t2(1);
      class a2 {
        constructor() {
          this.constructor === a2 && (0, e2.unreachable)("Cannot initialize BaseFilterFactory.");
        }
        addFilter(l2) {
          return "none";
        }
        addHCMFilter(l2, c2) {
          return "none";
        }
        destroy() {
        }
      }
      d2.BaseFilterFactory = a2;
      class y {
        constructor() {
          this.constructor === y && (0, e2.unreachable)("Cannot initialize BaseCanvasFactory.");
        }
        create(l2, c2) {
          if (l2 <= 0 || c2 <= 0)
            throw new Error("Invalid canvas size");
          const b2 = this._createCanvas(l2, c2);
          return { canvas: b2, context: b2.getContext("2d") };
        }
        reset(l2, c2, b2) {
          if (!l2.canvas)
            throw new Error("Canvas is not specified");
          if (c2 <= 0 || b2 <= 0)
            throw new Error("Invalid canvas size");
          l2.canvas.width = c2, l2.canvas.height = b2;
        }
        destroy(l2) {
          if (!l2.canvas)
            throw new Error("Canvas is not specified");
          l2.canvas.width = 0, l2.canvas.height = 0, l2.canvas = null, l2.context = null;
        }
        _createCanvas(l2, c2) {
          (0, e2.unreachable)("Abstract method `_createCanvas` called.");
        }
      }
      d2.BaseCanvasFactory = y;
      class w2 {
        constructor(l2) {
          let { baseUrl: c2 = null, isCompressed: b2 = true } = l2;
          this.constructor === w2 && (0, e2.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = c2, this.isCompressed = b2;
        }
        async fetch(l2) {
          let { name: c2 } = l2;
          if (!this.baseUrl)
            throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
          if (!c2)
            throw new Error("CMap name must be specified.");
          const b2 = this.baseUrl + c2 + (this.isCompressed ? ".bcmap" : ""), L2 = this.isCompressed ? e2.CMapCompressionType.BINARY : e2.CMapCompressionType.NONE;
          return this._fetchData(b2, L2).catch((m2) => {
            throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${b2}`);
          });
        }
        _fetchData(l2, c2) {
          (0, e2.unreachable)("Abstract method `_fetchData` called.");
        }
      }
      d2.BaseCMapReaderFactory = w2;
      class O {
        constructor(l2) {
          let { baseUrl: c2 = null } = l2;
          this.constructor === O && (0, e2.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = c2;
        }
        async fetch(l2) {
          let { filename: c2 } = l2;
          if (!this.baseUrl)
            throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
          if (!c2)
            throw new Error("Font filename must be specified.");
          const b2 = `${this.baseUrl}${c2}`;
          return this._fetchData(b2).catch((L2) => {
            throw new Error(`Unable to load font data at: ${b2}`);
          });
        }
        _fetchData(l2) {
          (0, e2.unreachable)("Abstract method `_fetchData` called.");
        }
      }
      d2.BaseStandardFontDataFactory = O;
      class p2 {
        constructor() {
          this.constructor === p2 && (0, e2.unreachable)("Cannot initialize BaseSVGFactory.");
        }
        create(l2, c2) {
          let b2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          if (l2 <= 0 || c2 <= 0)
            throw new Error("Invalid SVG dimensions");
          const L2 = this._createSVG("svg:svg");
          return L2.setAttribute("version", "1.1"), b2 || (L2.setAttribute("width", `${l2}px`), L2.setAttribute("height", `${c2}px`)), L2.setAttribute("preserveAspectRatio", "none"), L2.setAttribute("viewBox", `0 0 ${l2} ${c2}`), L2;
        }
        createElement(l2) {
          if (typeof l2 != "string")
            throw new Error("Invalid SVG element type");
          return this._createSVG(l2);
        }
        _createSVG(l2) {
          (0, e2.unreachable)("Abstract method `_createSVG` called.");
        }
      }
      d2.BaseSVGFactory = p2;
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.MurmurHash3_64 = void 0;
      var e2 = t2(1);
      const a2 = 3285377520, y = 4294901760, w2 = 65535;
      d2.MurmurHash3_64 = class {
        constructor(p2) {
          this.h1 = p2 ? 4294967295 & p2 : a2, this.h2 = p2 ? 4294967295 & p2 : a2;
        }
        update(p2) {
          let h2, l2;
          if (typeof p2 == "string") {
            h2 = new Uint8Array(2 * p2.length), l2 = 0;
            for (let s = 0, r = p2.length; s < r; s++) {
              const u = p2.charCodeAt(s);
              u <= 255 ? h2[l2++] = u : (h2[l2++] = u >>> 8, h2[l2++] = 255 & u);
            }
          } else {
            if (!(0, e2.isArrayBuffer)(p2))
              throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
            h2 = p2.slice(), l2 = h2.byteLength;
          }
          const c2 = l2 >> 2, b2 = l2 - 4 * c2, L2 = new Uint32Array(h2.buffer, 0, c2);
          let m2 = 0, M = 0, x2 = this.h1, I2 = this.h2;
          const v = 3432918353, i2 = 461845907, A2 = 11601, n2 = 13715;
          for (let s = 0; s < c2; s++)
            1 & s ? (m2 = L2[s], m2 = m2 * v & y | m2 * A2 & w2, m2 = m2 << 15 | m2 >>> 17, m2 = m2 * i2 & y | m2 * n2 & w2, x2 ^= m2, x2 = x2 << 13 | x2 >>> 19, x2 = 5 * x2 + 3864292196) : (M = L2[s], M = M * v & y | M * A2 & w2, M = M << 15 | M >>> 17, M = M * i2 & y | M * n2 & w2, I2 ^= M, I2 = I2 << 13 | I2 >>> 19, I2 = 5 * I2 + 3864292196);
          switch (m2 = 0, b2) {
            case 3:
              m2 ^= h2[4 * c2 + 2] << 16;
            case 2:
              m2 ^= h2[4 * c2 + 1] << 8;
            case 1:
              m2 ^= h2[4 * c2], m2 = m2 * v & y | m2 * A2 & w2, m2 = m2 << 15 | m2 >>> 17, m2 = m2 * i2 & y | m2 * n2 & w2, 1 & c2 ? x2 ^= m2 : I2 ^= m2;
          }
          this.h1 = x2, this.h2 = I2;
        }
        hexdigest() {
          let p2 = this.h1, h2 = this.h2;
          return p2 ^= h2 >>> 1, p2 = 3981806797 * p2 & y | 36045 * p2 & w2, h2 = 4283543511 * h2 & y | (2950163797 * (h2 << 16 | p2 >>> 16) & y) >>> 16, p2 ^= h2 >>> 1, p2 = 444984403 * p2 & y | 60499 * p2 & w2, h2 = 3301882366 * h2 & y | (3120437893 * (h2 << 16 | p2 >>> 16) & y) >>> 16, p2 ^= h2 >>> 1, (p2 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
        }
      };
    }, (k2, d2, t2) => {
      var y, w2;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.FontLoader = d2.FontFaceObject = void 0;
      var e2 = t2(1), a2 = t2(3);
      d2.FontLoader = (w2 = class {
        constructor(p2) {
          et(this, y, /* @__PURE__ */ new Set());
          let { ownerDocument: h2 = globalThis.document, styleElement: l2 = null } = p2;
          this._document = h2, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
        }
        addNativeFontFace(p2) {
          this.nativeFontFaces.add(p2), this._document.fonts.add(p2);
        }
        removeNativeFontFace(p2) {
          this.nativeFontFaces.delete(p2), this._document.fonts.delete(p2);
        }
        insertRule(p2) {
          this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
          const h2 = this.styleElement.sheet;
          h2.insertRule(p2, h2.cssRules.length);
        }
        clear() {
          for (const p2 of this.nativeFontFaces)
            this._document.fonts.delete(p2);
          this.nativeFontFaces.clear(), T(this, y).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
        }
        async loadSystemFont(p2) {
          if (p2 && !T(this, y).has(p2.loadedName))
            if ((0, e2.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
              const { loadedName: h2, src: l2, style: c2 } = p2, b2 = new FontFace(h2, l2, c2);
              this.addNativeFontFace(b2);
              try {
                await b2.load(), T(this, y).add(h2);
              } catch {
                (0, e2.warn)(`Cannot load system font: ${p2.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(b2);
              }
            } else
              (0, e2.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
        }
        async bind(p2) {
          if (p2.attached || p2.missingFile && !p2.systemFontInfo)
            return;
          if (p2.attached = true, p2.systemFontInfo) {
            await this.loadSystemFont(p2.systemFontInfo);
            return;
          }
          if (this.isFontLoadingAPISupported) {
            const l2 = p2.createNativeFontFace();
            if (l2) {
              this.addNativeFontFace(l2);
              try {
                await l2.loaded;
              } catch (c2) {
                throw (0, e2.warn)(`Failed to load font '${l2.family}': '${c2}'.`), p2.disableFontFace = true, c2;
              }
            }
            return;
          }
          const h2 = p2.createFontFaceRule();
          if (h2) {
            if (this.insertRule(h2), this.isSyncFontLoadingSupported)
              return;
            await new Promise((l2) => {
              const c2 = this._queueLoadingCallback(l2);
              this._prepareFontLoadEvent(p2, c2);
            });
          }
        }
        get isFontLoadingAPISupported() {
          var p2;
          const h2 = !((p2 = this._document) === null || p2 === void 0 || !p2.fonts);
          return (0, e2.shadow)(this, "isFontLoadingAPISupported", h2);
        }
        get isSyncFontLoadingSupported() {
          let p2 = false;
          return (a2.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (p2 = true), (0, e2.shadow)(this, "isSyncFontLoadingSupported", p2);
        }
        _queueLoadingCallback(p2) {
          const { loadingRequests: h2 } = this, l2 = { done: false, complete: function() {
            for ((0, e2.assert)(!l2.done, "completeRequest() cannot be called twice."), l2.done = true; h2.length > 0 && h2[0].done; ) {
              const b2 = h2.shift();
              setTimeout(b2.callback, 0);
            }
          }, callback: p2 };
          return h2.push(l2), l2;
        }
        get _loadTestFont() {
          const p2 = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
          return (0, e2.shadow)(this, "_loadTestFont", p2);
        }
        _prepareFontLoadEvent(p2, h2) {
          function l2(r, u) {
            return r.charCodeAt(u) << 24 | r.charCodeAt(u + 1) << 16 | r.charCodeAt(u + 2) << 8 | 255 & r.charCodeAt(u + 3);
          }
          function c2(r, u, C, D) {
            return r.substring(0, u) + D + r.substring(u + C);
          }
          let b2, L2;
          const m2 = this._document.createElement("canvas");
          m2.width = 1, m2.height = 1;
          const M = m2.getContext("2d");
          let x2 = 0;
          const I2 = `lt${Date.now()}${this.loadTestFontId++}`;
          let v = this._loadTestFont;
          v = c2(v, 976, I2.length, I2);
          const i2 = 1482184792;
          let A2 = l2(v, 16);
          for (b2 = 0, L2 = I2.length - 3; b2 < L2; b2 += 4)
            A2 = A2 - i2 + l2(I2, b2) | 0;
          b2 < I2.length && (A2 = A2 - i2 + l2(I2 + "XXX", b2) | 0), v = c2(v, 16, 4, (0, e2.string32)(A2));
          const n2 = `@font-face {font-family:"${I2}";src:${`url(data:font/opentype;base64,${btoa(v)});`}}`;
          this.insertRule(n2);
          const s = this._document.createElement("div");
          s.style.visibility = "hidden", s.style.width = s.style.height = "10px", s.style.position = "absolute", s.style.top = s.style.left = "0px";
          for (const r of [p2.loadedName, I2]) {
            const u = this._document.createElement("span");
            u.textContent = "Hi", u.style.fontFamily = r, s.append(u);
          }
          this._document.body.append(s), function r(u, C) {
            if (++x2 > 30) {
              (0, e2.warn)("Load test font never loaded."), C();
              return;
            }
            M.font = "30px " + u, M.fillText(".", 0, 20), M.getImageData(0, 0, 1, 1).data[3] > 0 ? C() : setTimeout(r.bind(null, u, C));
          }(I2, () => {
            s.remove(), h2.complete();
          });
        }
      }, y = /* @__PURE__ */ new WeakMap(), w2), d2.FontFaceObject = class {
        constructor(p2, h2) {
          let { isEvalSupported: l2 = true, disableFontFace: c2 = false, ignoreErrors: b2 = false, inspectFont: L2 = null } = h2;
          this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
          for (const m2 in p2)
            this[m2] = p2[m2];
          this.isEvalSupported = l2 !== false, this.disableFontFace = c2 === true, this.ignoreErrors = b2 === true, this._inspectFont = L2;
        }
        createNativeFontFace() {
          var p2;
          if (!this.data || this.disableFontFace)
            return null;
          let h2;
          if (this.cssFontInfo) {
            const l2 = { weight: this.cssFontInfo.fontWeight };
            this.cssFontInfo.italicAngle && (l2.style = `oblique ${this.cssFontInfo.italicAngle}deg`), h2 = new FontFace(this.cssFontInfo.fontFamily, this.data, l2);
          } else
            h2 = new FontFace(this.loadedName, this.data, {});
          return (p2 = this._inspectFont) === null || p2 === void 0 || p2.call(this, this), h2;
        }
        createFontFaceRule() {
          var p2;
          if (!this.data || this.disableFontFace)
            return null;
          const h2 = (0, e2.bytesToString)(this.data), l2 = `url(data:${this.mimetype};base64,${btoa(h2)});`;
          let c2;
          if (this.cssFontInfo) {
            let b2 = `font-weight: ${this.cssFontInfo.fontWeight};`;
            this.cssFontInfo.italicAngle && (b2 += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), c2 = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${b2}src:${l2}}`;
          } else
            c2 = `@font-face {font-family:"${this.loadedName}";src:${l2}}`;
          return (p2 = this._inspectFont) === null || p2 === void 0 || p2.call(this, this, l2), c2;
        }
        getPathGenerator(p2, h2) {
          if (this.compiledGlyphs[h2] !== void 0)
            return this.compiledGlyphs[h2];
          let l2;
          try {
            l2 = p2.get(this.loadedName + "_path_" + h2);
          } catch (c2) {
            if (!this.ignoreErrors)
              throw c2;
            return (0, e2.warn)(`getPathGenerator - ignoring character: "${c2}".`), this.compiledGlyphs[h2] = function(b2, L2) {
            };
          }
          if (this.isEvalSupported && e2.FeatureTest.isEvalSupported) {
            const c2 = [];
            for (const b2 of l2) {
              const L2 = b2.args !== void 0 ? b2.args.join(",") : "";
              c2.push("c.", b2.cmd, "(", L2, `);
`);
            }
            return this.compiledGlyphs[h2] = new Function("c", "size", c2.join(""));
          }
          return this.compiledGlyphs[h2] = function(c2, b2) {
            for (const L2 of l2)
              L2.cmd === "scale" && (L2.args = [b2, -b2]), c2[L2.cmd].apply(c2, L2.args);
          };
        }
      };
    }, (k2, d2, t2) => {
      var o, we, z, Ee;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.CanvasGraphics = void 0;
      var e2 = t2(1), a2 = t2(142), y = t2(147), w2 = t2(148), O = t2(3);
      const p2 = 4096, h2 = 16;
      class l2 {
        constructor(S) {
          this.canvasFactory = S, this.cache = /* @__PURE__ */ Object.create(null);
        }
        getCanvas(S, f, P) {
          let g;
          return this.cache[S] !== void 0 ? (g = this.cache[S], this.canvasFactory.reset(g, f, P)) : (g = this.canvasFactory.create(f, P), this.cache[S] = g), g;
        }
        delete(S) {
          delete this.cache[S];
        }
        clear() {
          for (const S in this.cache) {
            const f = this.cache[S];
            this.canvasFactory.destroy(f), delete this.cache[S];
          }
        }
      }
      function c2($, S, f, P, g, _, U, N, G, V) {
        const [W, X, K, H, Z, dt] = (0, a2.getCurrentTransform)($);
        if (X === 0 && K === 0) {
          const lt = U * W + Z, E = Math.round(lt), R = N * H + dt, j = Math.round(R), B = (U + G) * W + Z, Y = Math.abs(Math.round(B) - E) || 1, tt = (N + V) * H + dt, rt = Math.abs(Math.round(tt) - j) || 1;
          return $.setTransform(Math.sign(W), 0, 0, Math.sign(H), E, j), $.drawImage(S, f, P, g, _, 0, 0, Y, rt), $.setTransform(W, X, K, H, Z, dt), [Y, rt];
        }
        if (W === 0 && H === 0) {
          const lt = N * K + Z, E = Math.round(lt), R = U * X + dt, j = Math.round(R), B = (N + V) * K + Z, Y = Math.abs(Math.round(B) - E) || 1, tt = (U + G) * X + dt, rt = Math.abs(Math.round(tt) - j) || 1;
          return $.setTransform(0, Math.sign(X), Math.sign(K), 0, E, j), $.drawImage(S, f, P, g, _, 0, 0, rt, Y), $.setTransform(W, X, K, H, Z, dt), [rt, Y];
        }
        return $.drawImage(S, f, P, g, _, U, N, G, V), [Math.hypot(W, X) * G, Math.hypot(K, H) * V];
      }
      class b2 {
        constructor(S, f) {
          this.alphaIsShape = false, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = e2.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = e2.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = e2.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = false, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, S, f]);
        }
        clone() {
          const S = Object.create(this);
          return S.clipBox = this.clipBox.slice(), S;
        }
        setCurrentPoint(S, f) {
          this.x = S, this.y = f;
        }
        updatePathMinMax(S, f, P) {
          [f, P] = e2.Util.applyTransform([f, P], S), this.minX = Math.min(this.minX, f), this.minY = Math.min(this.minY, P), this.maxX = Math.max(this.maxX, f), this.maxY = Math.max(this.maxY, P);
        }
        updateRectMinMax(S, f) {
          const P = e2.Util.applyTransform(f, S), g = e2.Util.applyTransform(f.slice(2), S);
          this.minX = Math.min(this.minX, P[0], g[0]), this.minY = Math.min(this.minY, P[1], g[1]), this.maxX = Math.max(this.maxX, P[0], g[0]), this.maxY = Math.max(this.maxY, P[1], g[1]);
        }
        updateScalingPathMinMax(S, f) {
          e2.Util.scaleMinMax(S, f), this.minX = Math.min(this.minX, f[0]), this.maxX = Math.max(this.maxX, f[1]), this.minY = Math.min(this.minY, f[2]), this.maxY = Math.max(this.maxY, f[3]);
        }
        updateCurvePathMinMax(S, f, P, g, _, U, N, G, V, W) {
          const X = e2.Util.bezierBoundingBox(f, P, g, _, U, N, G, V);
          W ? (W[0] = Math.min(W[0], X[0], X[2]), W[1] = Math.max(W[1], X[0], X[2]), W[2] = Math.min(W[2], X[1], X[3]), W[3] = Math.max(W[3], X[1], X[3])) : this.updateRectMinMax(S, X);
        }
        getPathBoundingBox() {
          let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : y.PathType.FILL, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          const P = [this.minX, this.minY, this.maxX, this.maxY];
          if (S === y.PathType.STROKE) {
            f || (0, e2.unreachable)("Stroke bounding box must include transform.");
            const g = e2.Util.singularValueDecompose2dScale(f), _ = g[0] * this.lineWidth / 2, U = g[1] * this.lineWidth / 2;
            P[0] -= _, P[1] -= U, P[2] += _, P[3] += U;
          }
          return P;
        }
        updateClipFromPath() {
          const S = e2.Util.intersect(this.clipBox, this.getPathBoundingBox());
          this.startNewPathAndClipBox(S || [0, 0, 0, 0]);
        }
        isEmptyClip() {
          return this.minX === 1 / 0;
        }
        startNewPathAndClipBox(S) {
          this.clipBox = S, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
        }
        getClippedPathBoundingBox() {
          let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : y.PathType.FILL, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          return e2.Util.intersect(this.clipBox, this.getPathBoundingBox(S, f));
        }
      }
      function L2($, S) {
        if (typeof ImageData < "u" && S instanceof ImageData) {
          $.putImageData(S, 0, 0);
          return;
        }
        const f = S.height, P = S.width, g = f % h2, _ = (f - g) / h2, U = g === 0 ? _ : _ + 1, N = $.createImageData(P, h2);
        let G, V = 0;
        const W = S.data, X = N.data;
        let K, H, Z, dt;
        if (S.kind === e2.ImageKind.GRAYSCALE_1BPP) {
          const lt = W.byteLength, E = new Uint32Array(X.buffer, 0, X.byteLength >> 2), R = E.length, j = P + 7 >> 3, B = 4294967295, Y = e2.FeatureTest.isLittleEndian ? 4278190080 : 255;
          for (K = 0; K < U; K++) {
            for (Z = K < _ ? h2 : g, G = 0, H = 0; H < Z; H++) {
              const tt = lt - V;
              let rt = 0;
              const it = tt > j ? P : 8 * tt - 7, At = -8 & it;
              let ct = 0, vt = 0;
              for (; rt < At; rt += 8)
                vt = W[V++], E[G++] = 128 & vt ? B : Y, E[G++] = 64 & vt ? B : Y, E[G++] = 32 & vt ? B : Y, E[G++] = 16 & vt ? B : Y, E[G++] = 8 & vt ? B : Y, E[G++] = 4 & vt ? B : Y, E[G++] = 2 & vt ? B : Y, E[G++] = 1 & vt ? B : Y;
              for (; rt < it; rt++)
                ct === 0 && (vt = W[V++], ct = 128), E[G++] = vt & ct ? B : Y, ct >>= 1;
            }
            for (; G < R; )
              E[G++] = 0;
            $.putImageData(N, 0, K * h2);
          }
        } else if (S.kind === e2.ImageKind.RGBA_32BPP) {
          for (H = 0, dt = P * h2 * 4, K = 0; K < _; K++)
            X.set(W.subarray(V, V + dt)), V += dt, $.putImageData(N, 0, H), H += h2;
          K < U && (dt = P * g * 4, X.set(W.subarray(V, V + dt)), $.putImageData(N, 0, H));
        } else {
          if (S.kind !== e2.ImageKind.RGB_24BPP)
            throw new Error(`bad image kind: ${S.kind}`);
          for (Z = h2, dt = P * Z, K = 0; K < U; K++) {
            for (K >= _ && (Z = g, dt = P * Z), G = 0, H = dt; H--; )
              X[G++] = W[V++], X[G++] = W[V++], X[G++] = W[V++], X[G++] = 255;
            $.putImageData(N, 0, K * h2);
          }
        }
      }
      function m2($, S) {
        if (S.bitmap) {
          $.drawImage(S.bitmap, 0, 0);
          return;
        }
        const f = S.height, P = S.width, g = f % h2, _ = (f - g) / h2, U = g === 0 ? _ : _ + 1, N = $.createImageData(P, h2);
        let G = 0;
        const V = S.data, W = N.data;
        for (let X = 0; X < U; X++) {
          const K = X < _ ? h2 : g;
          ({ srcPos: G } = (0, w2.convertBlackAndWhiteToRGBA)({ src: V, srcPos: G, dest: W, width: P, height: K, nonBlackColor: 0 })), $.putImageData(N, 0, X * h2);
        }
      }
      function M($, S) {
        const f = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
        for (const P of f)
          $[P] !== void 0 && (S[P] = $[P]);
        $.setLineDash !== void 0 && (S.setLineDash($.getLineDash()), S.lineDashOffset = $.lineDashOffset);
      }
      function x2($) {
        $.strokeStyle = $.fillStyle = "#000000", $.fillRule = "nonzero", $.globalAlpha = 1, $.lineWidth = 1, $.lineCap = "butt", $.lineJoin = "miter", $.miterLimit = 10, $.globalCompositeOperation = "source-over", $.font = "10px sans-serif", $.setLineDash !== void 0 && ($.setLineDash([]), $.lineDashOffset = 0), O.isNodeJS || ($.filter = "none");
      }
      function I2($, S, f, P) {
        const g = $.length;
        for (let _ = 3; _ < g; _ += 4) {
          const U = $[_];
          if (U === 0)
            $[_ - 3] = S, $[_ - 2] = f, $[_ - 1] = P;
          else if (U < 255) {
            const N = 255 - U;
            $[_ - 3] = $[_ - 3] * U + S * N >> 8, $[_ - 2] = $[_ - 2] * U + f * N >> 8, $[_ - 1] = $[_ - 1] * U + P * N >> 8;
          }
        }
      }
      function v($, S, f) {
        const P = $.length;
        for (let g = 3; g < P; g += 4) {
          const _ = f ? f[$[g]] : $[g];
          S[g] = S[g] * _ * 0.00392156862745098 | 0;
        }
      }
      function i2($, S, f) {
        const P = $.length;
        for (let g = 3; g < P; g += 4) {
          const _ = 77 * $[g - 3] + 152 * $[g - 2] + 28 * $[g - 1];
          S[g] = f ? S[g] * f[_ >> 8] >> 8 : S[g] * _ >> 16;
        }
      }
      function A2($, S, f, P) {
        const g = P[0], _ = P[1], U = P[2] - g, N = P[3] - _;
        U !== 0 && N !== 0 && (function(V, W, X, K, H, Z, dt, lt, E, R, j) {
          const B = !!Z, Y = B ? Z[0] : 0, tt = B ? Z[1] : 0, rt = B ? Z[2] : 0;
          let it;
          it = H === "Luminosity" ? i2 : v;
          const At = Math.min(K, Math.ceil(1048576 / X));
          for (let ct = 0; ct < K; ct += At) {
            const vt = Math.min(At, K - ct), ht = V.getImageData(lt - R, ct + (E - j), X, vt), mt = W.getImageData(lt, ct + E, X, vt);
            B && I2(ht.data, Y, tt, rt), it(ht.data, mt.data, dt), W.putImageData(mt, lt, ct + E);
          }
        }(S.context, f, U, N, S.subtype, S.backdrop, S.transferMap, g, _, S.offsetX, S.offsetY), $.save(), $.globalAlpha = 1, $.globalCompositeOperation = "source-over", $.setTransform(1, 0, 0, 1, 0, 0), $.drawImage(f.canvas, 0, 0), $.restore());
      }
      function n2($, S) {
        const f = e2.Util.singularValueDecompose2dScale($);
        f[0] = Math.fround(f[0]), f[1] = Math.fround(f[1]);
        const P = Math.fround((globalThis.devicePixelRatio || 1) * a2.PixelsPerInch.PDF_TO_CSS_UNITS);
        return S !== void 0 ? S : f[0] <= P || f[1] <= P;
      }
      const s = ["butt", "round", "square"], r = ["miter", "round", "bevel"], u = {}, C = {}, J = class {
        constructor(S, f, P, g, _, U, N, G) {
          et(this, o);
          et(this, z);
          let { optionalContentConfig: V, markedContentStack: W = null } = U;
          this.ctx = S, this.current = new b2(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = false, this.res = null, this.xobjs = null, this.commonObjs = f, this.objs = P, this.canvasFactory = g, this.filterFactory = _, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = true, this.markedContentStack = W || [], this.optionalContentConfig = V, this.cachedCanvases = new l2(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = N, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = G, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
        }
        getObject(S) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          return typeof S == "string" ? S.startsWith("g_") ? this.commonObjs.get(S) : this.objs.get(S) : f;
        }
        beginDrawing(S) {
          let { transform: f, viewport: P, transparency: g = false, background: _ = null } = S;
          const U = this.ctx.canvas.width, N = this.ctx.canvas.height, G = this.ctx.fillStyle;
          if (this.ctx.fillStyle = _ || "#ffffff", this.ctx.fillRect(0, 0, U, N), this.ctx.fillStyle = G, g) {
            const V = this.cachedCanvases.getCanvas("transparent", U, N);
            this.compositeCtx = this.ctx, this.transparentCanvas = V.canvas, this.ctx = V.context, this.ctx.save(), this.ctx.transform(...(0, a2.getCurrentTransform)(this.compositeCtx));
          }
          this.ctx.save(), x2(this.ctx), f && (this.ctx.transform(...f), this.outputScaleX = f[0], this.outputScaleY = f[0]), this.ctx.transform(...P.transform), this.viewportScale = P.scale, this.baseTransform = (0, a2.getCurrentTransform)(this.ctx);
        }
        executeOperatorList(S, f, P, g) {
          const _ = S.argsArray, U = S.fnArray;
          let N = f || 0;
          const G = _.length;
          if (G === N)
            return N;
          const V = G - N > 10 && typeof P == "function", W = V ? Date.now() + 15 : 0;
          let X = 0;
          const K = this.commonObjs, H = this.objs;
          let Z;
          for (; ; ) {
            if (g !== void 0 && N === g.nextBreakPoint)
              return g.breakIt(N, P), N;
            if (Z = U[N], Z !== e2.OPS.dependency)
              this[Z].apply(this, _[N]);
            else
              for (const dt of _[N]) {
                const lt = dt.startsWith("g_") ? K : H;
                if (!lt.has(dt))
                  return lt.get(dt, P), N;
              }
            if (N++, N === G)
              return N;
            if (V && ++X > 10) {
              if (Date.now() > W)
                return P(), N;
              X = 0;
            }
          }
        }
        endDrawing() {
          nt(this, o, we).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
          for (const S of this._cachedBitmapsMap.values()) {
            for (const f of S.values())
              typeof HTMLCanvasElement < "u" && f instanceof HTMLCanvasElement && (f.width = f.height = 0);
            S.clear();
          }
          this._cachedBitmapsMap.clear(), nt(this, z, Ee).call(this);
        }
        _scaleImage(S, f) {
          const P = S.width, g = S.height;
          let _, U, N = Math.max(Math.hypot(f[0], f[1]), 1), G = Math.max(Math.hypot(f[2], f[3]), 1), V = P, W = g, X = "prescale1";
          for (; N > 2 && V > 1 || G > 2 && W > 1; ) {
            let K = V, H = W;
            N > 2 && V > 1 && (K = V >= 16384 ? Math.floor(V / 2) - 1 || 1 : Math.ceil(V / 2), N /= V / K), G > 2 && W > 1 && (H = W >= 16384 ? Math.floor(W / 2) - 1 || 1 : Math.ceil(W) / 2, G /= W / H), _ = this.cachedCanvases.getCanvas(X, K, H), U = _.context, U.clearRect(0, 0, K, H), U.drawImage(S, 0, 0, V, W, 0, 0, K, H), S = _.canvas, V = K, W = H, X = X === "prescale1" ? "prescale2" : "prescale1";
          }
          return { img: S, paintWidth: V, paintHeight: W };
        }
        _createMaskCanvas(S) {
          const f = this.ctx, { width: P, height: g } = S, _ = this.current.fillColor, U = this.current.patternFill, N = (0, a2.getCurrentTransform)(f);
          let G, V, W, X;
          if ((S.bitmap || S.data) && S.count > 1) {
            const rt = S.bitmap || S.data.buffer;
            V = JSON.stringify(U ? N : [N.slice(0, 4), _]), G = this._cachedBitmapsMap.get(rt), G || (G = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(rt, G));
            const it = G.get(V);
            if (it && !U)
              return { canvas: it, offsetX: Math.round(Math.min(N[0], N[2]) + N[4]), offsetY: Math.round(Math.min(N[1], N[3]) + N[5]) };
            W = it;
          }
          W || (X = this.cachedCanvases.getCanvas("maskCanvas", P, g), m2(X.context, S));
          let K = e2.Util.transform(N, [1 / P, 0, 0, -1 / g, 0, 0]);
          K = e2.Util.transform(K, [1, 0, 0, 1, 0, -g]);
          const H = e2.Util.applyTransform([0, 0], K), Z = e2.Util.applyTransform([P, g], K), dt = e2.Util.normalizeRect([H[0], H[1], Z[0], Z[1]]), lt = Math.round(dt[2] - dt[0]) || 1, E = Math.round(dt[3] - dt[1]) || 1, R = this.cachedCanvases.getCanvas("fillCanvas", lt, E), j = R.context, B = Math.min(H[0], Z[0]), Y = Math.min(H[1], Z[1]);
          j.translate(-B, -Y), j.transform(...K), W || (W = this._scaleImage(X.canvas, (0, a2.getCurrentTransformInverse)(j)), W = W.img, G && U && G.set(V, W)), j.imageSmoothingEnabled = n2((0, a2.getCurrentTransform)(j), S.interpolate), c2(j, W, 0, 0, W.width, W.height, 0, 0, P, g), j.globalCompositeOperation = "source-in";
          const tt = e2.Util.transform((0, a2.getCurrentTransformInverse)(j), [1, 0, 0, 1, -B, -Y]);
          return j.fillStyle = U ? _.getPattern(f, this, tt, y.PathType.FILL) : _, j.fillRect(0, 0, P, g), G && !U && (this.cachedCanvases.delete("fillCanvas"), G.set(V, R.canvas)), { canvas: R.canvas, offsetX: Math.round(B), offsetY: Math.round(Y) };
        }
        setLineWidth(S) {
          S !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = S, this.ctx.lineWidth = S;
        }
        setLineCap(S) {
          this.ctx.lineCap = s[S];
        }
        setLineJoin(S) {
          this.ctx.lineJoin = r[S];
        }
        setMiterLimit(S) {
          this.ctx.miterLimit = S;
        }
        setDash(S, f) {
          const P = this.ctx;
          P.setLineDash !== void 0 && (P.setLineDash(S), P.lineDashOffset = f);
        }
        setRenderingIntent(S) {
        }
        setFlatness(S) {
        }
        setGState(S) {
          for (const [f, P] of S)
            switch (f) {
              case "LW":
                this.setLineWidth(P);
                break;
              case "LC":
                this.setLineCap(P);
                break;
              case "LJ":
                this.setLineJoin(P);
                break;
              case "ML":
                this.setMiterLimit(P);
                break;
              case "D":
                this.setDash(P[0], P[1]);
                break;
              case "RI":
                this.setRenderingIntent(P);
                break;
              case "FL":
                this.setFlatness(P);
                break;
              case "Font":
                this.setFont(P[0], P[1]);
                break;
              case "CA":
                this.current.strokeAlpha = P;
                break;
              case "ca":
                this.current.fillAlpha = P, this.ctx.globalAlpha = P;
                break;
              case "BM":
                this.ctx.globalCompositeOperation = P;
                break;
              case "SMask":
                this.current.activeSMask = P ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                break;
              case "TR":
                this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(P);
            }
        }
        get inSMaskMode() {
          return !!this.suspendedCtx;
        }
        checkSMaskState() {
          const S = this.inSMaskMode;
          this.current.activeSMask && !S ? this.beginSMaskMode() : !this.current.activeSMask && S && this.endSMaskMode();
        }
        beginSMaskMode() {
          if (this.inSMaskMode)
            throw new Error("beginSMaskMode called while already in smask mode");
          const S = this.ctx.canvas.width, f = this.ctx.canvas.height, P = "smaskGroupAt" + this.groupLevel, g = this.cachedCanvases.getCanvas(P, S, f);
          this.suspendedCtx = this.ctx, this.ctx = g.context;
          const _ = this.ctx;
          _.setTransform(...(0, a2.getCurrentTransform)(this.suspendedCtx)), M(this.suspendedCtx, _), function(N, G) {
            if (N._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            N.__originalSave = N.save, N.__originalRestore = N.restore, N.__originalRotate = N.rotate, N.__originalScale = N.scale, N.__originalTranslate = N.translate, N.__originalTransform = N.transform, N.__originalSetTransform = N.setTransform, N.__originalResetTransform = N.resetTransform, N.__originalClip = N.clip, N.__originalMoveTo = N.moveTo, N.__originalLineTo = N.lineTo, N.__originalBezierCurveTo = N.bezierCurveTo, N.__originalRect = N.rect, N.__originalClosePath = N.closePath, N.__originalBeginPath = N.beginPath, N._removeMirroring = () => {
              N.save = N.__originalSave, N.restore = N.__originalRestore, N.rotate = N.__originalRotate, N.scale = N.__originalScale, N.translate = N.__originalTranslate, N.transform = N.__originalTransform, N.setTransform = N.__originalSetTransform, N.resetTransform = N.__originalResetTransform, N.clip = N.__originalClip, N.moveTo = N.__originalMoveTo, N.lineTo = N.__originalLineTo, N.bezierCurveTo = N.__originalBezierCurveTo, N.rect = N.__originalRect, N.closePath = N.__originalClosePath, N.beginPath = N.__originalBeginPath, delete N._removeMirroring;
            }, N.save = function() {
              G.save(), this.__originalSave();
            }, N.restore = function() {
              G.restore(), this.__originalRestore();
            }, N.translate = function(W, X) {
              G.translate(W, X), this.__originalTranslate(W, X);
            }, N.scale = function(W, X) {
              G.scale(W, X), this.__originalScale(W, X);
            }, N.transform = function(W, X, K, H, Z, dt) {
              G.transform(W, X, K, H, Z, dt), this.__originalTransform(W, X, K, H, Z, dt);
            }, N.setTransform = function(W, X, K, H, Z, dt) {
              G.setTransform(W, X, K, H, Z, dt), this.__originalSetTransform(W, X, K, H, Z, dt);
            }, N.resetTransform = function() {
              G.resetTransform(), this.__originalResetTransform();
            }, N.rotate = function(W) {
              G.rotate(W), this.__originalRotate(W);
            }, N.clip = function(W) {
              G.clip(W), this.__originalClip(W);
            }, N.moveTo = function(V, W) {
              G.moveTo(V, W), this.__originalMoveTo(V, W);
            }, N.lineTo = function(V, W) {
              G.lineTo(V, W), this.__originalLineTo(V, W);
            }, N.bezierCurveTo = function(V, W, X, K, H, Z) {
              G.bezierCurveTo(V, W, X, K, H, Z), this.__originalBezierCurveTo(V, W, X, K, H, Z);
            }, N.rect = function(V, W, X, K) {
              G.rect(V, W, X, K), this.__originalRect(V, W, X, K);
            }, N.closePath = function() {
              G.closePath(), this.__originalClosePath();
            }, N.beginPath = function() {
              G.beginPath(), this.__originalBeginPath();
            };
          }(_, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
        }
        endSMaskMode() {
          if (!this.inSMaskMode)
            throw new Error("endSMaskMode called while not in smask mode");
          this.ctx._removeMirroring(), M(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
        }
        compose(S) {
          if (!this.current.activeSMask)
            return;
          S ? (S[0] = Math.floor(S[0]), S[1] = Math.floor(S[1]), S[2] = Math.ceil(S[2]), S[3] = Math.ceil(S[3])) : S = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
          const f = this.current.activeSMask;
          A2(this.suspendedCtx, f, this.ctx, S), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
        }
        save() {
          this.inSMaskMode ? (M(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
          const S = this.current;
          this.stateStack.push(S), this.current = S.clone();
        }
        restore() {
          this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), M(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
        }
        transform(S, f, P, g, _, U) {
          this.ctx.transform(S, f, P, g, _, U), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
        }
        constructPath(S, f, P) {
          const g = this.ctx, _ = this.current;
          let U, N, G = _.x, V = _.y;
          const W = (0, a2.getCurrentTransform)(g), X = W[0] === 0 && W[3] === 0 || W[1] === 0 && W[2] === 0, K = X ? P.slice(0) : null;
          for (let H = 0, Z = 0, dt = S.length; H < dt; H++)
            switch (0 | S[H]) {
              case e2.OPS.rectangle:
                G = f[Z++], V = f[Z++];
                const lt = f[Z++], E = f[Z++], R = G + lt, j = V + E;
                g.moveTo(G, V), lt === 0 || E === 0 ? g.lineTo(R, j) : (g.lineTo(R, V), g.lineTo(R, j), g.lineTo(G, j)), X || _.updateRectMinMax(W, [G, V, R, j]), g.closePath();
                break;
              case e2.OPS.moveTo:
                G = f[Z++], V = f[Z++], g.moveTo(G, V), X || _.updatePathMinMax(W, G, V);
                break;
              case e2.OPS.lineTo:
                G = f[Z++], V = f[Z++], g.lineTo(G, V), X || _.updatePathMinMax(W, G, V);
                break;
              case e2.OPS.curveTo:
                U = G, N = V, G = f[Z + 4], V = f[Z + 5], g.bezierCurveTo(f[Z], f[Z + 1], f[Z + 2], f[Z + 3], G, V), _.updateCurvePathMinMax(W, U, N, f[Z], f[Z + 1], f[Z + 2], f[Z + 3], G, V, K), Z += 6;
                break;
              case e2.OPS.curveTo2:
                U = G, N = V, g.bezierCurveTo(G, V, f[Z], f[Z + 1], f[Z + 2], f[Z + 3]), _.updateCurvePathMinMax(W, U, N, G, V, f[Z], f[Z + 1], f[Z + 2], f[Z + 3], K), G = f[Z + 2], V = f[Z + 3], Z += 4;
                break;
              case e2.OPS.curveTo3:
                U = G, N = V, G = f[Z + 2], V = f[Z + 3], g.bezierCurveTo(f[Z], f[Z + 1], G, V, G, V), _.updateCurvePathMinMax(W, U, N, f[Z], f[Z + 1], G, V, G, V, K), Z += 4;
                break;
              case e2.OPS.closePath:
                g.closePath();
            }
          X && _.updateScalingPathMinMax(W, K), _.setCurrentPoint(G, V);
        }
        closePath() {
          this.ctx.closePath();
        }
        stroke() {
          let S = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
          const f = this.ctx, P = this.current.strokeColor;
          f.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof P == "object" && P != null && P.getPattern ? (f.save(), f.strokeStyle = P.getPattern(f, this, (0, a2.getCurrentTransformInverse)(f), y.PathType.STROKE), this.rescaleAndStroke(false), f.restore()) : this.rescaleAndStroke(true)), S && this.consumePath(this.current.getClippedPathBoundingBox()), f.globalAlpha = this.current.fillAlpha;
        }
        closeStroke() {
          this.closePath(), this.stroke();
        }
        fill() {
          let S = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
          const f = this.ctx, P = this.current.fillColor;
          let g = false;
          this.current.patternFill && (f.save(), f.fillStyle = P.getPattern(f, this, (0, a2.getCurrentTransformInverse)(f), y.PathType.FILL), g = true);
          const _ = this.current.getClippedPathBoundingBox();
          this.contentVisible && _ !== null && (this.pendingEOFill ? (f.fill("evenodd"), this.pendingEOFill = false) : f.fill()), g && f.restore(), S && this.consumePath(_);
        }
        eoFill() {
          this.pendingEOFill = true, this.fill();
        }
        fillStroke() {
          this.fill(false), this.stroke(false), this.consumePath();
        }
        eoFillStroke() {
          this.pendingEOFill = true, this.fillStroke();
        }
        closeFillStroke() {
          this.closePath(), this.fillStroke();
        }
        closeEOFillStroke() {
          this.pendingEOFill = true, this.closePath(), this.fillStroke();
        }
        endPath() {
          this.consumePath();
        }
        clip() {
          this.pendingClip = u;
        }
        eoClip() {
          this.pendingClip = C;
        }
        beginText() {
          this.current.textMatrix = e2.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
        }
        endText() {
          const S = this.pendingTextPaths, f = this.ctx;
          if (S !== void 0) {
            f.save(), f.beginPath();
            for (const P of S)
              f.setTransform(...P.transform), f.translate(P.x, P.y), P.addToPath(f, P.fontSize);
            f.restore(), f.clip(), f.beginPath(), delete this.pendingTextPaths;
          } else
            f.beginPath();
        }
        setCharSpacing(S) {
          this.current.charSpacing = S;
        }
        setWordSpacing(S) {
          this.current.wordSpacing = S;
        }
        setHScale(S) {
          this.current.textHScale = S / 100;
        }
        setLeading(S) {
          this.current.leading = -S;
        }
        setFont(S, f) {
          var P;
          const g = this.commonObjs.get(S), _ = this.current;
          if (!g)
            throw new Error(`Can't find font for ${S}`);
          if (_.fontMatrix = g.fontMatrix || e2.FONT_IDENTITY_MATRIX, _.fontMatrix[0] !== 0 && _.fontMatrix[3] !== 0 || (0, e2.warn)("Invalid font matrix for font " + S), f < 0 ? (f = -f, _.fontDirection = -1) : _.fontDirection = 1, this.current.font = g, this.current.fontSize = f, g.isType3Font)
            return;
          const U = g.loadedName || "sans-serif", N = ((P = g.systemFontInfo) === null || P === void 0 ? void 0 : P.css) || `"${U}", ${g.fallbackName}`;
          let G = "normal";
          g.black ? G = "900" : g.bold && (G = "bold");
          const V = g.italic ? "italic" : "normal";
          let W = f;
          f < 16 ? W = 16 : f > 100 && (W = 100), this.current.fontSizeScale = f / W, this.ctx.font = `${V} ${G} ${W}px ${N}`;
        }
        setTextRenderingMode(S) {
          this.current.textRenderingMode = S;
        }
        setTextRise(S) {
          this.current.textRise = S;
        }
        moveText(S, f) {
          this.current.x = this.current.lineX += S, this.current.y = this.current.lineY += f;
        }
        setLeadingMoveText(S, f) {
          this.setLeading(-f), this.moveText(S, f);
        }
        setTextMatrix(S, f, P, g, _, U) {
          this.current.textMatrix = [S, f, P, g, _, U], this.current.textMatrixScale = Math.hypot(S, f), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
        }
        nextLine() {
          this.moveText(0, this.current.leading);
        }
        paintChar(S, f, P, g) {
          const _ = this.ctx, U = this.current, N = U.font, G = U.textRenderingMode, V = U.fontSize / U.fontSizeScale, W = G & e2.TextRenderingMode.FILL_STROKE_MASK, X = !!(G & e2.TextRenderingMode.ADD_TO_PATH_FLAG), K = U.patternFill && !N.missingFile;
          let H;
          (N.disableFontFace || X || K) && (H = N.getPathGenerator(this.commonObjs, S)), N.disableFontFace || K ? (_.save(), _.translate(f, P), _.beginPath(), H(_, V), g && _.setTransform(...g), W !== e2.TextRenderingMode.FILL && W !== e2.TextRenderingMode.FILL_STROKE || _.fill(), W !== e2.TextRenderingMode.STROKE && W !== e2.TextRenderingMode.FILL_STROKE || _.stroke(), _.restore()) : (W !== e2.TextRenderingMode.FILL && W !== e2.TextRenderingMode.FILL_STROKE || _.fillText(S, f, P), W !== e2.TextRenderingMode.STROKE && W !== e2.TextRenderingMode.FILL_STROKE || _.strokeText(S, f, P)), X && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({ transform: (0, a2.getCurrentTransform)(_), x: f, y: P, fontSize: V, addToPath: H });
        }
        get isFontSubpixelAAEnabled() {
          const { context: S } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
          S.scale(1.5, 1), S.fillText("I", 0, 10);
          const f = S.getImageData(0, 0, 10, 10).data;
          let P = false;
          for (let g = 3; g < f.length; g += 4)
            if (f[g] > 0 && f[g] < 255) {
              P = true;
              break;
            }
          return (0, e2.shadow)(this, "isFontSubpixelAAEnabled", P);
        }
        showText(S) {
          const f = this.current, P = f.font;
          if (P.isType3Font)
            return this.showType3Text(S);
          const g = f.fontSize;
          if (g === 0)
            return;
          const _ = this.ctx, U = f.fontSizeScale, N = f.charSpacing, G = f.wordSpacing, V = f.fontDirection, W = f.textHScale * V, X = S.length, K = P.vertical, H = K ? 1 : -1, Z = P.defaultVMetrics, dt = g * f.fontMatrix[0], lt = f.textRenderingMode === e2.TextRenderingMode.FILL && !P.disableFontFace && !f.patternFill;
          _.save(), _.transform(...f.textMatrix), _.translate(f.x, f.y + f.textRise), V > 0 ? _.scale(W, -1) : _.scale(W, 1);
          let E;
          if (f.patternFill) {
            _.save();
            const tt = f.fillColor.getPattern(_, this, (0, a2.getCurrentTransformInverse)(_), y.PathType.FILL);
            E = (0, a2.getCurrentTransform)(_), _.restore(), _.fillStyle = tt;
          }
          let R = f.lineWidth;
          const j = f.textMatrixScale;
          if (j === 0 || R === 0) {
            const tt = f.textRenderingMode & e2.TextRenderingMode.FILL_STROKE_MASK;
            tt !== e2.TextRenderingMode.STROKE && tt !== e2.TextRenderingMode.FILL_STROKE || (R = this.getSinglePixelWidth());
          } else
            R /= j;
          if (U !== 1 && (_.scale(U, U), R /= U), _.lineWidth = R, P.isInvalidPDFjsFont) {
            const tt = [];
            let rt = 0;
            for (const it of S)
              tt.push(it.unicode), rt += it.width;
            _.fillText(tt.join(""), 0, 0), f.x += rt * dt * W, _.restore(), this.compose();
            return;
          }
          let B, Y = 0;
          for (B = 0; B < X; ++B) {
            const tt = S[B];
            if (typeof tt == "number") {
              Y += H * tt * g / 1e3;
              continue;
            }
            let rt = false;
            const it = (tt.isSpace ? G : 0) + N, At = tt.fontChar, ct = tt.accent;
            let vt, ht, mt, yt = tt.width;
            if (K) {
              const _t = tt.vmetric || Z, Ct = -(tt.vmetric ? _t[1] : 0.5 * yt) * dt, Q = _t[2] * dt;
              yt = _t ? -_t[0] : yt, vt = Ct / U, ht = (Y + Q) / U;
            } else
              vt = Y / U, ht = 0;
            if (P.remeasure && yt > 0) {
              const _t = 1e3 * _.measureText(At).width / g * U;
              if (yt < _t && this.isFontSubpixelAAEnabled) {
                const Ct = yt / _t;
                rt = true, _.save(), _.scale(Ct, 1), vt /= Ct;
              } else
                yt !== _t && (vt += (yt - _t) / 2e3 * g / U);
            }
            if (this.contentVisible && (tt.isInFont || P.missingFile)) {
              if (lt && !ct)
                _.fillText(At, vt, ht);
              else if (this.paintChar(At, vt, ht, E), ct) {
                const _t = vt + g * ct.offset.x / U, Ct = ht - g * ct.offset.y / U;
                this.paintChar(ct.fontChar, _t, Ct, E);
              }
            }
            mt = K ? yt * dt - it * V : yt * dt + it * V, Y += mt, rt && _.restore();
          }
          K ? f.y -= Y : f.x += Y * W, _.restore(), this.compose();
        }
        showType3Text(S) {
          const f = this.ctx, P = this.current, g = P.font, _ = P.fontSize, U = P.fontDirection, N = g.vertical ? 1 : -1, G = P.charSpacing, V = P.wordSpacing, W = P.textHScale * U, X = P.fontMatrix || e2.FONT_IDENTITY_MATRIX, K = S.length;
          let H, Z, dt, lt;
          if (P.textRenderingMode !== e2.TextRenderingMode.INVISIBLE && _ !== 0) {
            for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, f.save(), f.transform(...P.textMatrix), f.translate(P.x, P.y), f.scale(W, U), H = 0; H < K; ++H) {
              if (Z = S[H], typeof Z == "number") {
                lt = N * Z * _ / 1e3, this.ctx.translate(lt, 0), P.x += lt * W;
                continue;
              }
              const E = (Z.isSpace ? V : 0) + G, R = g.charProcOperatorList[Z.operatorListId];
              if (!R) {
                (0, e2.warn)(`Type3 character "${Z.operatorListId}" is not available.`);
                continue;
              }
              this.contentVisible && (this.processingType3 = Z, this.save(), f.scale(_, _), f.transform(...X), this.executeOperatorList(R), this.restore()), dt = e2.Util.applyTransform([Z.width, 0], X)[0] * _ + E, f.translate(dt, 0), P.x += dt * W;
            }
            f.restore(), this.processingType3 = null;
          }
        }
        setCharWidth(S, f) {
        }
        setCharWidthAndBounds(S, f, P, g, _, U) {
          this.ctx.rect(P, g, _ - P, U - g), this.ctx.clip(), this.endPath();
        }
        getColorN_Pattern(S) {
          let f;
          if (S[0] === "TilingPattern") {
            const P = S[1], g = this.baseTransform || (0, a2.getCurrentTransform)(this.ctx), _ = { createCanvasGraphics: (U) => new J(U, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }) };
            f = new y.TilingPattern(S, P, this.ctx, _, g);
          } else
            f = this._getPattern(S[1], S[2]);
          return f;
        }
        setStrokeColorN() {
          this.current.strokeColor = this.getColorN_Pattern(arguments);
        }
        setFillColorN() {
          this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = true;
        }
        setStrokeRGBColor(S, f, P) {
          const g = e2.Util.makeHexColor(S, f, P);
          this.ctx.strokeStyle = g, this.current.strokeColor = g;
        }
        setFillRGBColor(S, f, P) {
          const g = e2.Util.makeHexColor(S, f, P);
          this.ctx.fillStyle = g, this.current.fillColor = g, this.current.patternFill = false;
        }
        _getPattern(S) {
          let f, P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          return this.cachedPatterns.has(S) ? f = this.cachedPatterns.get(S) : (f = (0, y.getShadingPattern)(this.getObject(S)), this.cachedPatterns.set(S, f)), P && (f.matrix = P), f;
        }
        shadingFill(S) {
          if (!this.contentVisible)
            return;
          const f = this.ctx;
          this.save();
          const P = this._getPattern(S);
          f.fillStyle = P.getPattern(f, this, (0, a2.getCurrentTransformInverse)(f), y.PathType.SHADING);
          const g = (0, a2.getCurrentTransformInverse)(f);
          if (g) {
            const _ = f.canvas, U = _.width, N = _.height, G = e2.Util.applyTransform([0, 0], g), V = e2.Util.applyTransform([0, N], g), W = e2.Util.applyTransform([U, 0], g), X = e2.Util.applyTransform([U, N], g), K = Math.min(G[0], V[0], W[0], X[0]), H = Math.min(G[1], V[1], W[1], X[1]), Z = Math.max(G[0], V[0], W[0], X[0]), dt = Math.max(G[1], V[1], W[1], X[1]);
            this.ctx.fillRect(K, H, Z - K, dt - H);
          } else
            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
          this.compose(this.current.getClippedPathBoundingBox()), this.restore();
        }
        beginInlineImage() {
          (0, e2.unreachable)("Should not call beginInlineImage");
        }
        beginImageData() {
          (0, e2.unreachable)("Should not call beginImageData");
        }
        paintFormXObjectBegin(S, f) {
          if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(S) && S.length === 6 && this.transform(...S), this.baseTransform = (0, a2.getCurrentTransform)(this.ctx), f)) {
            const P = f[2] - f[0], g = f[3] - f[1];
            this.ctx.rect(f[0], f[1], P, g), this.current.updateRectMinMax((0, a2.getCurrentTransform)(this.ctx), f), this.clip(), this.endPath();
          }
        }
        paintFormXObjectEnd() {
          this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
        }
        beginGroup(S) {
          if (!this.contentVisible)
            return;
          this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
          const f = this.ctx;
          S.isolated || (0, e2.info)("TODO: Support non-isolated groups."), S.knockout && (0, e2.warn)("Knockout groups not supported.");
          const P = (0, a2.getCurrentTransform)(f);
          if (S.matrix && f.transform(...S.matrix), !S.bbox)
            throw new Error("Bounding box is required.");
          let g = e2.Util.getAxialAlignedBoundingBox(S.bbox, (0, a2.getCurrentTransform)(f));
          const _ = [0, 0, f.canvas.width, f.canvas.height];
          g = e2.Util.intersect(g, _) || [0, 0, 0, 0];
          const U = Math.floor(g[0]), N = Math.floor(g[1]);
          let G = Math.max(Math.ceil(g[2]) - U, 1), V = Math.max(Math.ceil(g[3]) - N, 1), W = 1, X = 1;
          G > p2 && (W = G / p2, G = p2), V > p2 && (X = V / p2, V = p2), this.current.startNewPathAndClipBox([0, 0, G, V]);
          let K = "groupAt" + this.groupLevel;
          S.smask && (K += "_smask_" + this.smaskCounter++ % 2);
          const H = this.cachedCanvases.getCanvas(K, G, V), Z = H.context;
          Z.scale(1 / W, 1 / X), Z.translate(-U, -N), Z.transform(...P), S.smask ? this.smaskStack.push({ canvas: H.canvas, context: Z, offsetX: U, offsetY: N, scaleX: W, scaleY: X, subtype: S.smask.subtype, backdrop: S.smask.backdrop, transferMap: S.smask.transferMap || null, startTransformInverse: null }) : (f.setTransform(1, 0, 0, 1, 0, 0), f.translate(U, N), f.scale(W, X), f.save()), M(f, Z), this.ctx = Z, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(f), this.groupLevel++;
        }
        endGroup(S) {
          if (!this.contentVisible)
            return;
          this.groupLevel--;
          const f = this.ctx, P = this.groupStack.pop();
          if (this.ctx = P, this.ctx.imageSmoothingEnabled = false, S.smask)
            this.tempSMask = this.smaskStack.pop(), this.restore();
          else {
            this.ctx.restore();
            const g = (0, a2.getCurrentTransform)(this.ctx);
            this.restore(), this.ctx.save(), this.ctx.setTransform(...g);
            const _ = e2.Util.getAxialAlignedBoundingBox([0, 0, f.canvas.width, f.canvas.height], g);
            this.ctx.drawImage(f.canvas, 0, 0), this.ctx.restore(), this.compose(_);
          }
        }
        beginAnnotation(S, f, P, g, _) {
          if (nt(this, o, we).call(this), x2(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(f) && f.length === 4) {
            const U = f[2] - f[0], N = f[3] - f[1];
            if (_ && this.annotationCanvasMap) {
              (P = P.slice())[4] -= f[0], P[5] -= f[1], (f = f.slice())[0] = f[1] = 0, f[2] = U, f[3] = N;
              const [G, V] = e2.Util.singularValueDecompose2dScale((0, a2.getCurrentTransform)(this.ctx)), { viewportScale: W } = this, X = Math.ceil(U * this.outputScaleX * W), K = Math.ceil(N * this.outputScaleY * W);
              this.annotationCanvas = this.canvasFactory.create(X, K);
              const { canvas: H, context: Z } = this.annotationCanvas;
              this.annotationCanvasMap.set(S, H), this.annotationCanvas.savedCtx = this.ctx, this.ctx = Z, this.ctx.save(), this.ctx.setTransform(G, 0, 0, -V, 0, N * V), x2(this.ctx);
            } else
              x2(this.ctx), this.ctx.rect(f[0], f[1], U, N), this.ctx.clip(), this.endPath();
          }
          this.current = new b2(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...P), this.transform(...g);
        }
        endAnnotation() {
          this.annotationCanvas && (this.ctx.restore(), nt(this, z, Ee).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
        }
        paintImageMaskXObject(S) {
          if (!this.contentVisible)
            return;
          const f = S.count;
          (S = this.getObject(S.data, S)).count = f;
          const P = this.ctx, g = this.processingType3;
          if (g && (g.compiled === void 0 && (g.compiled = function(G) {
            const { width: V, height: W } = G;
            if (V > 1e3 || W > 1e3)
              return null;
            const X = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), K = V + 1;
            let H, Z, dt, lt = new Uint8Array(K * (W + 1));
            const E = V + 7 & -8;
            let R = new Uint8Array(E * W), j = 0;
            for (const rt of G.data) {
              let it = 128;
              for (; it > 0; )
                R[j++] = rt & it ? 0 : 255, it >>= 1;
            }
            let B = 0;
            for (j = 0, R[j] !== 0 && (lt[0] = 1, ++B), Z = 1; Z < V; Z++)
              R[j] !== R[j + 1] && (lt[Z] = R[j] ? 2 : 1, ++B), j++;
            for (R[j] !== 0 && (lt[Z] = 2, ++B), H = 1; H < W; H++) {
              j = H * E, dt = H * K, R[j - E] !== R[j] && (lt[dt] = R[j] ? 1 : 8, ++B);
              let rt = (R[j] ? 4 : 0) + (R[j - E] ? 8 : 0);
              for (Z = 1; Z < V; Z++)
                rt = (rt >> 2) + (R[j + 1] ? 4 : 0) + (R[j - E + 1] ? 8 : 0), X[rt] && (lt[dt + Z] = X[rt], ++B), j++;
              if (R[j - E] !== R[j] && (lt[dt + Z] = R[j] ? 2 : 4, ++B), B > 1e3)
                return null;
            }
            for (j = E * (W - 1), dt = H * K, R[j] !== 0 && (lt[dt] = 8, ++B), Z = 1; Z < V; Z++)
              R[j] !== R[j + 1] && (lt[dt + Z] = R[j] ? 4 : 8, ++B), j++;
            if (R[j] !== 0 && (lt[dt + Z] = 4, ++B), B > 1e3)
              return null;
            const Y = new Int32Array([0, K, -1, 0, -K, 0, 0, 0, 1]), tt = new Path2D();
            for (H = 0; B && H <= W; H++) {
              let rt = H * K;
              const it = rt + V;
              for (; rt < it && !lt[rt]; )
                rt++;
              if (rt === it)
                continue;
              tt.moveTo(rt % K, H);
              const At = rt;
              let ct = lt[rt];
              do {
                const vt = Y[ct];
                do
                  rt += vt;
                while (!lt[rt]);
                const ht = lt[rt];
                ht !== 5 && ht !== 10 ? (ct = ht, lt[rt] = 0) : (ct = ht & 51 * ct >> 4, lt[rt] &= ct >> 2 | ct << 2), tt.lineTo(rt % K, rt / K | 0), lt[rt] || --B;
              } while (At !== rt);
              --H;
            }
            return R = null, lt = null, function(rt) {
              rt.save(), rt.scale(1 / V, -1 / W), rt.translate(0, -W), rt.fill(tt), rt.beginPath(), rt.restore();
            };
          }(S)), g.compiled)) {
            g.compiled(P);
            return;
          }
          const _ = this._createMaskCanvas(S), U = _.canvas;
          P.save(), P.setTransform(1, 0, 0, 1, 0, 0), P.drawImage(U, _.offsetX, _.offsetY), P.restore(), this.compose();
        }
        paintImageMaskXObjectRepeat(S, f) {
          let P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, _ = arguments.length > 4 ? arguments[4] : void 0, U = arguments.length > 5 ? arguments[5] : void 0;
          if (!this.contentVisible)
            return;
          S = this.getObject(S.data, S);
          const N = this.ctx;
          N.save();
          const G = (0, a2.getCurrentTransform)(N);
          N.transform(f, P, g, _, 0, 0);
          const V = this._createMaskCanvas(S);
          N.setTransform(1, 0, 0, 1, V.offsetX - G[4], V.offsetY - G[5]);
          for (let W = 0, X = U.length; W < X; W += 2) {
            const K = e2.Util.transform(G, [f, P, g, _, U[W], U[W + 1]]), [H, Z] = e2.Util.applyTransform([0, 0], K);
            N.drawImage(V.canvas, H, Z);
          }
          N.restore(), this.compose();
        }
        paintImageMaskXObjectGroup(S) {
          if (!this.contentVisible)
            return;
          const f = this.ctx, P = this.current.fillColor, g = this.current.patternFill;
          for (const _ of S) {
            const { data: U, width: N, height: G, transform: V } = _, W = this.cachedCanvases.getCanvas("maskCanvas", N, G), X = W.context;
            X.save(), m2(X, this.getObject(U, _)), X.globalCompositeOperation = "source-in", X.fillStyle = g ? P.getPattern(X, this, (0, a2.getCurrentTransformInverse)(f), y.PathType.FILL) : P, X.fillRect(0, 0, N, G), X.restore(), f.save(), f.transform(...V), f.scale(1, -1), c2(f, W.canvas, 0, 0, N, G, 0, -1, 1, 1), f.restore();
          }
          this.compose();
        }
        paintImageXObject(S) {
          if (!this.contentVisible)
            return;
          const f = this.getObject(S);
          f ? this.paintInlineImageXObject(f) : (0, e2.warn)("Dependent image isn't ready yet");
        }
        paintImageXObjectRepeat(S, f, P, g) {
          if (!this.contentVisible)
            return;
          const _ = this.getObject(S);
          if (!_) {
            (0, e2.warn)("Dependent image isn't ready yet");
            return;
          }
          const U = _.width, N = _.height, G = [];
          for (let V = 0, W = g.length; V < W; V += 2)
            G.push({ transform: [f, 0, 0, P, g[V], g[V + 1]], x: 0, y: 0, w: U, h: N });
          this.paintInlineImageXObjectGroup(_, G);
        }
        applyTransferMapsToCanvas(S) {
          return this.current.transferMaps !== "none" && (S.filter = this.current.transferMaps, S.drawImage(S.canvas, 0, 0), S.filter = "none"), S.canvas;
        }
        applyTransferMapsToBitmap(S) {
          if (this.current.transferMaps === "none")
            return S.bitmap;
          const { bitmap: f, width: P, height: g } = S, _ = this.cachedCanvases.getCanvas("inlineImage", P, g), U = _.context;
          return U.filter = this.current.transferMaps, U.drawImage(f, 0, 0), U.filter = "none", _.canvas;
        }
        paintInlineImageXObject(S) {
          if (!this.contentVisible)
            return;
          const f = S.width, P = S.height, g = this.ctx;
          this.save(), O.isNodeJS || (g.filter = "none"), g.scale(1 / f, -1 / P);
          let _;
          if (S.bitmap)
            _ = this.applyTransferMapsToBitmap(S);
          else if (typeof HTMLElement == "function" && S instanceof HTMLElement || !S.data)
            _ = S;
          else {
            const N = this.cachedCanvases.getCanvas("inlineImage", f, P).context;
            L2(N, S), _ = this.applyTransferMapsToCanvas(N);
          }
          const U = this._scaleImage(_, (0, a2.getCurrentTransformInverse)(g));
          g.imageSmoothingEnabled = n2((0, a2.getCurrentTransform)(g), S.interpolate), c2(g, U.img, 0, 0, U.paintWidth, U.paintHeight, 0, -P, f, P), this.compose(), this.restore();
        }
        paintInlineImageXObjectGroup(S, f) {
          if (!this.contentVisible)
            return;
          const P = this.ctx;
          let g;
          if (S.bitmap)
            g = S.bitmap;
          else {
            const _ = S.width, U = S.height, N = this.cachedCanvases.getCanvas("inlineImage", _, U).context;
            L2(N, S), g = this.applyTransferMapsToCanvas(N);
          }
          for (const _ of f)
            P.save(), P.transform(..._.transform), P.scale(1, -1), c2(P, g, _.x, _.y, _.w, _.h, 0, -1, 1, 1), P.restore();
          this.compose();
        }
        paintSolidColorImageMask() {
          this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
        }
        markPoint(S) {
        }
        markPointProps(S, f) {
        }
        beginMarkedContent(S) {
          this.markedContentStack.push({ visible: true });
        }
        beginMarkedContentProps(S, f) {
          S === "OC" ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(f) }) : this.markedContentStack.push({ visible: true }), this.contentVisible = this.isContentVisible();
        }
        endMarkedContent() {
          this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
        }
        beginCompat() {
        }
        endCompat() {
        }
        consumePath(S) {
          const f = this.current.isEmptyClip();
          this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(S);
          const P = this.ctx;
          this.pendingClip && (f || (this.pendingClip === C ? P.clip("evenodd") : P.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), P.beginPath();
        }
        getSinglePixelWidth() {
          if (!this._cachedGetSinglePixelWidth) {
            const S = (0, a2.getCurrentTransform)(this.ctx);
            if (S[1] === 0 && S[2] === 0)
              this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(S[0]), Math.abs(S[3]));
            else {
              const f = Math.abs(S[0] * S[3] - S[2] * S[1]), P = Math.hypot(S[0], S[2]), g = Math.hypot(S[1], S[3]);
              this._cachedGetSinglePixelWidth = Math.max(P, g) / f;
            }
          }
          return this._cachedGetSinglePixelWidth;
        }
        getScaleForStroking() {
          if (this._cachedScaleForStroking[0] === -1) {
            const { lineWidth: S } = this.current, { a: f, b: P, c: g, d: _ } = this.ctx.getTransform();
            let U, N;
            if (P === 0 && g === 0) {
              const G = Math.abs(f), V = Math.abs(_);
              if (G === V)
                if (S === 0)
                  U = N = 1 / G;
                else {
                  const W = G * S;
                  U = N = W < 1 ? 1 / W : 1;
                }
              else if (S === 0)
                U = 1 / G, N = 1 / V;
              else {
                const W = G * S, X = V * S;
                U = W < 1 ? 1 / W : 1, N = X < 1 ? 1 / X : 1;
              }
            } else {
              const G = Math.abs(f * _ - P * g), V = Math.hypot(f, P), W = Math.hypot(g, _);
              if (S === 0)
                U = W / G, N = V / G;
              else {
                const X = S * G;
                U = W > X ? W / X : 1, N = V > X ? V / X : 1;
              }
            }
            this._cachedScaleForStroking[0] = U, this._cachedScaleForStroking[1] = N;
          }
          return this._cachedScaleForStroking;
        }
        rescaleAndStroke(S) {
          const { ctx: f } = this, { lineWidth: P } = this.current, [g, _] = this.getScaleForStroking();
          if (f.lineWidth = P || 1, g === 1 && _ === 1) {
            f.stroke();
            return;
          }
          const U = f.getLineDash();
          if (S && f.save(), f.scale(g, _), U.length > 0) {
            const N = Math.max(g, _);
            f.setLineDash(U.map((G) => G / N)), f.lineDashOffset /= N;
          }
          f.stroke(), S && f.restore();
        }
        isContentVisible() {
          for (let S = this.markedContentStack.length - 1; S >= 0; S--)
            if (!this.markedContentStack[S].visible)
              return false;
          return true;
        }
      };
      let D = J;
      o = /* @__PURE__ */ new WeakSet(), we = function() {
        for (; this.stateStack.length || this.inSMaskMode; )
          this.restore();
        this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
      }, z = /* @__PURE__ */ new WeakSet(), Ee = function() {
        if (this.pageColors) {
          const S = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
          if (S !== "none") {
            const f = this.ctx.filter;
            this.ctx.filter = S, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = f;
          }
        }
      }, d2.CanvasGraphics = D;
      for (const $ in e2.OPS)
        D.prototype[$] !== void 0 && (D.prototype[e2.OPS[$]] = D.prototype[$]);
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.TilingPattern = d2.PathType = void 0, d2.getShadingPattern = function(v) {
        switch (v[0]) {
          case "RadialAxial":
            return new p2(v);
          case "Mesh":
            return new c2(v);
          case "Dummy":
            return new b2();
        }
        throw new Error(`Unknown IR type: ${v[0]}`);
      };
      var e2 = t2(1), a2 = t2(142);
      const y = { FILL: "Fill", STROKE: "Stroke", SHADING: "Shading" };
      d2.PathType = y;
      function w2(I2, v) {
        if (!v)
          return;
        const i2 = v[2] - v[0], A2 = v[3] - v[1], n2 = new Path2D();
        n2.rect(v[0], v[1], i2, A2), I2.clip(n2);
      }
      class O {
        constructor() {
          this.constructor === O && (0, e2.unreachable)("Cannot initialize BaseShadingPattern.");
        }
        getPattern() {
          (0, e2.unreachable)("Abstract method `getPattern` called.");
        }
      }
      class p2 extends O {
        constructor(v) {
          super(), this._type = v[1], this._bbox = v[2], this._colorStops = v[3], this._p0 = v[4], this._p1 = v[5], this._r0 = v[6], this._r1 = v[7], this.matrix = null;
        }
        _createGradient(v) {
          let i2;
          this._type === "axial" ? i2 = v.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (i2 = v.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
          for (const A2 of this._colorStops)
            i2.addColorStop(A2[0], A2[1]);
          return i2;
        }
        getPattern(v, i2, A2, n2) {
          let s;
          if (n2 === y.STROKE || n2 === y.FILL) {
            const r = i2.current.getClippedPathBoundingBox(n2, (0, a2.getCurrentTransform)(v)) || [0, 0, 0, 0], u = Math.ceil(r[2] - r[0]) || 1, C = Math.ceil(r[3] - r[1]) || 1, D = i2.cachedCanvases.getCanvas("pattern", u, C, true), o = D.context;
            o.clearRect(0, 0, o.canvas.width, o.canvas.height), o.beginPath(), o.rect(0, 0, o.canvas.width, o.canvas.height), o.translate(-r[0], -r[1]), A2 = e2.Util.transform(A2, [1, 0, 0, 1, r[0], r[1]]), o.transform(...i2.baseTransform), this.matrix && o.transform(...this.matrix), w2(o, this._bbox), o.fillStyle = this._createGradient(o), o.fill(), s = v.createPattern(D.canvas, "no-repeat");
            const F = new DOMMatrix(A2);
            s.setTransform(F);
          } else
            w2(v, this._bbox), s = this._createGradient(v);
          return s;
        }
      }
      function h2(I2, v, i2, A2, n2, s, r, u) {
        const C = v.coords, D = v.colors, o = I2.data, F = 4 * I2.width;
        let z;
        C[i2 + 1] > C[A2 + 1] && (z = i2, i2 = A2, A2 = z, z = s, s = r, r = z), C[A2 + 1] > C[n2 + 1] && (z = A2, A2 = n2, n2 = z, z = r, r = u, u = z), C[i2 + 1] > C[A2 + 1] && (z = i2, i2 = A2, A2 = z, z = s, s = r, r = z);
        const q = (C[i2] + v.offsetX) * v.scaleX, J = (C[i2 + 1] + v.offsetY) * v.scaleY, $ = (C[A2] + v.offsetX) * v.scaleX, S = (C[A2 + 1] + v.offsetY) * v.scaleY, f = (C[n2] + v.offsetX) * v.scaleX, P = (C[n2 + 1] + v.offsetY) * v.scaleY;
        if (J >= P)
          return;
        const g = D[s], _ = D[s + 1], U = D[s + 2], N = D[r], G = D[r + 1], V = D[r + 2], W = D[u], X = D[u + 1], K = D[u + 2], H = Math.round(J), Z = Math.round(P);
        let dt, lt, E, R, j, B, Y, tt;
        for (let rt = H; rt <= Z; rt++) {
          if (rt < S) {
            let ht;
            ht = rt < J ? 0 : (J - rt) / (J - S), dt = q - (q - $) * ht, lt = g - (g - N) * ht, E = _ - (_ - G) * ht, R = U - (U - V) * ht;
          } else {
            let ht;
            ht = rt > P ? 1 : S === P ? 0 : (S - rt) / (S - P), dt = $ - ($ - f) * ht, lt = N - (N - W) * ht, E = G - (G - X) * ht, R = V - (V - K) * ht;
          }
          let it;
          it = rt < J ? 0 : rt > P ? 1 : (J - rt) / (J - P), j = q - (q - f) * it, B = g - (g - W) * it, Y = _ - (_ - X) * it, tt = U - (U - K) * it;
          const At = Math.round(Math.min(dt, j)), ct = Math.round(Math.max(dt, j));
          let vt = F * rt + 4 * At;
          for (let ht = At; ht <= ct; ht++)
            it = (dt - ht) / (dt - j), it < 0 ? it = 0 : it > 1 && (it = 1), o[vt++] = lt - (lt - B) * it | 0, o[vt++] = E - (E - Y) * it | 0, o[vt++] = R - (R - tt) * it | 0, o[vt++] = 255;
        }
      }
      function l2(I2, v, i2) {
        const A2 = v.coords, n2 = v.colors;
        let s, r;
        switch (v.type) {
          case "lattice":
            const u = v.verticesPerRow, C = Math.floor(A2.length / u) - 1, D = u - 1;
            for (s = 0; s < C; s++) {
              let o = s * u;
              for (let F = 0; F < D; F++, o++)
                h2(I2, i2, A2[o], A2[o + 1], A2[o + u], n2[o], n2[o + 1], n2[o + u]), h2(I2, i2, A2[o + u + 1], A2[o + 1], A2[o + u], n2[o + u + 1], n2[o + 1], n2[o + u]);
            }
            break;
          case "triangles":
            for (s = 0, r = A2.length; s < r; s += 3)
              h2(I2, i2, A2[s], A2[s + 1], A2[s + 2], n2[s], n2[s + 1], n2[s + 2]);
            break;
          default:
            throw new Error("illegal figure");
        }
      }
      class c2 extends O {
        constructor(v) {
          super(), this._coords = v[2], this._colors = v[3], this._figures = v[4], this._bounds = v[5], this._bbox = v[7], this._background = v[8], this.matrix = null;
        }
        _createMeshCanvas(v, i2, A2) {
          const n2 = Math.floor(this._bounds[0]), s = Math.floor(this._bounds[1]), r = Math.ceil(this._bounds[2]) - n2, u = Math.ceil(this._bounds[3]) - s, C = Math.min(Math.ceil(Math.abs(r * v[0] * 1.1)), 3e3), D = Math.min(Math.ceil(Math.abs(u * v[1] * 1.1)), 3e3), o = r / C, F = u / D, z = { coords: this._coords, colors: this._colors, offsetX: -n2, offsetY: -s, scaleX: 1 / o, scaleY: 1 / F }, q = C + 4, J = D + 4, $ = A2.getCanvas("mesh", q, J, false), S = $.context, f = S.createImageData(C, D);
          if (i2) {
            const P = f.data;
            for (let g = 0, _ = P.length; g < _; g += 4)
              P[g] = i2[0], P[g + 1] = i2[1], P[g + 2] = i2[2], P[g + 3] = 255;
          }
          for (const P of this._figures)
            l2(f, P, z);
          return S.putImageData(f, 2, 2), { canvas: $.canvas, offsetX: n2 - 2 * o, offsetY: s - 2 * F, scaleX: o, scaleY: F };
        }
        getPattern(v, i2, A2, n2) {
          w2(v, this._bbox);
          let s;
          if (n2 === y.SHADING)
            s = e2.Util.singularValueDecompose2dScale((0, a2.getCurrentTransform)(v));
          else if (s = e2.Util.singularValueDecompose2dScale(i2.baseTransform), this.matrix) {
            const u = e2.Util.singularValueDecompose2dScale(this.matrix);
            s = [s[0] * u[0], s[1] * u[1]];
          }
          const r = this._createMeshCanvas(s, n2 === y.SHADING ? null : this._background, i2.cachedCanvases);
          return n2 !== y.SHADING && (v.setTransform(...i2.baseTransform), this.matrix && v.transform(...this.matrix)), v.translate(r.offsetX, r.offsetY), v.scale(r.scaleX, r.scaleY), v.createPattern(r.canvas, "no-repeat");
        }
      }
      class b2 extends O {
        getPattern() {
          return "hotpink";
        }
      }
      const L2 = 1, m2 = 2, x2 = class {
        constructor(v, i2, A2, n2, s) {
          this.operatorList = v[2], this.matrix = v[3] || [1, 0, 0, 1, 0, 0], this.bbox = v[4], this.xstep = v[5], this.ystep = v[6], this.paintType = v[7], this.tilingType = v[8], this.color = i2, this.ctx = A2, this.canvasGraphicsFactory = n2, this.baseTransform = s;
        }
        createPatternCanvas(v) {
          const i2 = this.operatorList, A2 = this.bbox, n2 = this.xstep, s = this.ystep, r = this.paintType, u = this.tilingType, C = this.color, D = this.canvasGraphicsFactory;
          (0, e2.info)("TilingType: " + u);
          const o = A2[0], F = A2[1], z = A2[2], q = A2[3], J = e2.Util.singularValueDecompose2dScale(this.matrix), $ = e2.Util.singularValueDecompose2dScale(this.baseTransform), S = [J[0] * $[0], J[1] * $[1]], f = this.getSizeAndScale(n2, this.ctx.canvas.width, S[0]), P = this.getSizeAndScale(s, this.ctx.canvas.height, S[1]), g = v.cachedCanvases.getCanvas("pattern", f.size, P.size, true), _ = g.context, U = D.createCanvasGraphics(_);
          U.groupLevel = v.groupLevel, this.setFillAndStrokeStyleToContext(U, r, C);
          let N = o, G = F, V = z, W = q;
          return o < 0 && (N = 0, V += Math.abs(o)), F < 0 && (G = 0, W += Math.abs(F)), _.translate(-f.scale * N, -P.scale * G), U.transform(f.scale, 0, 0, P.scale, 0, 0), _.save(), this.clipBbox(U, N, G, V, W), U.baseTransform = (0, a2.getCurrentTransform)(U.ctx), U.executeOperatorList(i2), U.endDrawing(), { canvas: g.canvas, scaleX: f.scale, scaleY: P.scale, offsetX: N, offsetY: G };
        }
        getSizeAndScale(v, i2, A2) {
          v = Math.abs(v);
          const n2 = Math.max(x2.MAX_PATTERN_SIZE, i2);
          let s = Math.ceil(v * A2);
          return s >= n2 ? s = n2 : A2 = s / v, { scale: A2, size: s };
        }
        clipBbox(v, i2, A2, n2, s) {
          const r = n2 - i2, u = s - A2;
          v.ctx.rect(i2, A2, r, u), v.current.updateRectMinMax((0, a2.getCurrentTransform)(v.ctx), [i2, A2, n2, s]), v.clip(), v.endPath();
        }
        setFillAndStrokeStyleToContext(v, i2, A2) {
          const n2 = v.ctx, s = v.current;
          switch (i2) {
            case L2:
              const r = this.ctx;
              n2.fillStyle = r.fillStyle, n2.strokeStyle = r.strokeStyle, s.fillColor = r.fillStyle, s.strokeColor = r.strokeStyle;
              break;
            case m2:
              const u = e2.Util.makeHexColor(A2[0], A2[1], A2[2]);
              n2.fillStyle = u, n2.strokeStyle = u, s.fillColor = u, s.strokeColor = u;
              break;
            default:
              throw new e2.FormatError(`Unsupported paint type: ${i2}`);
          }
        }
        getPattern(v, i2, A2, n2) {
          let s = A2;
          n2 !== y.SHADING && (s = e2.Util.transform(s, i2.baseTransform), this.matrix && (s = e2.Util.transform(s, this.matrix)));
          const r = this.createPatternCanvas(i2);
          let u = new DOMMatrix(s);
          u = u.translate(r.offsetX, r.offsetY), u = u.scale(1 / r.scaleX, 1 / r.scaleY);
          const C = v.createPattern(r.canvas, "repeat");
          return C.setTransform(u), C;
        }
      };
      let M = x2;
      It(M, "MAX_PATTERN_SIZE", 3e3), d2.TilingPattern = M;
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.convertBlackAndWhiteToRGBA = a2, d2.convertToRGBA = function(w2) {
        switch (w2.kind) {
          case e2.ImageKind.GRAYSCALE_1BPP:
            return a2(w2);
          case e2.ImageKind.RGB_24BPP:
            return function(p2) {
              let { src: h2, srcPos: l2 = 0, dest: c2, destPos: b2 = 0, width: L2, height: m2 } = p2, M = 0;
              const x2 = h2.length >> 2, I2 = new Uint32Array(h2.buffer, l2, x2);
              if (e2.FeatureTest.isLittleEndian) {
                for (; M < x2 - 2; M += 3, b2 += 4) {
                  const v = I2[M], i2 = I2[M + 1], A2 = I2[M + 2];
                  c2[b2] = 4278190080 | v, c2[b2 + 1] = v >>> 24 | i2 << 8 | 4278190080, c2[b2 + 2] = i2 >>> 16 | A2 << 16 | 4278190080, c2[b2 + 3] = A2 >>> 8 | 4278190080;
                }
                for (let v = 4 * M, i2 = h2.length; v < i2; v += 3)
                  c2[b2++] = h2[v] | h2[v + 1] << 8 | h2[v + 2] << 16 | 4278190080;
              } else {
                for (; M < x2 - 2; M += 3, b2 += 4) {
                  const v = I2[M], i2 = I2[M + 1], A2 = I2[M + 2];
                  c2[b2] = 255 | v, c2[b2 + 1] = v << 24 | i2 >>> 8 | 255, c2[b2 + 2] = i2 << 16 | A2 >>> 16 | 255, c2[b2 + 3] = A2 << 8 | 255;
                }
                for (let v = 4 * M, i2 = h2.length; v < i2; v += 3)
                  c2[b2++] = h2[v] << 24 | h2[v + 1] << 16 | h2[v + 2] << 8 | 255;
              }
              return { srcPos: l2, destPos: b2 };
            }(w2);
        }
        return null;
      }, d2.grayToRGBA = function(w2, O) {
        if (e2.FeatureTest.isLittleEndian)
          for (let p2 = 0, h2 = w2.length; p2 < h2; p2++)
            O[p2] = 65793 * w2[p2] | 4278190080;
        else
          for (let p2 = 0, h2 = w2.length; p2 < h2; p2++)
            O[p2] = 16843008 * w2[p2] | 255;
      };
      var e2 = t2(1);
      function a2(y) {
        let { src: w2, srcPos: O = 0, dest: p2, width: h2, height: l2, nonBlackColor: c2 = 4294967295, inverseDecode: b2 = false } = y;
        const L2 = e2.FeatureTest.isLittleEndian ? 4278190080 : 255, [m2, M] = b2 ? [c2, L2] : [L2, c2], x2 = h2 >> 3, I2 = 7 & h2, v = w2.length;
        p2 = new Uint32Array(p2.buffer);
        let i2 = 0;
        for (let A2 = 0; A2 < l2; A2++) {
          for (const s = O + x2; O < s; O++) {
            const r = O < v ? w2[O] : 255;
            p2[i2++] = 128 & r ? M : m2, p2[i2++] = 64 & r ? M : m2, p2[i2++] = 32 & r ? M : m2, p2[i2++] = 16 & r ? M : m2, p2[i2++] = 8 & r ? M : m2, p2[i2++] = 4 & r ? M : m2, p2[i2++] = 2 & r ? M : m2, p2[i2++] = 1 & r ? M : m2;
          }
          if (I2 === 0)
            continue;
          const n2 = O < v ? w2[O++] : 255;
          for (let s = 0; s < I2; s++)
            p2[i2++] = n2 & 1 << 7 - s ? M : m2;
        }
        return { srcPos: O, destPos: i2 };
      }
    }, (k2, d2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.GlobalWorkerOptions = void 0;
      const t2 = /* @__PURE__ */ Object.create(null);
      d2.GlobalWorkerOptions = t2, t2.workerPort = null, t2.workerSrc = "";
    }, (k2, d2, t2) => {
      var M, Ye, I2, Ke, i2, fe, n2;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.MessageHandler = void 0;
      var e2 = t2(1);
      const a2 = 1, y = 2, w2 = 1, O = 2, p2 = 3, h2 = 4, l2 = 5, c2 = 6, b2 = 7, L2 = 8;
      function m2(s) {
        switch (s instanceof Error || typeof s == "object" && s !== null || (0, e2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), s.name) {
          case "AbortException":
            return new e2.AbortException(s.message);
          case "MissingPDFException":
            return new e2.MissingPDFException(s.message);
          case "PasswordException":
            return new e2.PasswordException(s.message, s.code);
          case "UnexpectedResponseException":
            return new e2.UnexpectedResponseException(s.message, s.status);
          case "UnknownErrorException":
            return new e2.UnknownErrorException(s.message, s.details);
          default:
            return new e2.UnknownErrorException(s.message, s.toString());
        }
      }
      d2.MessageHandler = (n2 = class {
        constructor(r, u, C) {
          et(this, M);
          et(this, I2);
          et(this, i2);
          this.sourceName = r, this.targetName = u, this.comObj = C, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (D) => {
            const o = D.data;
            if (o.targetName !== this.sourceName)
              return;
            if (o.stream) {
              nt(this, I2, Ke).call(this, o);
              return;
            }
            if (o.callback) {
              const z = o.callbackId, q = this.callbackCapabilities[z];
              if (!q)
                throw new Error(`Cannot resolve callback ${z}`);
              if (delete this.callbackCapabilities[z], o.callback === a2)
                q.resolve(o.data);
              else {
                if (o.callback !== y)
                  throw new Error("Unexpected callback case");
                q.reject(m2(o.reason));
              }
              return;
            }
            const F = this.actionHandler[o.action];
            if (!F)
              throw new Error(`Unknown action from worker: ${o.action}`);
            if (o.callbackId) {
              const z = this.sourceName, q = o.sourceName;
              new Promise(function(J) {
                J(F(o.data));
              }).then(function(J) {
                C.postMessage({ sourceName: z, targetName: q, callback: a2, callbackId: o.callbackId, data: J });
              }, function(J) {
                C.postMessage({ sourceName: z, targetName: q, callback: y, callbackId: o.callbackId, reason: m2(J) });
              });
            } else
              o.streamId ? nt(this, M, Ye).call(this, o) : F(o.data);
          }, C.addEventListener("message", this._onComObjOnMessage);
        }
        on(r, u) {
          const C = this.actionHandler;
          if (C[r])
            throw new Error(`There is already an actionName called "${r}"`);
          C[r] = u;
        }
        send(r, u, C) {
          this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: r, data: u }, C);
        }
        sendWithPromise(r, u, C) {
          const D = this.callbackId++, o = new e2.PromiseCapability();
          this.callbackCapabilities[D] = o;
          try {
            this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: r, callbackId: D, data: u }, C);
          } catch (F) {
            o.reject(F);
          }
          return o.promise;
        }
        sendWithStream(r, u, C, D) {
          const o = this.streamId++, F = this.sourceName, z = this.targetName, q = this.comObj;
          return new ReadableStream({ start: (J) => {
            const $ = new e2.PromiseCapability();
            return this.streamControllers[o] = { controller: J, startCall: $, pullCall: null, cancelCall: null, isClosed: false }, q.postMessage({ sourceName: F, targetName: z, action: r, streamId: o, data: u, desiredSize: J.desiredSize }, D), $.promise;
          }, pull: (J) => {
            const $ = new e2.PromiseCapability();
            return this.streamControllers[o].pullCall = $, q.postMessage({ sourceName: F, targetName: z, stream: c2, streamId: o, desiredSize: J.desiredSize }), $.promise;
          }, cancel: (J) => {
            (0, e2.assert)(J instanceof Error, "cancel must have a valid reason");
            const $ = new e2.PromiseCapability();
            return this.streamControllers[o].cancelCall = $, this.streamControllers[o].isClosed = true, q.postMessage({ sourceName: F, targetName: z, stream: w2, streamId: o, reason: m2(J) }), $.promise;
          } }, C);
        }
        destroy() {
          this.comObj.removeEventListener("message", this._onComObjOnMessage);
        }
      }, M = /* @__PURE__ */ new WeakSet(), Ye = function(r) {
        const u = r.streamId, C = this.sourceName, D = r.sourceName, o = this.comObj, F = this, z = this.actionHandler[r.action], q = { enqueue(J) {
          let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, S = arguments.length > 2 ? arguments[2] : void 0;
          if (this.isCancelled)
            return;
          const f = this.desiredSize;
          this.desiredSize -= $, f > 0 && this.desiredSize <= 0 && (this.sinkCapability = new e2.PromiseCapability(), this.ready = this.sinkCapability.promise), o.postMessage({ sourceName: C, targetName: D, stream: h2, streamId: u, chunk: J }, S);
        }, close() {
          this.isCancelled || (this.isCancelled = true, o.postMessage({ sourceName: C, targetName: D, stream: p2, streamId: u }), delete F.streamSinks[u]);
        }, error(J) {
          (0, e2.assert)(J instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = true, o.postMessage({ sourceName: C, targetName: D, stream: l2, streamId: u, reason: m2(J) }));
        }, sinkCapability: new e2.PromiseCapability(), onPull: null, onCancel: null, isCancelled: false, desiredSize: r.desiredSize, ready: null };
        q.sinkCapability.resolve(), q.ready = q.sinkCapability.promise, this.streamSinks[u] = q, new Promise(function(J) {
          J(z(r.data, q));
        }).then(function() {
          o.postMessage({ sourceName: C, targetName: D, stream: L2, streamId: u, success: true });
        }, function(J) {
          o.postMessage({ sourceName: C, targetName: D, stream: L2, streamId: u, reason: m2(J) });
        });
      }, I2 = /* @__PURE__ */ new WeakSet(), Ke = function(r) {
        const u = r.streamId, C = this.sourceName, D = r.sourceName, o = this.comObj, F = this.streamControllers[u], z = this.streamSinks[u];
        switch (r.stream) {
          case L2:
            r.success ? F.startCall.resolve() : F.startCall.reject(m2(r.reason));
            break;
          case b2:
            r.success ? F.pullCall.resolve() : F.pullCall.reject(m2(r.reason));
            break;
          case c2:
            if (!z) {
              o.postMessage({ sourceName: C, targetName: D, stream: b2, streamId: u, success: true });
              break;
            }
            z.desiredSize <= 0 && r.desiredSize > 0 && z.sinkCapability.resolve(), z.desiredSize = r.desiredSize, new Promise(function(q) {
              var J;
              q((J = z.onPull) === null || J === void 0 ? void 0 : J.call(z));
            }).then(function() {
              o.postMessage({ sourceName: C, targetName: D, stream: b2, streamId: u, success: true });
            }, function(q) {
              o.postMessage({ sourceName: C, targetName: D, stream: b2, streamId: u, reason: m2(q) });
            });
            break;
          case h2:
            if ((0, e2.assert)(F, "enqueue should have stream controller"), F.isClosed)
              break;
            F.controller.enqueue(r.chunk);
            break;
          case p2:
            if ((0, e2.assert)(F, "close should have stream controller"), F.isClosed)
              break;
            F.isClosed = true, F.controller.close(), nt(this, i2, fe).call(this, F, u);
            break;
          case l2:
            (0, e2.assert)(F, "error should have stream controller"), F.controller.error(m2(r.reason)), nt(this, i2, fe).call(this, F, u);
            break;
          case O:
            r.success ? F.cancelCall.resolve() : F.cancelCall.reject(m2(r.reason)), nt(this, i2, fe).call(this, F, u);
            break;
          case w2:
            if (!z)
              break;
            new Promise(function(q) {
              var J;
              q((J = z.onCancel) === null || J === void 0 ? void 0 : J.call(z, m2(r.reason)));
            }).then(function() {
              o.postMessage({ sourceName: C, targetName: D, stream: O, streamId: u, success: true });
            }, function(q) {
              o.postMessage({ sourceName: C, targetName: D, stream: O, streamId: u, reason: m2(q) });
            }), z.sinkCapability.reject(m2(r.reason)), z.isCancelled = true, delete this.streamSinks[u];
            break;
          default:
            throw new Error("Unexpected stream case");
        }
      }, i2 = /* @__PURE__ */ new WeakSet(), fe = async function(r, u) {
        var C, D, o;
        await Promise.allSettled([(C = r.startCall) === null || C === void 0 ? void 0 : C.promise, (D = r.pullCall) === null || D === void 0 ? void 0 : D.promise, (o = r.cancelCall) === null || o === void 0 ? void 0 : o.promise]), delete this.streamControllers[u];
      }, n2);
    }, (k2, d2, t2) => {
      var a2, y, w2;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.Metadata = void 0;
      var e2 = t2(1);
      d2.Metadata = (w2 = class {
        constructor(p2) {
          et(this, a2, void 0);
          et(this, y, void 0);
          let { parsedData: h2, rawData: l2 } = p2;
          ut(this, a2, h2), ut(this, y, l2);
        }
        getRaw() {
          return T(this, y);
        }
        get(p2) {
          return T(this, a2).get(p2) ?? null;
        }
        getAll() {
          return (0, e2.objectFromMap)(T(this, a2));
        }
        has(p2) {
          return T(this, a2).has(p2);
        }
      }, a2 = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap(), w2);
    }, (k2, d2, t2) => {
      var O, p2, h2, l2, c2, b2, Te, m2;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.OptionalContentConfig = void 0;
      var e2 = t2(1), a2 = t2(144);
      const y = Symbol("INTERNAL");
      class w2 {
        constructor(x2, I2) {
          et(this, O, true);
          this.name = x2, this.intent = I2;
        }
        get visible() {
          return T(this, O);
        }
        _setVisible(x2, I2) {
          x2 !== y && (0, e2.unreachable)("Internal method `_setVisible` called."), ut(this, O, I2);
        }
      }
      O = /* @__PURE__ */ new WeakMap(), d2.OptionalContentConfig = (m2 = class {
        constructor(x2) {
          et(this, b2);
          et(this, p2, null);
          et(this, h2, /* @__PURE__ */ new Map());
          et(this, l2, null);
          et(this, c2, null);
          if (this.name = null, this.creator = null, x2 !== null) {
            this.name = x2.name, this.creator = x2.creator, ut(this, c2, x2.order);
            for (const I2 of x2.groups)
              T(this, h2).set(I2.id, new w2(I2.name, I2.intent));
            if (x2.baseState === "OFF")
              for (const I2 of T(this, h2).values())
                I2._setVisible(y, false);
            for (const I2 of x2.on)
              T(this, h2).get(I2)._setVisible(y, true);
            for (const I2 of x2.off)
              T(this, h2).get(I2)._setVisible(y, false);
            ut(this, l2, this.getHash());
          }
        }
        isVisible(x2) {
          if (T(this, h2).size === 0)
            return true;
          if (!x2)
            return (0, e2.warn)("Optional content group not defined."), true;
          if (x2.type === "OCG")
            return T(this, h2).has(x2.id) ? T(this, h2).get(x2.id).visible : ((0, e2.warn)(`Optional content group not found: ${x2.id}`), true);
          if (x2.type === "OCMD") {
            if (x2.expression)
              return nt(this, b2, Te).call(this, x2.expression);
            if (!x2.policy || x2.policy === "AnyOn") {
              for (const I2 of x2.ids) {
                if (!T(this, h2).has(I2))
                  return (0, e2.warn)(`Optional content group not found: ${I2}`), true;
                if (T(this, h2).get(I2).visible)
                  return true;
              }
              return false;
            }
            if (x2.policy === "AllOn") {
              for (const I2 of x2.ids) {
                if (!T(this, h2).has(I2))
                  return (0, e2.warn)(`Optional content group not found: ${I2}`), true;
                if (!T(this, h2).get(I2).visible)
                  return false;
              }
              return true;
            }
            if (x2.policy === "AnyOff") {
              for (const I2 of x2.ids) {
                if (!T(this, h2).has(I2))
                  return (0, e2.warn)(`Optional content group not found: ${I2}`), true;
                if (!T(this, h2).get(I2).visible)
                  return true;
              }
              return false;
            }
            if (x2.policy === "AllOff") {
              for (const I2 of x2.ids) {
                if (!T(this, h2).has(I2))
                  return (0, e2.warn)(`Optional content group not found: ${I2}`), true;
                if (T(this, h2).get(I2).visible)
                  return false;
              }
              return true;
            }
            return (0, e2.warn)(`Unknown optional content policy ${x2.policy}.`), true;
          }
          return (0, e2.warn)(`Unknown group type ${x2.type}.`), true;
        }
        setVisibility(x2) {
          let I2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
          T(this, h2).has(x2) ? (T(this, h2).get(x2)._setVisible(y, !!I2), ut(this, p2, null)) : (0, e2.warn)(`Optional content group not found: ${x2}`);
        }
        get hasInitialVisibility() {
          return this.getHash() === T(this, l2);
        }
        getOrder() {
          return T(this, h2).size ? T(this, c2) ? T(this, c2).slice() : [...T(this, h2).keys()] : null;
        }
        getGroups() {
          return T(this, h2).size > 0 ? (0, e2.objectFromMap)(T(this, h2)) : null;
        }
        getGroup(x2) {
          return T(this, h2).get(x2) || null;
        }
        getHash() {
          if (T(this, p2) !== null)
            return T(this, p2);
          const x2 = new a2.MurmurHash3_64();
          for (const [I2, v] of T(this, h2))
            x2.update(`${I2}:${v.visible}`);
          return ut(this, p2, x2.hexdigest());
        }
      }, p2 = /* @__PURE__ */ new WeakMap(), h2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), c2 = /* @__PURE__ */ new WeakMap(), b2 = /* @__PURE__ */ new WeakSet(), Te = function(x2) {
        const I2 = x2.length;
        if (I2 < 2)
          return true;
        const v = x2[0];
        for (let i2 = 1; i2 < I2; i2++) {
          const A2 = x2[i2];
          let n2;
          if (Array.isArray(A2))
            n2 = nt(this, b2, Te).call(this, A2);
          else {
            if (!T(this, h2).has(A2))
              return (0, e2.warn)(`Optional content group not found: ${A2}`), true;
            n2 = T(this, h2).get(A2).visible;
          }
          switch (v) {
            case "And":
              if (!n2)
                return false;
              break;
            case "Or":
              if (n2)
                return true;
              break;
            case "Not":
              return !n2;
            default:
              return true;
          }
        }
        return v === "And";
      }, m2);
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.PDFDataTransportStream = void 0;
      var e2 = t2(1), a2 = t2(142);
      d2.PDFDataTransportStream = class {
        constructor(p2, h2) {
          let { length: l2, initialData: c2, progressiveDone: b2 = false, contentDispositionFilename: L2 = null, disableRange: m2 = false, disableStream: M = false } = p2;
          if ((0, e2.assert)(h2, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = b2, this._contentDispositionFilename = L2, (c2 == null ? void 0 : c2.length) > 0) {
            const x2 = c2 instanceof Uint8Array && c2.byteLength === c2.buffer.byteLength ? c2.buffer : new Uint8Array(c2).buffer;
            this._queuedChunks.push(x2);
          }
          this._pdfDataRangeTransport = h2, this._isStreamingSupported = !M, this._isRangeSupported = !m2, this._contentLength = l2, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((x2, I2) => {
            this._onReceiveData({ begin: x2, chunk: I2 });
          }), this._pdfDataRangeTransport.addProgressListener((x2, I2) => {
            this._onProgress({ loaded: x2, total: I2 });
          }), this._pdfDataRangeTransport.addProgressiveReadListener((x2) => {
            this._onReceiveData({ chunk: x2 });
          }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
            this._onProgressiveDone();
          }), this._pdfDataRangeTransport.transportReady();
        }
        _onReceiveData(p2) {
          let { begin: h2, chunk: l2 } = p2;
          const c2 = l2 instanceof Uint8Array && l2.byteLength === l2.buffer.byteLength ? l2.buffer : new Uint8Array(l2).buffer;
          if (h2 === void 0)
            this._fullRequestReader ? this._fullRequestReader._enqueue(c2) : this._queuedChunks.push(c2);
          else {
            const b2 = this._rangeReaders.some(function(L2) {
              return L2._begin !== h2 ? false : (L2._enqueue(c2), true);
            });
            (0, e2.assert)(b2, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
          }
        }
        get _progressiveDataLength() {
          var p2;
          return ((p2 = this._fullRequestReader) === null || p2 === void 0 ? void 0 : p2._loaded) ?? 0;
        }
        _onProgress(p2) {
          if (p2.total === void 0) {
            var h2, l2;
            (h2 = this._rangeReaders[0]) === null || h2 === void 0 || (l2 = h2.onProgress) === null || l2 === void 0 || l2.call(h2, { loaded: p2.loaded });
          } else {
            var c2, b2;
            (c2 = this._fullRequestReader) === null || c2 === void 0 || (b2 = c2.onProgress) === null || b2 === void 0 || b2.call(c2, { loaded: p2.loaded, total: p2.total });
          }
        }
        _onProgressiveDone() {
          var p2;
          (p2 = this._fullRequestReader) === null || p2 === void 0 || p2.progressiveDone(), this._progressiveDone = true;
        }
        _removeRangeReader(p2) {
          const h2 = this._rangeReaders.indexOf(p2);
          h2 >= 0 && this._rangeReaders.splice(h2, 1);
        }
        getFullReader() {
          (0, e2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
          const p2 = this._queuedChunks;
          return this._queuedChunks = null, new y(this, p2, this._progressiveDone, this._contentDispositionFilename);
        }
        getRangeReader(p2, h2) {
          if (h2 <= this._progressiveDataLength)
            return null;
          const l2 = new w2(this, p2, h2);
          return this._pdfDataRangeTransport.requestDataRange(p2, h2), this._rangeReaders.push(l2), l2;
        }
        cancelAllRequests(p2) {
          var h2;
          (h2 = this._fullRequestReader) === null || h2 === void 0 || h2.cancel(p2);
          for (const l2 of this._rangeReaders.slice(0))
            l2.cancel(p2);
          this._pdfDataRangeTransport.abort();
        }
      };
      class y {
        constructor(p2, h2) {
          let l2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], c2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          this._stream = p2, this._done = l2 || false, this._filename = (0, a2.isPdfFile)(c2) ? c2 : null, this._queuedChunks = h2 || [], this._loaded = 0;
          for (const b2 of this._queuedChunks)
            this._loaded += b2.byteLength;
          this._requests = [], this._headersReady = Promise.resolve(), p2._fullRequestReader = this, this.onProgress = null;
        }
        _enqueue(p2) {
          this._done || (this._requests.length > 0 ? this._requests.shift().resolve({ value: p2, done: false }) : this._queuedChunks.push(p2), this._loaded += p2.byteLength);
        }
        get headersReady() {
          return this._headersReady;
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._stream._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._stream._isStreamingSupported;
        }
        get contentLength() {
          return this._stream._contentLength;
        }
        async read() {
          if (this._queuedChunks.length > 0)
            return { value: this._queuedChunks.shift(), done: false };
          if (this._done)
            return { value: void 0, done: true };
          const p2 = new e2.PromiseCapability();
          return this._requests.push(p2), p2.promise;
        }
        cancel(p2) {
          this._done = true;
          for (const h2 of this._requests)
            h2.resolve({ value: void 0, done: true });
          this._requests.length = 0;
        }
        progressiveDone() {
          this._done || (this._done = true);
        }
      }
      class w2 {
        constructor(p2, h2, l2) {
          this._stream = p2, this._begin = h2, this._end = l2, this._queuedChunk = null, this._requests = [], this._done = false, this.onProgress = null;
        }
        _enqueue(p2) {
          if (!this._done) {
            if (this._requests.length === 0)
              this._queuedChunk = p2;
            else {
              this._requests.shift().resolve({ value: p2, done: false });
              for (const h2 of this._requests)
                h2.resolve({ value: void 0, done: true });
              this._requests.length = 0;
            }
            this._done = true, this._stream._removeRangeReader(this);
          }
        }
        get isStreamingSupported() {
          return false;
        }
        async read() {
          if (this._queuedChunk) {
            const h2 = this._queuedChunk;
            return this._queuedChunk = null, { value: h2, done: false };
          }
          if (this._done)
            return { value: void 0, done: true };
          const p2 = new e2.PromiseCapability();
          return this._requests.push(p2), p2.promise;
        }
        cancel(p2) {
          this._done = true;
          for (const h2 of this._requests)
            h2.resolve({ value: void 0, done: true });
          this._requests.length = 0, this._stream._removeRangeReader(this);
        }
      }
    }, (k2, d2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.XfaText = void 0;
      class t2 {
        static textContent(a2) {
          const y = [], w2 = { items: y, styles: /* @__PURE__ */ Object.create(null) };
          return function O(p2) {
            var h2;
            if (!p2)
              return;
            let l2 = null;
            const c2 = p2.name;
            if (c2 === "#text")
              l2 = p2.value;
            else {
              if (!t2.shouldBuildText(c2))
                return;
              p2 != null && (h2 = p2.attributes) !== null && h2 !== void 0 && h2.textContent ? l2 = p2.attributes.textContent : p2.value && (l2 = p2.value);
            }
            if (l2 !== null && y.push({ str: l2 }), p2.children)
              for (const b2 of p2.children)
                O(b2);
          }(a2), w2;
        }
        static shouldBuildText(a2) {
          return !(a2 === "textarea" || a2 === "input" || a2 === "option" || a2 === "select");
        }
      }
      d2.XfaText = t2;
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.NodeStandardFontDataFactory = d2.NodeFilterFactory = d2.NodeCanvasFactory = d2.NodeCMapReaderFactory = void 0;
      var e2 = t2(143);
      const a2 = function(h2) {
        return new Promise((l2, c2) => {
          require$$6.readFile(h2, (b2, L2) => {
            !b2 && L2 ? l2(new Uint8Array(L2)) : c2(new Error(b2));
          });
        });
      };
      class y extends e2.BaseFilterFactory {
      }
      d2.NodeFilterFactory = y;
      class w2 extends e2.BaseCanvasFactory {
        _createCanvas(l2, c2) {
          return require$$6.createCanvas(l2, c2);
        }
      }
      d2.NodeCanvasFactory = w2;
      class O extends e2.BaseCMapReaderFactory {
        _fetchData(l2, c2) {
          return a2(l2).then((b2) => ({ cMapData: b2, compressionType: c2 }));
        }
      }
      d2.NodeCMapReaderFactory = O;
      class p2 extends e2.BaseStandardFontDataFactory {
        _fetchData(l2) {
          return a2(l2);
        }
      }
      d2.NodeStandardFontDataFactory = p2;
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.PDFNodeStream = void 0;
      var e2 = t2(1), a2 = t2(157);
      const y = require$$6, w2 = require$$6, O = require$$6, p2 = require$$6, h2 = /^file:\/\/\/[a-zA-Z]:\//;
      d2.PDFNodeStream = class {
        constructor(v) {
          this.source = v, this.url = function(A2) {
            const n2 = p2.parse(A2);
            return n2.protocol === "file:" || n2.host ? n2 : /^[a-z]:[/\\]/i.test(A2) ? p2.parse(`file:///${A2}`) : (n2.host || (n2.protocol = "file:"), n2);
          }(v.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && v.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
        }
        get _progressiveDataLength() {
          var v;
          return ((v = this._fullRequestReader) === null || v === void 0 ? void 0 : v._loaded) ?? 0;
        }
        getFullReader() {
          return (0, e2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new M(this) : new L2(this), this._fullRequestReader;
        }
        getRangeReader(v, i2) {
          if (i2 <= this._progressiveDataLength)
            return null;
          const A2 = this.isFsUrl ? new x2(this, v, i2) : new m2(this, v, i2);
          return this._rangeRequestReaders.push(A2), A2;
        }
        cancelAllRequests(v) {
          var i2;
          (i2 = this._fullRequestReader) === null || i2 === void 0 || i2.cancel(v);
          for (const A2 of this._rangeRequestReaders.slice(0))
            A2.cancel(v);
        }
      };
      class l2 {
        constructor(v) {
          this._url = v.url, this._done = false, this._storedError = null, this.onProgress = null;
          const i2 = v.source;
          this._contentLength = i2.length, this._loaded = 0, this._filename = null, this._disableRange = i2.disableRange || false, this._rangeChunkSize = i2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = !i2.disableStream, this._isRangeSupported = !i2.disableRange, this._readableStream = null, this._readCapability = new e2.PromiseCapability(), this._headersCapability = new e2.PromiseCapability();
        }
        get headersReady() {
          return this._headersCapability.promise;
        }
        get filename() {
          return this._filename;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        async read() {
          var v;
          if (await this._readCapability.promise, this._done)
            return { value: void 0, done: true };
          if (this._storedError)
            throw this._storedError;
          const i2 = this._readableStream.read();
          return i2 === null ? (this._readCapability = new e2.PromiseCapability(), this.read()) : (this._loaded += i2.length, (v = this.onProgress) === null || v === void 0 || v.call(this, { loaded: this._loaded, total: this._contentLength }), { value: new Uint8Array(i2).buffer, done: false });
        }
        cancel(v) {
          this._readableStream ? this._readableStream.destroy(v) : this._error(v);
        }
        _error(v) {
          this._storedError = v, this._readCapability.resolve();
        }
        _setReadableStream(v) {
          this._readableStream = v, v.on("readable", () => {
            this._readCapability.resolve();
          }), v.on("end", () => {
            v.destroy(), this._done = true, this._readCapability.resolve();
          }), v.on("error", (i2) => {
            this._error(i2);
          }), !this._isStreamingSupported && this._isRangeSupported && this._error(new e2.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
        }
      }
      class c2 {
        constructor(v) {
          this._url = v.url, this._done = false, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new e2.PromiseCapability();
          const i2 = v.source;
          this._isStreamingSupported = !i2.disableStream;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        async read() {
          var v;
          if (await this._readCapability.promise, this._done)
            return { value: void 0, done: true };
          if (this._storedError)
            throw this._storedError;
          const i2 = this._readableStream.read();
          return i2 === null ? (this._readCapability = new e2.PromiseCapability(), this.read()) : (this._loaded += i2.length, (v = this.onProgress) === null || v === void 0 || v.call(this, { loaded: this._loaded }), { value: new Uint8Array(i2).buffer, done: false });
        }
        cancel(v) {
          this._readableStream ? this._readableStream.destroy(v) : this._error(v);
        }
        _error(v) {
          this._storedError = v, this._readCapability.resolve();
        }
        _setReadableStream(v) {
          this._readableStream = v, v.on("readable", () => {
            this._readCapability.resolve();
          }), v.on("end", () => {
            v.destroy(), this._done = true, this._readCapability.resolve();
          }), v.on("error", (i2) => {
            this._error(i2);
          }), this._storedError && this._readableStream.destroy(this._storedError);
        }
      }
      function b2(I2, v) {
        return { protocol: I2.protocol, auth: I2.auth, host: I2.hostname, port: I2.port, path: I2.path, method: "GET", headers: v };
      }
      class L2 extends l2 {
        constructor(v) {
          super(v);
          const i2 = (A2) => {
            if (A2.statusCode === 404) {
              const u = new e2.MissingPDFException(`Missing PDF "${this._url}".`);
              this._storedError = u, this._headersCapability.reject(u);
              return;
            }
            this._headersCapability.resolve(), this._setReadableStream(A2);
            const n2 = (u) => this._readableStream.headers[u.toLowerCase()], { allowRangeRequests: s, suggestedLength: r } = (0, a2.validateRangeRequestCapabilities)({ getResponseHeader: n2, isHttp: v.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
            this._isRangeSupported = s, this._contentLength = r || this._contentLength, this._filename = (0, a2.extractFilenameFromHeader)(n2);
          };
          this._request = null, this._url.protocol === "http:" ? this._request = w2.request(b2(this._url, v.httpHeaders), i2) : this._request = O.request(b2(this._url, v.httpHeaders), i2), this._request.on("error", (A2) => {
            this._storedError = A2, this._headersCapability.reject(A2);
          }), this._request.end();
        }
      }
      class m2 extends c2 {
        constructor(v, i2, A2) {
          super(v), this._httpHeaders = {};
          for (const s in v.httpHeaders) {
            const r = v.httpHeaders[s];
            r !== void 0 && (this._httpHeaders[s] = r);
          }
          this._httpHeaders.Range = `bytes=${i2}-${A2 - 1}`;
          const n2 = (s) => {
            if (s.statusCode !== 404)
              this._setReadableStream(s);
            else {
              const r = new e2.MissingPDFException(`Missing PDF "${this._url}".`);
              this._storedError = r;
            }
          };
          this._request = null, this._url.protocol === "http:" ? this._request = w2.request(b2(this._url, this._httpHeaders), n2) : this._request = O.request(b2(this._url, this._httpHeaders), n2), this._request.on("error", (s) => {
            this._storedError = s;
          }), this._request.end();
        }
      }
      class M extends l2 {
        constructor(v) {
          super(v);
          let i2 = decodeURIComponent(this._url.path);
          h2.test(this._url.href) && (i2 = i2.replace(/^\//, "")), y.lstat(i2, (A2, n2) => {
            A2 ? (A2.code === "ENOENT" && (A2 = new e2.MissingPDFException(`Missing PDF "${i2}".`)), this._storedError = A2, this._headersCapability.reject(A2)) : (this._contentLength = n2.size, this._setReadableStream(y.createReadStream(i2)), this._headersCapability.resolve());
          });
        }
      }
      class x2 extends c2 {
        constructor(v, i2, A2) {
          super(v);
          let n2 = decodeURIComponent(this._url.path);
          h2.test(this._url.href) && (n2 = n2.replace(/^\//, "")), this._setReadableStream(y.createReadStream(n2, { start: i2, end: A2 - 1 }));
        }
      }
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.createResponseStatusError = function(O, p2) {
        return O === 404 || O === 0 && p2.startsWith("file:") ? new e2.MissingPDFException('Missing PDF "' + p2 + '".') : new e2.UnexpectedResponseException(`Unexpected server response (${O}) while retrieving PDF "${p2}".`, O);
      }, d2.extractFilenameFromHeader = function(O) {
        const p2 = O("Content-Disposition");
        if (p2) {
          let h2 = (0, a2.getFilenameFromContentDispositionHeader)(p2);
          if (h2.includes("%"))
            try {
              h2 = decodeURIComponent(h2);
            } catch {
            }
          if ((0, y.isPdfFile)(h2))
            return h2;
        }
        return null;
      }, d2.validateRangeRequestCapabilities = function(O) {
        let { getResponseHeader: p2, isHttp: h2, rangeChunkSize: l2, disableRange: c2 } = O;
        const b2 = { allowRangeRequests: false, suggestedLength: void 0 }, L2 = parseInt(p2("Content-Length"), 10);
        return !Number.isInteger(L2) || (b2.suggestedLength = L2, L2 <= 2 * l2) || c2 || !h2 || p2("Accept-Ranges") !== "bytes" || (p2("Content-Encoding") || "identity") !== "identity" || (b2.allowRangeRequests = true), b2;
      }, d2.validateResponseStatus = function(O) {
        return O === 200 || O === 206;
      };
      var e2 = t2(1), a2 = t2(158), y = t2(142);
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.getFilenameFromContentDispositionHeader = function(y) {
        let w2 = true, O = p2("filename\\*", "i").exec(y);
        if (O) {
          O = O[1];
          let m2 = c2(O);
          return m2 = unescape(m2), m2 = b2(m2), m2 = L2(m2), l2(m2);
        }
        if (O = function(M) {
          const x2 = [];
          let I2;
          const v = p2("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
          for (; (I2 = v.exec(M)) !== null; ) {
            let [, A2, n2, s] = I2;
            if (A2 = parseInt(A2, 10), A2 in x2) {
              if (A2 === 0)
                break;
            } else
              x2[A2] = [n2, s];
          }
          const i2 = [];
          for (let A2 = 0; A2 < x2.length && A2 in x2; ++A2) {
            let [n2, s] = x2[A2];
            s = c2(s), n2 && (s = unescape(s), A2 === 0 && (s = b2(s))), i2.push(s);
          }
          return i2.join("");
        }(y), O)
          return l2(L2(O));
        if (O = p2("filename", "i").exec(y), O) {
          O = O[1];
          let m2 = c2(O);
          return m2 = L2(m2), l2(m2);
        }
        function p2(m2, M) {
          return new RegExp("(?:^|;)\\s*" + m2 + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', M);
        }
        function h2(m2, M) {
          if (m2) {
            if (!/^[\x00-\xFF]+$/.test(M))
              return M;
            try {
              const x2 = new TextDecoder(m2, { fatal: true }), I2 = (0, e2.stringToBytes)(M);
              M = x2.decode(I2), w2 = false;
            } catch {
            }
          }
          return M;
        }
        function l2(m2) {
          return w2 && /[\x80-\xff]/.test(m2) && (m2 = h2("utf-8", m2), w2 && (m2 = h2("iso-8859-1", m2))), m2;
        }
        function c2(m2) {
          if (m2.startsWith('"')) {
            const M = m2.slice(1).split('\\"');
            for (let x2 = 0; x2 < M.length; ++x2) {
              const I2 = M[x2].indexOf('"');
              I2 !== -1 && (M[x2] = M[x2].slice(0, I2), M.length = x2 + 1), M[x2] = M[x2].replaceAll(/\\(.)/g, "$1");
            }
            m2 = M.join('"');
          }
          return m2;
        }
        function b2(m2) {
          const M = m2.indexOf("'");
          return M === -1 ? m2 : h2(m2.slice(0, M), m2.slice(M + 1).replace(/^[^']*'/, ""));
        }
        function L2(m2) {
          return !m2.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(m2) ? m2 : m2.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(M, x2, I2, v) {
            if (I2 === "q" || I2 === "Q")
              return h2(x2, v = (v = v.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, function(i2, A2) {
                return String.fromCharCode(parseInt(A2, 16));
              }));
            try {
              v = atob(v);
            } catch {
            }
            return h2(x2, v);
          });
        }
        return "";
      };
      var e2 = t2(1);
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.PDFNetworkStream = void 0;
      var e2 = t2(1), a2 = t2(157);
      class y {
        constructor(h2) {
          let l2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this.url = h2, this.isHttp = /^https?:/i.test(h2), this.httpHeaders = this.isHttp && l2.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = l2.withCredentials || false, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
        }
        requestRange(h2, l2, c2) {
          const b2 = { begin: h2, end: l2 };
          for (const L2 in c2)
            b2[L2] = c2[L2];
          return this.request(b2);
        }
        requestFull(h2) {
          return this.request(h2);
        }
        request(h2) {
          const l2 = new XMLHttpRequest(), c2 = this.currXhrId++, b2 = this.pendingRequests[c2] = { xhr: l2 };
          l2.open("GET", this.url), l2.withCredentials = this.withCredentials;
          for (const L2 in this.httpHeaders) {
            const m2 = this.httpHeaders[L2];
            m2 !== void 0 && l2.setRequestHeader(L2, m2);
          }
          return this.isHttp && "begin" in h2 && "end" in h2 ? (l2.setRequestHeader("Range", `bytes=${h2.begin}-${h2.end - 1}`), b2.expectedStatus = 206) : b2.expectedStatus = 200, l2.responseType = "arraybuffer", h2.onError && (l2.onerror = function(L2) {
            h2.onError(l2.status);
          }), l2.onreadystatechange = this.onStateChange.bind(this, c2), l2.onprogress = this.onProgress.bind(this, c2), b2.onHeadersReceived = h2.onHeadersReceived, b2.onDone = h2.onDone, b2.onError = h2.onError, b2.onProgress = h2.onProgress, l2.send(null), c2;
        }
        onProgress(h2, l2) {
          var c2;
          const b2 = this.pendingRequests[h2];
          b2 && ((c2 = b2.onProgress) === null || c2 === void 0 || c2.call(b2, l2));
        }
        onStateChange(h2, l2) {
          const c2 = this.pendingRequests[h2];
          if (!c2)
            return;
          const b2 = c2.xhr;
          if (b2.readyState >= 2 && c2.onHeadersReceived && (c2.onHeadersReceived(), delete c2.onHeadersReceived), b2.readyState !== 4 || !(h2 in this.pendingRequests))
            return;
          if (delete this.pendingRequests[h2], b2.status === 0 && this.isHttp) {
            var L2;
            (L2 = c2.onError) === null || L2 === void 0 || L2.call(c2, b2.status);
            return;
          }
          const m2 = b2.status || 200;
          if (!(m2 === 200 && c2.expectedStatus === 206) && m2 !== c2.expectedStatus) {
            var M;
            (M = c2.onError) === null || M === void 0 || M.call(c2, b2.status);
            return;
          }
          const x2 = function(i2) {
            const A2 = i2.response;
            return typeof A2 != "string" ? A2 : (0, e2.stringToBytes)(A2).buffer;
          }(b2);
          if (m2 === 206) {
            const v = b2.getResponseHeader("Content-Range"), i2 = /bytes (\d+)-(\d+)\/(\d+)/.exec(v);
            c2.onDone({ begin: parseInt(i2[1], 10), chunk: x2 });
          } else if (x2)
            c2.onDone({ begin: 0, chunk: x2 });
          else {
            var I2;
            (I2 = c2.onError) === null || I2 === void 0 || I2.call(c2, b2.status);
          }
        }
        getRequestXhr(h2) {
          return this.pendingRequests[h2].xhr;
        }
        isPendingRequest(h2) {
          return h2 in this.pendingRequests;
        }
        abortRequest(h2) {
          const l2 = this.pendingRequests[h2].xhr;
          delete this.pendingRequests[h2], l2.abort();
        }
      }
      d2.PDFNetworkStream = class {
        constructor(h2) {
          this._source = h2, this._manager = new y(h2.url, { httpHeaders: h2.httpHeaders, withCredentials: h2.withCredentials }), this._rangeChunkSize = h2.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
        }
        _onRangeRequestReaderClosed(h2) {
          const l2 = this._rangeRequestReaders.indexOf(h2);
          l2 >= 0 && this._rangeRequestReaders.splice(l2, 1);
        }
        getFullReader() {
          return (0, e2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new w2(this._manager, this._source), this._fullRequestReader;
        }
        getRangeReader(h2, l2) {
          const c2 = new O(this._manager, h2, l2);
          return c2.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(c2), c2;
        }
        cancelAllRequests(h2) {
          var l2;
          (l2 = this._fullRequestReader) === null || l2 === void 0 || l2.cancel(h2);
          for (const c2 of this._rangeRequestReaders.slice(0))
            c2.cancel(h2);
        }
      };
      class w2 {
        constructor(h2, l2) {
          this._manager = h2;
          const c2 = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) };
          this._url = l2.url, this._fullRequestId = h2.requestFull(c2), this._headersReceivedCapability = new e2.PromiseCapability(), this._disableRange = l2.disableRange || false, this._contentLength = l2.length, this._rangeChunkSize = l2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = false, this._isRangeSupported = false, this._cachedChunks = [], this._requests = [], this._done = false, this._storedError = void 0, this._filename = null, this.onProgress = null;
        }
        _onHeadersReceived() {
          const h2 = this._fullRequestId, l2 = this._manager.getRequestXhr(h2), c2 = (m2) => l2.getResponseHeader(m2), { allowRangeRequests: b2, suggestedLength: L2 } = (0, a2.validateRangeRequestCapabilities)({ getResponseHeader: c2, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
          b2 && (this._isRangeSupported = true), this._contentLength = L2 || this._contentLength, this._filename = (0, a2.extractFilenameFromHeader)(c2), this._isRangeSupported && this._manager.abortRequest(h2), this._headersReceivedCapability.resolve();
        }
        _onDone(h2) {
          if (h2 && (this._requests.length > 0 ? this._requests.shift().resolve({ value: h2.chunk, done: false }) : this._cachedChunks.push(h2.chunk)), this._done = true, !(this._cachedChunks.length > 0)) {
            for (const l2 of this._requests)
              l2.resolve({ value: void 0, done: true });
            this._requests.length = 0;
          }
        }
        _onError(h2) {
          this._storedError = (0, a2.createResponseStatusError)(h2, this._url), this._headersReceivedCapability.reject(this._storedError);
          for (const l2 of this._requests)
            l2.reject(this._storedError);
          this._requests.length = 0, this._cachedChunks.length = 0;
        }
        _onProgress(h2) {
          var l2;
          (l2 = this.onProgress) === null || l2 === void 0 || l2.call(this, { loaded: h2.loaded, total: h2.lengthComputable ? h2.total : this._contentLength });
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        get contentLength() {
          return this._contentLength;
        }
        get headersReady() {
          return this._headersReceivedCapability.promise;
        }
        async read() {
          if (this._storedError)
            throw this._storedError;
          if (this._cachedChunks.length > 0)
            return { value: this._cachedChunks.shift(), done: false };
          if (this._done)
            return { value: void 0, done: true };
          const h2 = new e2.PromiseCapability();
          return this._requests.push(h2), h2.promise;
        }
        cancel(h2) {
          this._done = true, this._headersReceivedCapability.reject(h2);
          for (const l2 of this._requests)
            l2.resolve({ value: void 0, done: true });
          this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
        }
      }
      class O {
        constructor(h2, l2, c2) {
          this._manager = h2;
          const b2 = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) };
          this._url = h2.url, this._requestId = h2.requestRange(l2, c2, b2), this._requests = [], this._queuedChunk = null, this._done = false, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
        }
        _close() {
          var h2;
          (h2 = this.onClosed) === null || h2 === void 0 || h2.call(this, this);
        }
        _onDone(h2) {
          const l2 = h2.chunk;
          this._requests.length > 0 ? this._requests.shift().resolve({ value: l2, done: false }) : this._queuedChunk = l2, this._done = true;
          for (const c2 of this._requests)
            c2.resolve({ value: void 0, done: true });
          this._requests.length = 0, this._close();
        }
        _onError(h2) {
          this._storedError = (0, a2.createResponseStatusError)(h2, this._url);
          for (const l2 of this._requests)
            l2.reject(this._storedError);
          this._requests.length = 0, this._queuedChunk = null;
        }
        _onProgress(h2) {
          if (!this.isStreamingSupported) {
            var l2;
            (l2 = this.onProgress) === null || l2 === void 0 || l2.call(this, { loaded: h2.loaded });
          }
        }
        get isStreamingSupported() {
          return false;
        }
        async read() {
          if (this._storedError)
            throw this._storedError;
          if (this._queuedChunk !== null) {
            const l2 = this._queuedChunk;
            return this._queuedChunk = null, { value: l2, done: false };
          }
          if (this._done)
            return { value: void 0, done: true };
          const h2 = new e2.PromiseCapability();
          return this._requests.push(h2), h2.promise;
        }
        cancel(h2) {
          this._done = true;
          for (const l2 of this._requests)
            l2.resolve({ value: void 0, done: true });
          this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
        }
      }
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.PDFFetchStream = void 0;
      var e2 = t2(1), a2 = t2(157);
      function y(l2, c2, b2) {
        return { method: "GET", headers: l2, signal: b2.signal, mode: "cors", credentials: c2 ? "include" : "same-origin", redirect: "follow" };
      }
      function w2(l2) {
        const c2 = new Headers();
        for (const b2 in l2) {
          const L2 = l2[b2];
          L2 !== void 0 && c2.append(b2, L2);
        }
        return c2;
      }
      function O(l2) {
        return l2 instanceof Uint8Array ? l2.buffer : l2 instanceof ArrayBuffer ? l2 : ((0, e2.warn)(`getArrayBuffer - unexpected data format: ${l2}`), new Uint8Array(l2).buffer);
      }
      d2.PDFFetchStream = class {
        constructor(c2) {
          this.source = c2, this.isHttp = /^https?:/i.test(c2.url), this.httpHeaders = this.isHttp && c2.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
        }
        get _progressiveDataLength() {
          var c2;
          return ((c2 = this._fullRequestReader) === null || c2 === void 0 ? void 0 : c2._loaded) ?? 0;
        }
        getFullReader() {
          return (0, e2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new p2(this), this._fullRequestReader;
        }
        getRangeReader(c2, b2) {
          if (b2 <= this._progressiveDataLength)
            return null;
          const L2 = new h2(this, c2, b2);
          return this._rangeRequestReaders.push(L2), L2;
        }
        cancelAllRequests(c2) {
          var b2;
          (b2 = this._fullRequestReader) === null || b2 === void 0 || b2.cancel(c2);
          for (const L2 of this._rangeRequestReaders.slice(0))
            L2.cancel(c2);
        }
      };
      class p2 {
        constructor(c2) {
          this._stream = c2, this._reader = null, this._loaded = 0, this._filename = null;
          const b2 = c2.source;
          this._withCredentials = b2.withCredentials || false, this._contentLength = b2.length, this._headersCapability = new e2.PromiseCapability(), this._disableRange = b2.disableRange || false, this._rangeChunkSize = b2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._abortController = new AbortController(), this._isStreamingSupported = !b2.disableStream, this._isRangeSupported = !b2.disableRange, this._headers = w2(this._stream.httpHeaders);
          const L2 = b2.url;
          fetch(L2, y(this._headers, this._withCredentials, this._abortController)).then((m2) => {
            if (!(0, a2.validateResponseStatus)(m2.status))
              throw (0, a2.createResponseStatusError)(m2.status, L2);
            this._reader = m2.body.getReader(), this._headersCapability.resolve();
            const M = (v) => m2.headers.get(v), { allowRangeRequests: x2, suggestedLength: I2 } = (0, a2.validateRangeRequestCapabilities)({ getResponseHeader: M, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
            this._isRangeSupported = x2, this._contentLength = I2 || this._contentLength, this._filename = (0, a2.extractFilenameFromHeader)(M), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new e2.AbortException("Streaming is disabled."));
          }).catch(this._headersCapability.reject), this.onProgress = null;
        }
        get headersReady() {
          return this._headersCapability.promise;
        }
        get filename() {
          return this._filename;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        async read() {
          var c2;
          await this._headersCapability.promise;
          const { value: b2, done: L2 } = await this._reader.read();
          return L2 ? { value: b2, done: L2 } : (this._loaded += b2.byteLength, (c2 = this.onProgress) === null || c2 === void 0 || c2.call(this, { loaded: this._loaded, total: this._contentLength }), { value: O(b2), done: false });
        }
        cancel(c2) {
          var b2;
          (b2 = this._reader) === null || b2 === void 0 || b2.cancel(c2), this._abortController.abort();
        }
      }
      class h2 {
        constructor(c2, b2, L2) {
          this._stream = c2, this._reader = null, this._loaded = 0;
          const m2 = c2.source;
          this._withCredentials = m2.withCredentials || false, this._readCapability = new e2.PromiseCapability(), this._isStreamingSupported = !m2.disableStream, this._abortController = new AbortController(), this._headers = w2(this._stream.httpHeaders), this._headers.append("Range", `bytes=${b2}-${L2 - 1}`);
          const M = m2.url;
          fetch(M, y(this._headers, this._withCredentials, this._abortController)).then((x2) => {
            if (!(0, a2.validateResponseStatus)(x2.status))
              throw (0, a2.createResponseStatusError)(x2.status, M);
            this._readCapability.resolve(), this._reader = x2.body.getReader();
          }).catch(this._readCapability.reject), this.onProgress = null;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        async read() {
          var c2;
          await this._readCapability.promise;
          const { value: b2, done: L2 } = await this._reader.read();
          return L2 ? { value: b2, done: L2 } : (this._loaded += b2.byteLength, (c2 = this.onProgress) === null || c2 === void 0 || c2.call(this, { loaded: this._loaded }), { value: O(b2), done: false });
        }
        cancel(c2) {
          var b2;
          (b2 = this._reader) === null || b2 === void 0 || b2.cancel(c2), this._abortController.abort();
        }
      }
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.TextLayerRenderTask = void 0, d2.renderTextLayer = function(L2) {
        !L2.textContentSource && (L2.textContent || L2.textContentStream) && ((0, a2.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), L2.textContentSource = L2.textContent || L2.textContentStream);
        const { container: m2, viewport: M } = L2, x2 = getComputedStyle(m2), I2 = x2.getPropertyValue("visibility"), v = parseFloat(x2.getPropertyValue("--scale-factor"));
        I2 === "visible" && (!v || Math.abs(v - M.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
        const i2 = new c2(L2);
        return i2._render(), i2;
      }, d2.updateTextLayer = function(L2) {
        let { container: m2, viewport: M, textDivs: x2, textDivProperties: I2, isOffscreenCanvasSupported: v, mustRotate: i2 = true, mustRescale: A2 = true } = L2;
        if (i2 && (0, a2.setLayerDimensions)(m2, { rotation: M.rotation }), A2) {
          const n2 = p2(0, v), s = { prevFontSize: null, prevFontFamily: null, div: null, scale: M.scale * (globalThis.devicePixelRatio || 1), properties: null, ctx: n2 };
          for (const r of x2)
            s.properties = I2.get(r), s.div = r, l2(s);
        }
      };
      var e2 = t2(1), a2 = t2(142);
      const y = 30, w2 = 0.8, O = /* @__PURE__ */ new Map();
      function p2(b2, L2) {
        let m2;
        if (L2 && e2.FeatureTest.isOffscreenCanvasSupported)
          m2 = new OffscreenCanvas(b2, b2).getContext("2d", { alpha: false });
        else {
          const M = document.createElement("canvas");
          M.width = M.height = b2, m2 = M.getContext("2d", { alpha: false });
        }
        return m2;
      }
      function h2(b2, L2, m2) {
        const M = document.createElement("span"), x2 = { angle: 0, canvasWidth: 0, hasText: L2.str !== "", hasEOL: L2.hasEOL, fontSize: 0 };
        b2._textDivs.push(M);
        const I2 = e2.Util.transform(b2._transform, L2.transform);
        let v = Math.atan2(I2[1], I2[0]);
        const i2 = m2[L2.fontName];
        i2.vertical && (v += Math.PI / 2);
        const A2 = Math.hypot(I2[2], I2[3]), n2 = A2 * function(F, z) {
          const q = O.get(F);
          if (q)
            return q;
          const J = p2(y, z);
          J.font = `${y}px ${F}`;
          const $ = J.measureText("");
          let S = $.fontBoundingBoxAscent, f = Math.abs($.fontBoundingBoxDescent);
          if (S) {
            const g = S / (S + f);
            return O.set(F, g), J.canvas.width = J.canvas.height = 0, g;
          }
          J.strokeStyle = "red", J.clearRect(0, 0, y, y), J.strokeText("g", 0, 0);
          let P = J.getImageData(0, 0, y, y).data;
          f = 0;
          for (let g = P.length - 1 - 3; g >= 0; g -= 4)
            if (P[g] > 0) {
              f = Math.ceil(g / 4 / y);
              break;
            }
          J.clearRect(0, 0, y, y), J.strokeText("A", 0, y), P = J.getImageData(0, 0, y, y).data, S = 0;
          for (let g = 0, _ = P.length; g < _; g += 4)
            if (P[g] > 0) {
              S = y - Math.floor(g / 4 / y);
              break;
            }
          if (J.canvas.width = J.canvas.height = 0, S) {
            const g = S / (S + f);
            return O.set(F, g), g;
          }
          return O.set(F, w2), w2;
        }(i2.fontFamily, b2._isOffscreenCanvasSupported);
        let s, r;
        v === 0 ? (s = I2[4], r = I2[5] - n2) : (s = I2[4] + n2 * Math.sin(v), r = I2[5] - n2 * Math.cos(v));
        const u = "calc(var(--scale-factor)*", C = M.style;
        b2._container === b2._rootContainer ? (C.left = `${(100 * s / b2._pageWidth).toFixed(2)}%`, C.top = `${(100 * r / b2._pageHeight).toFixed(2)}%`) : (C.left = `${u}${s.toFixed(2)}px)`, C.top = `${u}${r.toFixed(2)}px)`), C.fontSize = `${u}${A2.toFixed(2)}px)`, C.fontFamily = i2.fontFamily, x2.fontSize = A2, M.setAttribute("role", "presentation"), M.textContent = L2.str, M.dir = L2.dir, b2._fontInspectorEnabled && (M.dataset.fontName = L2.fontName), v !== 0 && (x2.angle = v * (180 / Math.PI));
        let D = false;
        if (L2.str.length > 1)
          D = true;
        else if (L2.str !== " " && L2.transform[0] !== L2.transform[3]) {
          const o = Math.abs(L2.transform[0]), F = Math.abs(L2.transform[3]);
          o !== F && Math.max(o, F) / Math.min(o, F) > 1.5 && (D = true);
        }
        D && (x2.canvasWidth = i2.vertical ? L2.height : L2.width), b2._textDivProperties.set(M, x2), b2._isReadableStream && b2._layoutText(M);
      }
      function l2(b2) {
        const { div: L2, scale: m2, properties: M, ctx: x2, prevFontSize: I2, prevFontFamily: v } = b2, { style: i2 } = L2;
        let A2 = "";
        if (M.canvasWidth !== 0 && M.hasText) {
          const { fontFamily: n2 } = i2, { canvasWidth: s, fontSize: r } = M;
          (I2 !== r || v !== n2) && (x2.font = `${r * m2}px ${n2}`, b2.prevFontSize = r, b2.prevFontFamily = n2);
          const { width: u } = x2.measureText(L2.textContent);
          u > 0 && (A2 = `scaleX(${s * m2 / u})`);
        }
        M.angle !== 0 && (A2 = `rotate(${M.angle}deg) ${A2}`), A2.length > 0 && (i2.transform = A2);
      }
      class c2 {
        constructor(L2) {
          var m2;
          let { textContentSource: M, container: x2, viewport: I2, textDivs: v, textDivProperties: i2, textContentItemsStr: A2, isOffscreenCanvasSupported: n2 } = L2;
          this._textContentSource = M, this._isReadableStream = M instanceof ReadableStream, this._container = this._rootContainer = x2, this._textDivs = v || [], this._textContentItemsStr = A2 || [], this._isOffscreenCanvasSupported = n2, this._fontInspectorEnabled = !((m2 = globalThis.FontInspector) === null || m2 === void 0 || !m2.enabled), this._reader = null, this._textDivProperties = i2 || /* @__PURE__ */ new WeakMap(), this._canceled = false, this._capability = new e2.PromiseCapability(), this._layoutTextParams = { prevFontSize: null, prevFontFamily: null, div: null, scale: I2.scale * (globalThis.devicePixelRatio || 1), properties: null, ctx: p2(0, n2) };
          const { pageWidth: s, pageHeight: r, pageX: u, pageY: C } = I2.rawDims;
          this._transform = [1, 0, 0, -1, -u, C + r], this._pageWidth = s, this._pageHeight = r, (0, a2.setLayerDimensions)(x2, I2), this._capability.promise.finally(() => {
            this._layoutTextParams = null;
          }).catch(() => {
          });
        }
        get promise() {
          return this._capability.promise;
        }
        cancel() {
          this._canceled = true, this._reader && (this._reader.cancel(new e2.AbortException("TextLayer task cancelled.")).catch(() => {
          }), this._reader = null), this._capability.reject(new e2.AbortException("TextLayer task cancelled."));
        }
        _processItems(L2, m2) {
          for (const M of L2)
            if (M.str !== void 0)
              this._textContentItemsStr.push(M.str), h2(this, M, m2);
            else if (M.type === "beginMarkedContentProps" || M.type === "beginMarkedContent") {
              const x2 = this._container;
              this._container = document.createElement("span"), this._container.classList.add("markedContent"), M.id !== null && this._container.setAttribute("id", `${M.id}`), x2.append(this._container);
            } else
              M.type === "endMarkedContent" && (this._container = this._container.parentNode);
        }
        _layoutText(L2) {
          const m2 = this._layoutTextParams.properties = this._textDivProperties.get(L2);
          if (this._layoutTextParams.div = L2, l2(this._layoutTextParams), m2.hasText && this._container.append(L2), m2.hasEOL) {
            const M = document.createElement("br");
            M.setAttribute("role", "presentation"), this._container.append(M);
          }
        }
        _render() {
          const L2 = new e2.PromiseCapability();
          let m2 = /* @__PURE__ */ Object.create(null);
          if (this._isReadableStream) {
            const M = () => {
              this._reader.read().then((x2) => {
                let { value: I2, done: v } = x2;
                v ? L2.resolve() : (Object.assign(m2, I2.styles), this._processItems(I2.items, m2), M());
              }, L2.reject);
            };
            this._reader = this._textContentSource.getReader(), M();
          } else {
            if (!this._textContentSource)
              throw new Error('No "textContentSource" parameter specified.');
            {
              const { items: M, styles: x2 } = this._textContentSource;
              this._processItems(M, x2), L2.resolve();
            }
          }
          L2.promise.then(() => {
            m2 = null, function(x2) {
              if (x2._canceled)
                return;
              const I2 = x2._textDivs, v = x2._capability;
              if (I2.length > 1e5)
                v.resolve();
              else {
                if (!x2._isReadableStream)
                  for (const i2 of I2)
                    x2._layoutText(i2);
                v.resolve();
              }
            }(this);
          }, this._capability.reject);
        }
      }
      d2.TextLayerRenderTask = c2;
    }, (k2, d2, t2) => {
      var h2, l2, c2, b2, L2, m2, M, x2, I2, Pe, i2, Je, n2, ke, r, Re;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.AnnotationEditorLayer = void 0;
      var e2 = t2(1), a2 = t2(141), y = t2(163), w2 = t2(164), O = t2(142);
      const C = class {
        constructor(o) {
          et(this, I2);
          et(this, i2);
          et(this, n2);
          et(this, r);
          et(this, h2, void 0);
          et(this, l2, false);
          et(this, c2, this.pointerup.bind(this));
          et(this, b2, this.pointerdown.bind(this));
          et(this, L2, /* @__PURE__ */ new Map());
          et(this, m2, false);
          et(this, M, false);
          et(this, x2, void 0);
          C._initialized || (C._initialized = true, y.FreeTextEditor.initialize(o.l10n), w2.InkEditor.initialize(o.l10n)), o.uiManager.registerEditorTypes([y.FreeTextEditor, w2.InkEditor]), ut(this, x2, o.uiManager), this.pageIndex = o.pageIndex, this.div = o.div, ut(this, h2, o.accessibilityManager), T(this, x2).addLayer(this);
        }
        get isEmpty() {
          return T(this, L2).size === 0;
        }
        updateToolbar(o) {
          T(this, x2).updateToolbar(o);
        }
        updateMode() {
          let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : T(this, x2).getMode();
          nt(this, r, Re).call(this), o === e2.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(false), this.disableClick()) : this.enableClick(), T(this, x2).unselectAll(), o !== e2.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", o === e2.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", o === e2.AnnotationEditorType.INK), this.div.hidden = false);
        }
        addInkEditorIfNeeded(o) {
          if (!(!o && T(this, x2).getMode() !== e2.AnnotationEditorType.INK)) {
            if (!o) {
              for (const F of T(this, L2).values())
                if (F.isEmpty()) {
                  F.setInBackground();
                  return;
                }
            }
            nt(this, n2, ke).call(this, { offsetX: 0, offsetY: 0 }).setInBackground();
          }
        }
        setEditingState(o) {
          T(this, x2).setEditingState(o);
        }
        addCommands(o) {
          T(this, x2).addCommands(o);
        }
        enable() {
          this.div.style.pointerEvents = "auto";
          for (const o of T(this, L2).values())
            o.enableEditing();
        }
        disable() {
          this.div.style.pointerEvents = "none";
          for (const o of T(this, L2).values())
            o.disableEditing();
          nt(this, r, Re).call(this), this.isEmpty && (this.div.hidden = true);
        }
        setActiveEditor(o) {
          T(this, x2).getActive() !== o && T(this, x2).setActiveEditor(o);
        }
        enableClick() {
          this.div.addEventListener("pointerdown", T(this, b2)), this.div.addEventListener("pointerup", T(this, c2));
        }
        disableClick() {
          this.div.removeEventListener("pointerdown", T(this, b2)), this.div.removeEventListener("pointerup", T(this, c2));
        }
        attach(o) {
          T(this, L2).set(o.id, o);
        }
        detach(o) {
          var F;
          T(this, L2).delete(o.id), (F = T(this, h2)) === null || F === void 0 || F.removePointerInTextLayer(o.contentDiv);
        }
        remove(o) {
          T(this, x2).removeEditor(o), this.detach(o), o.div.style.display = "none", setTimeout(() => {
            o.div.style.display = "", o.div.remove(), o.isAttachedToDOM = false, document.activeElement === document.body && T(this, x2).focusMainContainer();
          }, 0), T(this, M) || this.addInkEditorIfNeeded(false);
        }
        add(o) {
          if (nt(this, I2, Pe).call(this, o), T(this, x2).addEditor(o), this.attach(o), !o.isAttachedToDOM) {
            const F = o.render();
            this.div.append(F), o.isAttachedToDOM = true;
          }
          this.moveEditorInDOM(o), o.onceAdded(), T(this, x2).addToAnnotationStorage(o);
        }
        moveEditorInDOM(o) {
          var F;
          (F = T(this, h2)) === null || F === void 0 || F.moveElementInDOM(this.div, o.div, o.contentDiv, true);
        }
        addOrRebuild(o) {
          o.needsToBeRebuilt() ? o.rebuild() : this.add(o);
        }
        addANewEditor(o) {
          this.addCommands({ cmd: () => {
            this.addOrRebuild(o);
          }, undo: () => {
            o.remove();
          }, mustExec: true });
        }
        addUndoableEditor(o) {
          this.addCommands({ cmd: () => {
            this.addOrRebuild(o);
          }, undo: () => {
            o.remove();
          }, mustExec: false });
        }
        getNextId() {
          return T(this, x2).getId();
        }
        deserialize(o) {
          switch (o.annotationType) {
            case e2.AnnotationEditorType.FREETEXT:
              return y.FreeTextEditor.deserialize(o, this, T(this, x2));
            case e2.AnnotationEditorType.INK:
              return w2.InkEditor.deserialize(o, this, T(this, x2));
          }
          return null;
        }
        setSelected(o) {
          T(this, x2).setSelected(o);
        }
        toggleSelected(o) {
          T(this, x2).toggleSelected(o);
        }
        isSelected(o) {
          return T(this, x2).isSelected(o);
        }
        unselect(o) {
          T(this, x2).unselect(o);
        }
        pointerup(o) {
          const { isMac: F } = e2.FeatureTest.platform;
          !(o.button !== 0 || o.ctrlKey && F) && o.target === this.div && T(this, m2) && (ut(this, m2, false), T(this, l2) ? nt(this, n2, ke).call(this, o) : ut(this, l2, true));
        }
        pointerdown(o) {
          const { isMac: F } = e2.FeatureTest.platform;
          if (o.button !== 0 || o.ctrlKey && F || o.target !== this.div)
            return;
          ut(this, m2, true);
          const z = T(this, x2).getActive();
          ut(this, l2, !z || z.isEmpty());
        }
        drop(o) {
          const F = o.dataTransfer.getData("text/plain"), z = T(this, x2).getEditor(F);
          if (!z)
            return;
          o.preventDefault(), o.dataTransfer.dropEffect = "move", nt(this, I2, Pe).call(this, z);
          const q = this.div.getBoundingClientRect(), J = o.clientX - q.x, $ = o.clientY - q.y;
          z.translate(J - z.startX, $ - z.startY), this.moveEditorInDOM(z), z.div.focus();
        }
        dragover(o) {
          o.preventDefault();
        }
        destroy() {
          var o;
          ((o = T(this, x2).getActive()) === null || o === void 0 ? void 0 : o.parent) === this && T(this, x2).setActiveEditor(null);
          for (const z of T(this, L2).values()) {
            var F;
            (F = T(this, h2)) === null || F === void 0 || F.removePointerInTextLayer(z.contentDiv), z.setParent(null), z.isAttachedToDOM = false, z.div.remove();
          }
          this.div = null, T(this, L2).clear(), T(this, x2).removeLayer(this);
        }
        render(o) {
          let { viewport: F } = o;
          this.viewport = F, (0, O.setLayerDimensions)(this.div, F), (0, a2.bindEvents)(this, this.div, ["dragover", "drop"]);
          for (const z of T(this, x2).getEditors(this.pageIndex))
            this.add(z);
          this.updateMode();
        }
        update(o) {
          let { viewport: F } = o;
          T(this, x2).commitOrRemove(), this.viewport = F, (0, O.setLayerDimensions)(this.div, { rotation: F.rotation }), this.updateMode();
        }
        get pageDimensions() {
          const { pageWidth: o, pageHeight: F } = this.viewport.rawDims;
          return [o, F];
        }
      };
      let p2 = C;
      h2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), c2 = /* @__PURE__ */ new WeakMap(), b2 = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap(), m2 = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap(), x2 = /* @__PURE__ */ new WeakMap(), I2 = /* @__PURE__ */ new WeakSet(), Pe = function(o) {
        var F;
        o.parent !== this && (this.attach(o), (F = o.parent) === null || F === void 0 || F.detach(o), o.setParent(this), o.div && o.isAttachedToDOM && (o.div.remove(), this.div.append(o.div)));
      }, i2 = /* @__PURE__ */ new WeakSet(), Je = function(o) {
        switch (T(this, x2).getMode()) {
          case e2.AnnotationEditorType.FREETEXT:
            return new y.FreeTextEditor(o);
          case e2.AnnotationEditorType.INK:
            return new w2.InkEditor(o);
        }
        return null;
      }, n2 = /* @__PURE__ */ new WeakSet(), ke = function(o) {
        const F = this.getNextId(), z = nt(this, i2, Je).call(this, { parent: this, id: F, x: o.offsetX, y: o.offsetY, uiManager: T(this, x2) });
        return z && this.add(z), z;
      }, r = /* @__PURE__ */ new WeakSet(), Re = function() {
        ut(this, M, true);
        for (const o of T(this, L2).values())
          o.isEmpty() && o.remove();
        ut(this, M, false);
      }, It(p2, "_initialized", false), d2.AnnotationEditorLayer = p2;
    }, (k2, d2, t2) => {
      var O, p2, h2, l2, c2, b2, L2, m2, M, x2, Qe, v, Ze, A2, tr, s, Me;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.FreeTextEditor = void 0;
      var e2 = t2(1), a2 = t2(141), y = t2(140);
      const u = class extends y.AnnotationEditor {
        constructor(o) {
          super({ ...o, name: "freeTextEditor" });
          et(this, x2);
          et(this, v);
          et(this, A2);
          et(this, s);
          et(this, O, this.editorDivBlur.bind(this));
          et(this, p2, this.editorDivFocus.bind(this));
          et(this, h2, this.editorDivInput.bind(this));
          et(this, l2, this.editorDivKeydown.bind(this));
          et(this, c2, void 0);
          et(this, b2, "");
          et(this, L2, `${this.id}-editor`);
          et(this, m2, false);
          et(this, M, void 0);
          ut(this, c2, o.color || u._defaultColor || y.AnnotationEditor._defaultLineColor), ut(this, M, o.fontSize || u._defaultFontSize);
        }
        static initialize(o) {
          this._l10nPromise = new Map(["free_text2_default_content", "editor_free_text2_aria_label"].map((z) => [z, o.get(z)]));
          const F = getComputedStyle(document.documentElement);
          this._internalPadding = parseFloat(F.getPropertyValue("--freetext-padding"));
        }
        static updateDefaultParams(o, F) {
          switch (o) {
            case e2.AnnotationEditorParamsType.FREETEXT_SIZE:
              u._defaultFontSize = F;
              break;
            case e2.AnnotationEditorParamsType.FREETEXT_COLOR:
              u._defaultColor = F;
          }
        }
        updateParams(o, F) {
          switch (o) {
            case e2.AnnotationEditorParamsType.FREETEXT_SIZE:
              nt(this, x2, Qe).call(this, F);
              break;
            case e2.AnnotationEditorParamsType.FREETEXT_COLOR:
              nt(this, v, Ze).call(this, F);
          }
        }
        static get defaultPropertiesToUpdate() {
          return [[e2.AnnotationEditorParamsType.FREETEXT_SIZE, u._defaultFontSize], [e2.AnnotationEditorParamsType.FREETEXT_COLOR, u._defaultColor || y.AnnotationEditor._defaultLineColor]];
        }
        get propertiesToUpdate() {
          return [[e2.AnnotationEditorParamsType.FREETEXT_SIZE, T(this, M)], [e2.AnnotationEditorParamsType.FREETEXT_COLOR, T(this, c2)]];
        }
        getInitialTranslation() {
          const o = this.parentScale;
          return [-u._internalPadding * o, -(u._internalPadding + T(this, M)) * o];
        }
        rebuild() {
          super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this));
        }
        enableEditMode() {
          this.isInEditMode() || (this.parent.setEditingState(false), this.parent.updateToolbar(e2.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = true, this.div.draggable = false, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", T(this, l2)), this.editorDiv.addEventListener("focus", T(this, p2)), this.editorDiv.addEventListener("blur", T(this, O)), this.editorDiv.addEventListener("input", T(this, h2)));
        }
        disableEditMode() {
          this.isInEditMode() && (this.parent.setEditingState(true), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = false, this.div.setAttribute("aria-activedescendant", T(this, L2)), this.div.draggable = true, this.editorDiv.removeEventListener("keydown", T(this, l2)), this.editorDiv.removeEventListener("focus", T(this, p2)), this.editorDiv.removeEventListener("blur", T(this, O)), this.editorDiv.removeEventListener("input", T(this, h2)), this.div.focus({ preventScroll: true }), this.isEditing = false, this.parent.div.classList.add("freeTextEditing"));
        }
        focusin(o) {
          super.focusin(o), o.target !== this.editorDiv && this.editorDiv.focus();
        }
        onceAdded() {
          this.width || (this.enableEditMode(), this.editorDiv.focus());
        }
        isEmpty() {
          return !this.editorDiv || this.editorDiv.innerText.trim() === "";
        }
        remove() {
          this.isEditing = false, this.parent.setEditingState(true), this.parent.div.classList.add("freeTextEditing"), super.remove();
        }
        commit() {
          this.isInEditMode() && (super.commit(), T(this, m2) || (ut(this, m2, true), this.parent.addUndoableEditor(this)), this.disableEditMode(), ut(this, b2, nt(this, A2, tr).call(this).trimEnd()), nt(this, s, Me).call(this));
        }
        shouldGetKeyboardEvents() {
          return this.isInEditMode();
        }
        dblclick(o) {
          this.enableEditMode(), this.editorDiv.focus();
        }
        keydown(o) {
          o.target === this.div && o.key === "Enter" && (this.enableEditMode(), this.editorDiv.focus());
        }
        editorDivKeydown(o) {
          u._keyboardManager.exec(this, o);
        }
        editorDivFocus(o) {
          this.isEditing = true;
        }
        editorDivBlur(o) {
          this.isEditing = false;
        }
        editorDivInput(o) {
          this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
        }
        disableEditing() {
          this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
        }
        enableEditing() {
          this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", true);
        }
        render() {
          if (this.div)
            return this.div;
          let o, F;
          this.width && (o = this.x, F = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", T(this, L2)), this.enableEditing(), u._l10nPromise.get("editor_free_text2_aria_label").then((q) => {
            var J;
            return (J = this.editorDiv) === null || J === void 0 ? void 0 : J.setAttribute("aria-label", q);
          }), u._l10nPromise.get("free_text2_default_content").then((q) => {
            var J;
            return (J = this.editorDiv) === null || J === void 0 ? void 0 : J.setAttribute("default-content", q);
          }), this.editorDiv.contentEditable = true;
          const { style: z } = this.editorDiv;
          if (z.fontSize = `calc(${T(this, M)}px * var(--scale-factor))`, z.color = T(this, c2), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, a2.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
            const [q, J] = this.parentDimensions;
            this.setAt(o * q, F * J, this.width * q, this.height * J);
            for (const $ of T(this, b2).split(`
`)) {
              const S = document.createElement("div");
              S.append($ ? document.createTextNode($) : document.createElement("br")), this.editorDiv.append(S);
            }
            this.div.draggable = true, this.editorDiv.contentEditable = false;
          } else
            this.div.draggable = false, this.editorDiv.contentEditable = true;
          return this.div;
        }
        get contentDiv() {
          return this.editorDiv;
        }
        static deserialize(o, F, z) {
          const q = super.deserialize(o, F, z);
          return ut(q, M, o.fontSize), ut(q, c2, e2.Util.makeHexColor(...o.color)), ut(q, b2, o.value), q;
        }
        serialize() {
          if (this.isEmpty())
            return null;
          const o = u._internalPadding * this.parentScale, F = this.getRect(o, o), z = y.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : T(this, c2));
          return { annotationType: e2.AnnotationEditorType.FREETEXT, color: z, fontSize: T(this, M), value: T(this, b2), pageIndex: this.pageIndex, rect: F, rotation: this.rotation };
        }
      };
      let w2 = u;
      O = /* @__PURE__ */ new WeakMap(), p2 = /* @__PURE__ */ new WeakMap(), h2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), c2 = /* @__PURE__ */ new WeakMap(), b2 = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap(), m2 = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap(), x2 = /* @__PURE__ */ new WeakSet(), Qe = function(o) {
        const F = (q) => {
          this.editorDiv.style.fontSize = `calc(${q}px * var(--scale-factor))`, this.translate(0, -(q - T(this, M)) * this.parentScale), ut(this, M, q), nt(this, s, Me).call(this);
        }, z = T(this, M);
        this.addCommands({ cmd: () => {
          F(o);
        }, undo: () => {
          F(z);
        }, mustExec: true, type: e2.AnnotationEditorParamsType.FREETEXT_SIZE, overwriteIfSameType: true, keepUndo: true });
      }, v = /* @__PURE__ */ new WeakSet(), Ze = function(o) {
        const F = T(this, c2);
        this.addCommands({ cmd: () => {
          ut(this, c2, this.editorDiv.style.color = o);
        }, undo: () => {
          ut(this, c2, this.editorDiv.style.color = F);
        }, mustExec: true, type: e2.AnnotationEditorParamsType.FREETEXT_COLOR, overwriteIfSameType: true, keepUndo: true });
      }, A2 = /* @__PURE__ */ new WeakSet(), tr = function() {
        const o = this.editorDiv.getElementsByTagName("div");
        if (o.length === 0)
          return this.editorDiv.innerText;
        const F = [];
        for (const z of o)
          F.push(z.innerText.replace(/\r\n?|\n/, ""));
        return F.join(`
`);
      }, s = /* @__PURE__ */ new WeakSet(), Me = function() {
        const [o, F] = this.parentDimensions;
        let z;
        if (this.isAttachedToDOM)
          z = this.div.getBoundingClientRect();
        else {
          const { currentLayer: q, div: J } = this, $ = J.style.display;
          J.style.display = "hidden", q.div.append(this.div), z = J.getBoundingClientRect(), J.remove(), J.style.display = $;
        }
        this.width = z.width / o, this.height = z.height / F;
      }, It(w2, "_freeTextDefaultContent", ""), It(w2, "_l10nPromise"), It(w2, "_internalPadding", 0), It(w2, "_defaultColor", null), It(w2, "_defaultFontSize", 10), It(w2, "_keyboardManager", new a2.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], u.prototype.commitOrRemove]])), It(w2, "_type", "freetext"), d2.FreeTextEditor = w2;
    }, (k2, d2, t2) => {
      var p2, h2, l2, c2, b2, L2, m2, M, x2, I2, v, i2, A2, n2, s, r, u, er, D, rr, F, sr, q, nr, $, Fe, f, ir, g, De, U, ar, G, or, W, lr, K, cr, Z, hr, lt, Kt, R, Oe, B, ge, tt, me, it, ne, ct, Ie, ht, ve, yt, dr, Ct, ur, pt, pr, Mt, fr, at, Le, Et, be, St, ie, Nt, Ne;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.InkEditor = void 0;
      var e2 = t2(1), a2 = t2(140), y = t2(141);
      const w2 = 16, Rt = class extends a2.AnnotationEditor {
        constructor(st) {
          super({ ...st, name: "inkEditor" });
          et(this, u);
          et(this, D);
          et(this, F);
          et(this, q);
          et(this, $);
          et(this, f);
          et(this, g);
          et(this, U);
          et(this, G);
          et(this, W);
          et(this, K);
          et(this, Z);
          et(this, lt);
          et(this, R);
          et(this, B);
          et(this, tt);
          et(this, it);
          et(this, ct);
          et(this, ht);
          et(this, Ct);
          et(this, pt);
          et(this, Mt);
          et(this, at);
          et(this, Et);
          et(this, St);
          et(this, Nt);
          et(this, p2, 0);
          et(this, h2, 0);
          et(this, l2, 0);
          et(this, c2, this.canvasContextMenu.bind(this));
          et(this, b2, this.canvasPointermove.bind(this));
          et(this, L2, this.canvasPointerleave.bind(this));
          et(this, m2, this.canvasPointerup.bind(this));
          et(this, M, this.canvasPointerdown.bind(this));
          et(this, x2, new Path2D());
          et(this, I2, false);
          et(this, v, false);
          et(this, i2, false);
          et(this, A2, null);
          et(this, n2, 0);
          et(this, s, 0);
          et(this, r, null);
          this.color = st.color || null, this.thickness = st.thickness || null, this.opacity = st.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0;
        }
        static initialize(st) {
          this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink2_aria_label"].map((ot) => [ot, st.get(ot)]));
        }
        static updateDefaultParams(st, ot) {
          switch (st) {
            case e2.AnnotationEditorParamsType.INK_THICKNESS:
              Rt._defaultThickness = ot;
              break;
            case e2.AnnotationEditorParamsType.INK_COLOR:
              Rt._defaultColor = ot;
              break;
            case e2.AnnotationEditorParamsType.INK_OPACITY:
              Rt._defaultOpacity = ot / 100;
          }
        }
        updateParams(st, ot) {
          switch (st) {
            case e2.AnnotationEditorParamsType.INK_THICKNESS:
              nt(this, u, er).call(this, ot);
              break;
            case e2.AnnotationEditorParamsType.INK_COLOR:
              nt(this, D, rr).call(this, ot);
              break;
            case e2.AnnotationEditorParamsType.INK_OPACITY:
              nt(this, F, sr).call(this, ot);
          }
        }
        static get defaultPropertiesToUpdate() {
          return [[e2.AnnotationEditorParamsType.INK_THICKNESS, Rt._defaultThickness], [e2.AnnotationEditorParamsType.INK_COLOR, Rt._defaultColor || a2.AnnotationEditor._defaultLineColor], [e2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * Rt._defaultOpacity)]];
        }
        get propertiesToUpdate() {
          return [[e2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Rt._defaultThickness], [e2.AnnotationEditorParamsType.INK_COLOR, this.color || Rt._defaultColor || a2.AnnotationEditor._defaultLineColor], [e2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Rt._defaultOpacity))]];
        }
        rebuild() {
          super.rebuild(), this.div !== null && (this.canvas || (nt(this, B, ge).call(this), nt(this, tt, me).call(this)), this.isAttachedToDOM || (this.parent.add(this), nt(this, it, ne).call(this)), nt(this, St, ie).call(this));
        }
        remove() {
          this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, T(this, A2).disconnect(), ut(this, A2, null), super.remove());
        }
        setParent(st) {
          !this.parent && st ? this._uiManager.removeShouldRescale(this) : this.parent && st === null && this._uiManager.addShouldRescale(this), super.setParent(st);
        }
        onScaleChanging() {
          const [st, ot] = this.parentDimensions, ft = this.width * st, gt = this.height * ot;
          this.setDimensions(ft, gt);
        }
        enableEditMode() {
          !T(this, I2) && this.canvas !== null && (super.enableEditMode(), this.div.draggable = false, this.canvas.addEventListener("pointerdown", T(this, M)));
        }
        disableEditMode() {
          this.isInEditMode() && this.canvas !== null && (super.disableEditMode(), this.div.draggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", T(this, M)));
        }
        onceAdded() {
          this.div.draggable = !this.isEmpty();
        }
        isEmpty() {
          return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
        }
        commit() {
          T(this, I2) || (super.commit(), this.isEditing = false, this.disableEditMode(), this.setInForeground(), ut(this, I2, true), this.div.classList.add("disabled"), nt(this, St, ie).call(this, true), this.parent.addInkEditorIfNeeded(true), this.parent.moveEditorInDOM(this), this.div.focus({ preventScroll: true }));
        }
        focusin(st) {
          super.focusin(st), this.enableEditMode();
        }
        canvasPointerdown(st) {
          st.button === 0 && this.isInEditMode() && !T(this, I2) && (this.setInForeground(), st.preventDefault(), st.type !== "mouse" && this.div.focus(), nt(this, f, ir).call(this, st.offsetX, st.offsetY));
        }
        canvasContextMenu(st) {
          st.preventDefault();
        }
        canvasPointermove(st) {
          st.preventDefault(), nt(this, g, De).call(this, st.offsetX, st.offsetY);
        }
        canvasPointerup(st) {
          st.preventDefault(), nt(this, R, Oe).call(this, st);
        }
        canvasPointerleave(st) {
          nt(this, R, Oe).call(this, st);
        }
        render() {
          if (this.div)
            return this.div;
          let st, ot;
          this.width && (st = this.x, ot = this.y), super.render(), Rt._l10nPromise.get("editor_ink2_aria_label").then((kt) => {
            var Tt;
            return (Tt = this.div) === null || Tt === void 0 ? void 0 : Tt.setAttribute("aria-label", kt);
          });
          const [ft, gt, bt, wt] = nt(this, q, nr).call(this);
          if (this.setAt(ft, gt, 0, 0), this.setDims(bt, wt), nt(this, B, ge).call(this), this.width) {
            const [kt, Tt] = this.parentDimensions;
            this.setAt(st * kt, ot * Tt, this.width * kt, this.height * Tt), ut(this, i2, true), nt(this, it, ne).call(this), this.setDims(this.width * kt, this.height * Tt), nt(this, lt, Kt).call(this), nt(this, Nt, Ne).call(this), this.div.classList.add("disabled");
          } else
            this.div.classList.add("editing"), this.enableEditMode();
          return nt(this, tt, me).call(this), this.div;
        }
        setDimensions(st, ot) {
          const ft = Math.round(st), gt = Math.round(ot);
          if (T(this, n2) === ft && T(this, s) === gt)
            return;
          ut(this, n2, ft), ut(this, s, gt), this.canvas.style.visibility = "hidden", T(this, p2) && Math.abs(T(this, p2) - st / ot) > 0.01 && (ot = Math.ceil(st / T(this, p2)), this.setDims(st, ot));
          const [bt, wt] = this.parentDimensions;
          this.width = st / bt, this.height = ot / wt, T(this, I2) && nt(this, ct, Ie).call(this, st, ot), nt(this, it, ne).call(this), nt(this, lt, Kt).call(this), this.canvas.style.visibility = "visible", this.fixDims();
        }
        static deserialize(st, ot, ft) {
          var Lt, jt;
          const gt = super.deserialize(st, ot, ft);
          gt.thickness = st.thickness, gt.color = e2.Util.makeHexColor(...st.color), gt.opacity = st.opacity;
          const [bt, wt] = gt.pageDimensions, kt = gt.width * bt, Tt = gt.height * wt, Ot = gt.parentScale, Dt = st.thickness / 2;
          ut(gt, p2, kt / Tt), ut(gt, I2, true), ut(gt, n2, Math.round(kt)), ut(gt, s, Math.round(Tt));
          for (const { bezier: Bt } of st.paths) {
            const zt = [];
            gt.paths.push(zt);
            let Wt = Ot * (Bt[0] - Dt), Gt = Ot * (Tt - Bt[1] - Dt);
            for (let Vt = 2, le = Bt.length; Vt < le; Vt += 6) {
              const ce = Ot * (Bt[Vt] - Dt), he = Ot * (Tt - Bt[Vt + 1] - Dt), de = Ot * (Bt[Vt + 2] - Dt), mr = Ot * (Tt - Bt[Vt + 3] - Dt), Ue = Ot * (Bt[Vt + 4] - Dt), qe = Ot * (Tt - Bt[Vt + 5] - Dt);
              zt.push([[Wt, Gt], [ce, he], [de, mr], [Ue, qe]]), Wt = Ue, Gt = qe;
            }
            const ee = nt(this, yt, dr).call(this, zt);
            gt.bezierPath2D.push(ee);
          }
          const qt = nt(Lt = gt, at, Le).call(Lt);
          return ut(gt, l2, Math.max(w2, qt[2] - qt[0])), ut(gt, h2, Math.max(w2, qt[3] - qt[1])), nt(jt = gt, ct, Ie).call(jt, kt, Tt), gt;
        }
        serialize() {
          if (this.isEmpty())
            return null;
          const st = this.getRect(0, 0), ot = this.rotation % 180 == 0 ? st[3] - st[1] : st[2] - st[0], ft = a2.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
          return { annotationType: e2.AnnotationEditorType.INK, color: ft, thickness: this.thickness, opacity: this.opacity, paths: nt(this, Ct, ur).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, ot), pageIndex: this.pageIndex, rect: st, rotation: this.rotation };
        }
      };
      let O = Rt;
      p2 = /* @__PURE__ */ new WeakMap(), h2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), c2 = /* @__PURE__ */ new WeakMap(), b2 = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap(), m2 = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap(), x2 = /* @__PURE__ */ new WeakMap(), I2 = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap(), i2 = /* @__PURE__ */ new WeakMap(), A2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakSet(), er = function(st) {
        const ot = this.thickness;
        this.addCommands({ cmd: () => {
          this.thickness = st, nt(this, St, ie).call(this);
        }, undo: () => {
          this.thickness = ot, nt(this, St, ie).call(this);
        }, mustExec: true, type: e2.AnnotationEditorParamsType.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true });
      }, D = /* @__PURE__ */ new WeakSet(), rr = function(st) {
        const ot = this.color;
        this.addCommands({ cmd: () => {
          this.color = st, nt(this, lt, Kt).call(this);
        }, undo: () => {
          this.color = ot, nt(this, lt, Kt).call(this);
        }, mustExec: true, type: e2.AnnotationEditorParamsType.INK_COLOR, overwriteIfSameType: true, keepUndo: true });
      }, F = /* @__PURE__ */ new WeakSet(), sr = function(st) {
        st /= 100;
        const ot = this.opacity;
        this.addCommands({ cmd: () => {
          this.opacity = st, nt(this, lt, Kt).call(this);
        }, undo: () => {
          this.opacity = ot, nt(this, lt, Kt).call(this);
        }, mustExec: true, type: e2.AnnotationEditorParamsType.INK_OPACITY, overwriteIfSameType: true, keepUndo: true });
      }, q = /* @__PURE__ */ new WeakSet(), nr = function() {
        const { parentRotation: st, parentDimensions: [ot, ft] } = this;
        switch (st) {
          case 90:
            return [0, ft, ft, ot];
          case 180:
            return [ot, ft, ot, ft];
          case 270:
            return [ot, 0, ft, ot];
          default:
            return [0, 0, ot, ft];
        }
      }, $ = /* @__PURE__ */ new WeakSet(), Fe = function() {
        const { ctx: st, color: ot, opacity: ft, thickness: gt, parentScale: bt, scaleFactor: wt } = this;
        st.lineWidth = gt * bt / wt, st.lineCap = "round", st.lineJoin = "round", st.miterLimit = 10, st.strokeStyle = `${ot}${(0, y.opacityToHex)(ft)}`;
      }, f = /* @__PURE__ */ new WeakSet(), ir = function(st, ot) {
        this.canvas.addEventListener("contextmenu", T(this, c2)), this.canvas.addEventListener("pointerleave", T(this, L2)), this.canvas.addEventListener("pointermove", T(this, b2)), this.canvas.addEventListener("pointerup", T(this, m2)), this.canvas.removeEventListener("pointerdown", T(this, M)), this.isEditing = true, T(this, i2) || (ut(this, i2, true), nt(this, it, ne).call(this), this.thickness || (this.thickness = Rt._defaultThickness), this.color || (this.color = Rt._defaultColor || a2.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Rt._defaultOpacity)), this.currentPath.push([st, ot]), ut(this, v, false), nt(this, $, Fe).call(this), ut(this, r, () => {
          nt(this, W, lr).call(this), T(this, r) && window.requestAnimationFrame(T(this, r));
        }), window.requestAnimationFrame(T(this, r));
      }, g = /* @__PURE__ */ new WeakSet(), De = function(st, ot) {
        const [ft, gt] = this.currentPath.at(-1);
        if (this.currentPath.length > 1 && st === ft && ot === gt)
          return;
        const bt = this.currentPath;
        let wt = T(this, x2);
        bt.push([st, ot]), ut(this, v, true), bt.length <= 2 ? (wt.moveTo(...bt[0]), wt.lineTo(st, ot)) : (bt.length === 3 && (ut(this, x2, wt = new Path2D()), wt.moveTo(...bt[0])), nt(this, K, cr).call(this, wt, ...bt.at(-3), ...bt.at(-2), st, ot));
      }, U = /* @__PURE__ */ new WeakSet(), ar = function() {
        if (this.currentPath.length === 0)
          return;
        const st = this.currentPath.at(-1);
        T(this, x2).lineTo(...st);
      }, G = /* @__PURE__ */ new WeakSet(), or = function(st, ot) {
        ut(this, r, null), st = Math.min(Math.max(st, 0), this.canvas.width), ot = Math.min(Math.max(ot, 0), this.canvas.height), nt(this, g, De).call(this, st, ot), nt(this, U, ar).call(this);
        let ft;
        if (this.currentPath.length !== 1)
          ft = nt(this, Z, hr).call(this);
        else {
          const wt = [st, ot];
          ft = [[wt, wt.slice(), wt.slice(), wt]];
        }
        const gt = T(this, x2), bt = this.currentPath;
        this.currentPath = [], ut(this, x2, new Path2D()), this.addCommands({ cmd: () => {
          this.allRawPaths.push(bt), this.paths.push(ft), this.bezierPath2D.push(gt), this.rebuild();
        }, undo: () => {
          this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (nt(this, B, ge).call(this), nt(this, tt, me).call(this)), nt(this, St, ie).call(this));
        }, mustExec: true });
      }, W = /* @__PURE__ */ new WeakSet(), lr = function() {
        if (!T(this, v))
          return;
        ut(this, v, false), Math.ceil(this.thickness * this.parentScale);
        const st = this.currentPath.slice(-3), ot = st.map((bt) => bt[0]), ft = st.map((bt) => bt[1]), { ctx: gt } = (Math.min(...ot), Math.max(...ot), Math.min(...ft), Math.max(...ft), this);
        gt.save(), gt.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (const bt of this.bezierPath2D)
          gt.stroke(bt);
        gt.stroke(T(this, x2)), gt.restore();
      }, K = /* @__PURE__ */ new WeakSet(), cr = function(st, ot, ft, gt, bt, wt, kt) {
        const Tt = (ot + gt) / 2, Ot = (ft + bt) / 2, Dt = (gt + wt) / 2, qt = (bt + kt) / 2;
        st.bezierCurveTo(Tt + 2 * (gt - Tt) / 3, Ot + 2 * (bt - Ot) / 3, Dt + 2 * (gt - Dt) / 3, qt + 2 * (bt - qt) / 3, Dt, qt);
      }, Z = /* @__PURE__ */ new WeakSet(), hr = function() {
        const st = this.currentPath;
        if (st.length <= 2)
          return [[st[0], st[0], st.at(-1), st.at(-1)]];
        const ot = [];
        let ft, [gt, bt] = st[0];
        for (ft = 1; ft < st.length - 2; ft++) {
          const [Lt, jt] = st[ft], [Bt, zt] = st[ft + 1], Wt = (Lt + Bt) / 2, Gt = (jt + zt) / 2, ee = [gt + 2 * (Lt - gt) / 3, bt + 2 * (jt - bt) / 3], Vt = [Wt + 2 * (Lt - Wt) / 3, Gt + 2 * (jt - Gt) / 3];
          ot.push([[gt, bt], ee, Vt, [Wt, Gt]]), [gt, bt] = [Wt, Gt];
        }
        const [wt, kt] = st[ft], [Tt, Ot] = st[ft + 1], Dt = [gt + 2 * (wt - gt) / 3, bt + 2 * (kt - bt) / 3], qt = [Tt + 2 * (wt - Tt) / 3, Ot + 2 * (kt - Ot) / 3];
        return ot.push([[gt, bt], Dt, qt, [Tt, Ot]]), ot;
      }, lt = /* @__PURE__ */ new WeakSet(), Kt = function() {
        if (this.isEmpty()) {
          nt(this, ht, ve).call(this);
          return;
        }
        nt(this, $, Fe).call(this);
        const { canvas: st, ctx: ot } = this;
        ot.setTransform(1, 0, 0, 1, 0, 0), ot.clearRect(0, 0, st.width, st.height), nt(this, ht, ve).call(this);
        for (const ft of this.bezierPath2D)
          ot.stroke(ft);
      }, R = /* @__PURE__ */ new WeakSet(), Oe = function(st) {
        this.canvas.removeEventListener("pointerleave", T(this, L2)), this.canvas.removeEventListener("pointermove", T(this, b2)), this.canvas.removeEventListener("pointerup", T(this, m2)), this.canvas.addEventListener("pointerdown", T(this, M)), setTimeout(() => {
          this.canvas.removeEventListener("contextmenu", T(this, c2));
        }, 10), nt(this, G, or).call(this, st.offsetX, st.offsetY), this.addToAnnotationStorage(), this.setInBackground();
      }, B = /* @__PURE__ */ new WeakSet(), ge = function() {
        this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", Rt._l10nPromise.get("editor_ink_canvas_aria_label").then((st) => {
          var ot;
          return (ot = this.canvas) === null || ot === void 0 ? void 0 : ot.setAttribute("aria-label", st);
        }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
      }, tt = /* @__PURE__ */ new WeakSet(), me = function() {
        ut(this, A2, new ResizeObserver((st) => {
          const ot = st[0].contentRect;
          ot.width && ot.height && this.setDimensions(ot.width, ot.height);
        })), T(this, A2).observe(this.div);
      }, it = /* @__PURE__ */ new WeakSet(), ne = function() {
        if (!T(this, i2))
          return;
        const [st, ot] = this.parentDimensions;
        this.canvas.width = Math.ceil(this.width * st), this.canvas.height = Math.ceil(this.height * ot), nt(this, ht, ve).call(this);
      }, ct = /* @__PURE__ */ new WeakSet(), Ie = function(st, ot) {
        const ft = nt(this, Et, be).call(this), gt = (st - ft) / T(this, l2), bt = (ot - ft) / T(this, h2);
        this.scaleFactor = Math.min(gt, bt);
      }, ht = /* @__PURE__ */ new WeakSet(), ve = function() {
        const st = nt(this, Et, be).call(this) / 2;
        this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + st, this.translationY * this.scaleFactor + st);
      }, yt = /* @__PURE__ */ new WeakSet(), dr = function(st) {
        const ot = new Path2D();
        for (let ft = 0, gt = st.length; ft < gt; ft++) {
          const [bt, wt, kt, Tt] = st[ft];
          ft === 0 && ot.moveTo(...bt), ot.bezierCurveTo(wt[0], wt[1], kt[0], kt[1], Tt[0], Tt[1]);
        }
        return ot;
      }, Ct = /* @__PURE__ */ new WeakSet(), ur = function(st, ot, ft, gt) {
        const bt = [], wt = this.thickness / 2;
        let kt, Tt;
        for (const Ot of this.paths) {
          kt = [], Tt = [];
          for (let Dt = 0, qt = Ot.length; Dt < qt; Dt++) {
            const [Lt, jt, Bt, zt] = Ot[Dt], Wt = st * (Lt[0] + ot) + wt, Gt = gt - st * (Lt[1] + ft) - wt, ee = st * (jt[0] + ot) + wt, Vt = gt - st * (jt[1] + ft) - wt, le = st * (Bt[0] + ot) + wt, ce = gt - st * (Bt[1] + ft) - wt, he = st * (zt[0] + ot) + wt, de = gt - st * (zt[1] + ft) - wt;
            Dt === 0 && (kt.push(Wt, Gt), Tt.push(Wt, Gt)), kt.push(ee, Vt, le, ce, he, de), nt(this, pt, pr).call(this, Wt, Gt, ee, Vt, le, ce, he, de, 4, Tt);
          }
          bt.push({ bezier: kt, points: Tt });
        }
        return bt;
      }, pt = /* @__PURE__ */ new WeakSet(), pr = function(st, ot, ft, gt, bt, wt, kt, Tt, Ot, Dt) {
        if (nt(this, Mt, fr).call(this, st, ot, ft, gt, bt, wt, kt, Tt))
          Dt.push(kt, Tt);
        else {
          for (let qt = 1; qt < Ot - 1; qt++) {
            const Lt = qt / Ot, jt = 1 - Lt;
            let Bt = Lt * st + jt * ft, zt = Lt * ot + jt * gt, Wt = Lt * ft + jt * bt, Gt = Lt * gt + jt * wt;
            Bt = Lt * Bt + jt * Wt, zt = Lt * zt + jt * Gt, Wt = Lt * Wt + jt * (Lt * bt + jt * kt), Gt = Lt * Gt + jt * (Lt * wt + jt * Tt), Bt = Lt * Bt + jt * Wt, zt = Lt * zt + jt * Gt, Dt.push(Bt, zt);
          }
          Dt.push(kt, Tt);
        }
      }, Mt = /* @__PURE__ */ new WeakSet(), fr = function(st, ot, ft, gt, bt, wt, kt, Tt) {
        const Ot = (3 * ft - 2 * st - kt) ** 2, Dt = (3 * gt - 2 * ot - Tt) ** 2, qt = (3 * bt - st - 2 * kt) ** 2, Lt = (3 * wt - ot - 2 * Tt) ** 2;
        return Math.max(Ot, qt) + Math.max(Dt, Lt) <= 10;
      }, at = /* @__PURE__ */ new WeakSet(), Le = function() {
        let st = 1 / 0, ot = -1 / 0, ft = 1 / 0, gt = -1 / 0;
        for (const bt of this.paths)
          for (const [wt, kt, Tt, Ot] of bt) {
            const Dt = e2.Util.bezierBoundingBox(...wt, ...kt, ...Tt, ...Ot);
            st = Math.min(st, Dt[0]), ft = Math.min(ft, Dt[1]), ot = Math.max(ot, Dt[2]), gt = Math.max(gt, Dt[3]);
          }
        return [st, ft, ot, gt];
      }, Et = /* @__PURE__ */ new WeakSet(), be = function() {
        return T(this, I2) ? Math.ceil(this.thickness * this.parentScale) : 0;
      }, St = /* @__PURE__ */ new WeakSet(), ie = function() {
        let st = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
        if (this.isEmpty())
          return;
        if (!T(this, I2)) {
          nt(this, lt, Kt).call(this);
          return;
        }
        const ot = nt(this, at, Le).call(this), ft = nt(this, Et, be).call(this);
        ut(this, l2, Math.max(w2, ot[2] - ot[0])), ut(this, h2, Math.max(w2, ot[3] - ot[1]));
        const gt = Math.ceil(ft + T(this, l2) * this.scaleFactor), bt = Math.ceil(ft + T(this, h2) * this.scaleFactor), [wt, kt] = this.parentDimensions;
        this.width = gt / wt, this.height = bt / kt, ut(this, p2, gt / bt), nt(this, Nt, Ne).call(this);
        const Tt = this.translationX, Ot = this.translationY;
        this.translationX = -ot[0], this.translationY = -ot[1], nt(this, it, ne).call(this), nt(this, lt, Kt).call(this), ut(this, n2, gt), ut(this, s, bt), this.setDims(gt, bt);
        const Dt = st ? ft / this.scaleFactor / 2 : 0;
        this.translate(Tt - this.translationX - Dt, Ot - this.translationY - Dt);
      }, Nt = /* @__PURE__ */ new WeakSet(), Ne = function() {
        const { style: st } = this.div;
        T(this, p2) >= 1 ? (st.minHeight = "16px", st.minWidth = `${Math.round(T(this, p2) * w2)}px`) : (st.minWidth = "16px", st.minHeight = `${Math.round(w2 / T(this, p2))}px`);
      }, et(O, yt), It(O, "_defaultColor", null), It(O, "_defaultOpacity", 1), It(O, "_defaultThickness", 1), It(O, "_l10nPromise"), It(O, "_type", "ink"), d2.InkEditor = O;
    }, (k2, d2, t2) => {
      var U, Zt, G, gr, X, je, H, Be;
      Object.defineProperty(d2, "__esModule", { value: true }), d2.AnnotationLayer = void 0;
      var e2 = t2(1), a2 = t2(142), y = t2(139), w2 = t2(166), O = t2(167);
      const p2 = 1e3, h2 = /* @__PURE__ */ new WeakSet();
      function l2(lt) {
        return { width: lt[2] - lt[0], height: lt[3] - lt[1] };
      }
      class c2 {
        static create(E) {
          switch (E.data.annotationType) {
            case e2.AnnotationType.LINK:
              return new L2(E);
            case e2.AnnotationType.TEXT:
              return new m2(E);
            case e2.AnnotationType.WIDGET:
              switch (E.data.fieldType) {
                case "Tx":
                  return new x2(E);
                case "Btn":
                  return E.data.radioButton ? new v(E) : E.data.checkBox ? new I2(E) : new i2(E);
                case "Ch":
                  return new A2(E);
              }
              return new M(E);
            case e2.AnnotationType.POPUP:
              return new n2(E);
            case e2.AnnotationType.FREETEXT:
              return new r(E);
            case e2.AnnotationType.LINE:
              return new u(E);
            case e2.AnnotationType.SQUARE:
              return new C(E);
            case e2.AnnotationType.CIRCLE:
              return new D(E);
            case e2.AnnotationType.POLYLINE:
              return new o(E);
            case e2.AnnotationType.CARET:
              return new z(E);
            case e2.AnnotationType.INK:
              return new q(E);
            case e2.AnnotationType.POLYGON:
              return new F(E);
            case e2.AnnotationType.HIGHLIGHT:
              return new J(E);
            case e2.AnnotationType.UNDERLINE:
              return new $(E);
            case e2.AnnotationType.SQUIGGLY:
              return new S(E);
            case e2.AnnotationType.STRIKEOUT:
              return new f(E);
            case e2.AnnotationType.STAMP:
              return new P(E);
            case e2.AnnotationType.FILEATTACHMENT:
              return new g(E);
            default:
              return new b2(E);
          }
        }
      }
      class b2 {
        constructor(E) {
          let { isRenderable: R = false, ignoreBorder: j = false, createQuadrilaterals: B = false } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this.isRenderable = R, this.data = E.data, this.layer = E.layer, this.page = E.page, this.viewport = E.viewport, this.linkService = E.linkService, this.downloadManager = E.downloadManager, this.imageResourcesPath = E.imageResourcesPath, this.renderForms = E.renderForms, this.svgFactory = E.svgFactory, this.annotationStorage = E.annotationStorage, this.enableScripting = E.enableScripting, this.hasJSActions = E.hasJSActions, this._fieldObjects = E.fieldObjects, R && (this.container = this._createContainer(j)), B && (this.quadrilaterals = this._createQuadrilaterals(j));
        }
        _createContainer() {
          let E = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          const { data: R, page: j, viewport: B } = this, Y = document.createElement("section");
          Y.setAttribute("data-annotation-id", R.id), R.noRotate && Y.classList.add("norotate");
          const { pageWidth: tt, pageHeight: rt, pageX: it, pageY: At } = B.rawDims, { width: ct, height: vt } = l2(R.rect), ht = e2.Util.normalizeRect([R.rect[0], j.view[3] - R.rect[1] + j.view[1], R.rect[2], j.view[3] - R.rect[3] + j.view[1]]);
          if (!E && R.borderStyle.width > 0) {
            Y.style.borderWidth = `${R.borderStyle.width}px`;
            const yt = R.borderStyle.horizontalCornerRadius, _t = R.borderStyle.verticalCornerRadius;
            if (yt > 0 || _t > 0) {
              const Q = `calc(${yt}px * var(--scale-factor)) / calc(${_t}px * var(--scale-factor))`;
              Y.style.borderRadius = Q;
            } else if (this instanceof v) {
              const Q = `calc(${ct}px * var(--scale-factor)) / calc(${vt}px * var(--scale-factor))`;
              Y.style.borderRadius = Q;
            }
            switch (R.borderStyle.style) {
              case e2.AnnotationBorderStyleType.SOLID:
                Y.style.borderStyle = "solid";
                break;
              case e2.AnnotationBorderStyleType.DASHED:
                Y.style.borderStyle = "dashed";
                break;
              case e2.AnnotationBorderStyleType.BEVELED:
                (0, e2.warn)("Unimplemented border style: beveled");
                break;
              case e2.AnnotationBorderStyleType.INSET:
                (0, e2.warn)("Unimplemented border style: inset");
                break;
              case e2.AnnotationBorderStyleType.UNDERLINE:
                Y.style.borderBottomStyle = "solid";
            }
            const Ct = R.borderColor || null;
            Ct ? Y.style.borderColor = e2.Util.makeHexColor(0 | Ct[0], 0 | Ct[1], 0 | Ct[2]) : Y.style.borderWidth = 0;
          }
          Y.style.left = 100 * (ht[0] - it) / tt + "%", Y.style.top = 100 * (ht[1] - At) / rt + "%";
          const { rotation: mt } = R;
          return R.hasOwnCanvas || mt === 0 ? (Y.style.width = 100 * ct / tt + "%", Y.style.height = 100 * vt / rt + "%") : this.setRotation(mt, Y), Y;
        }
        setRotation(E) {
          let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.container;
          const { pageWidth: j, pageHeight: B } = this.viewport.rawDims, { width: Y, height: tt } = l2(this.data.rect);
          let rt, it;
          E % 180 == 0 ? (rt = 100 * Y / j, it = 100 * tt / B) : (rt = 100 * tt / j, it = 100 * Y / B), R.style.width = `${rt}%`, R.style.height = `${it}%`, R.setAttribute("data-main-rotation", (360 - E) % 360);
        }
        get _commonActions() {
          const E = (R, j, B) => {
            const Y = B.detail[R];
            B.target.style[j] = w2.ColorConverters[`${Y[0]}_HTML`](Y.slice(1));
          };
          return (0, e2.shadow)(this, "_commonActions", { display: (R) => {
            const j = R.detail.display % 2 == 1;
            this.container.style.visibility = j ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { hidden: j, print: R.detail.display === 0 || R.detail.display === 3 });
          }, print: (R) => {
            this.annotationStorage.setValue(this.data.id, { print: R.detail.print });
          }, hidden: (R) => {
            this.container.style.visibility = R.detail.hidden ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { hidden: R.detail.hidden });
          }, focus: (R) => {
            setTimeout(() => R.target.focus({ preventScroll: false }), 0);
          }, userName: (R) => {
            R.target.title = R.detail.userName;
          }, readonly: (R) => {
            R.detail.readonly ? R.target.setAttribute("readonly", "") : R.target.removeAttribute("readonly");
          }, required: (R) => {
            this._setRequired(R.target, R.detail.required);
          }, bgColor: (R) => {
            E("bgColor", "backgroundColor", R);
          }, fillColor: (R) => {
            E("fillColor", "backgroundColor", R);
          }, fgColor: (R) => {
            E("fgColor", "color", R);
          }, textColor: (R) => {
            E("textColor", "color", R);
          }, borderColor: (R) => {
            E("borderColor", "borderColor", R);
          }, strokeColor: (R) => {
            E("strokeColor", "borderColor", R);
          }, rotation: (R) => {
            const j = R.detail.rotation;
            this.setRotation(j), this.annotationStorage.setValue(this.data.id, { rotation: j });
          } });
        }
        _dispatchEventFromSandbox(E, R) {
          const j = this._commonActions;
          for (const B of Object.keys(R.detail)) {
            const Y = E[B] || j[B];
            Y == null || Y(R);
          }
        }
        _setDefaultPropertiesFromJS(E) {
          if (!this.enableScripting)
            return;
          const R = this.annotationStorage.getRawValue(this.data.id);
          if (!R)
            return;
          const j = this._commonActions;
          for (const [B, Y] of Object.entries(R)) {
            const tt = j[B];
            tt && (tt({ detail: { [B]: Y }, target: E }), delete R[B]);
          }
        }
        _createQuadrilaterals() {
          let E = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          if (!this.data.quadPoints)
            return null;
          const R = [], j = this.data.rect;
          for (const B of this.data.quadPoints)
            this.data.rect = [B[2].x, B[2].y, B[1].x, B[1].y], R.push(this._createContainer(E));
          return this.data.rect = j, R;
        }
        _createPopup(E, R) {
          let j = this.container;
          this.quadrilaterals && (E || (E = this.quadrilaterals), j = this.quadrilaterals[0]), E || ((E = document.createElement("div")).classList.add("popupTriggerArea"), j.append(E));
          const B = new s({ container: j, trigger: E, color: R.color, titleObj: R.titleObj, modificationDate: R.modificationDate, contentsObj: R.contentsObj, richText: R.richText, hideWrapper: true }).render();
          B.style.left = "100%", j.append(B);
        }
        _renderQuadrilaterals(E) {
          for (const R of this.quadrilaterals)
            R.classList.add(E);
          return this.quadrilaterals;
        }
        render() {
          (0, e2.unreachable)("Abstract method `AnnotationElement.render` called");
        }
        _getElementsByName(E) {
          let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          const j = [];
          if (this._fieldObjects) {
            const B = this._fieldObjects[E];
            if (B)
              for (const { page: Y, id: tt, exportValues: rt } of B) {
                if (Y === -1 || tt === R)
                  continue;
                const it = typeof rt == "string" ? rt : null, At = document.querySelector(`[data-element-id="${tt}"]`);
                !At || h2.has(At) ? j.push({ id: tt, exportValue: it, domElement: At }) : (0, e2.warn)(`_getElementsByName - element not allowed: ${tt}`);
              }
            return j;
          }
          for (const B of document.getElementsByName(E)) {
            const { exportValue: Y } = B, tt = B.getAttribute("data-element-id");
            tt !== R && h2.has(B) && j.push({ id: tt, exportValue: Y, domElement: B });
          }
          return j;
        }
      }
      class L2 extends b2 {
        constructor(R) {
          let j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          super(R, { isRenderable: true, ignoreBorder: !(j == null || !j.ignoreBorder), createQuadrilaterals: true });
          et(this, U);
          et(this, G);
          this.isTooltipOnly = R.data.isTooltipOnly;
        }
        render() {
          const { data: R, linkService: j } = this, B = document.createElement("a");
          B.setAttribute("data-element-id", R.id);
          let Y = false;
          return R.url ? (j.addLinkAttributes(B, R.url, R.newWindow), Y = true) : R.action ? (this._bindNamedAction(B, R.action), Y = true) : R.attachment ? (this._bindAttachment(B, R.attachment), Y = true) : R.setOCGState ? (nt(this, G, gr).call(this, B, R.setOCGState), Y = true) : R.dest ? (this._bindLink(B, R.dest), Y = true) : (R.actions && (R.actions.Action || R.actions["Mouse Up"] || R.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(B, R), Y = true), R.resetForm ? (this._bindResetFormAction(B, R.resetForm), Y = true) : this.isTooltipOnly && !Y && (this._bindLink(B, ""), Y = true)), this.quadrilaterals ? this._renderQuadrilaterals("linkAnnotation").map((tt, rt) => {
            const it = rt === 0 ? B : B.cloneNode();
            return tt.append(it), tt;
          }) : (this.container.classList.add("linkAnnotation"), Y && this.container.append(B), this.container);
        }
        _bindLink(R, j) {
          R.href = this.linkService.getDestinationHash(j), R.onclick = () => (j && this.linkService.goToDestination(j), false), (j || j === "") && nt(this, U, Zt).call(this);
        }
        _bindNamedAction(R, j) {
          R.href = this.linkService.getAnchorUrl(""), R.onclick = () => (this.linkService.executeNamedAction(j), false), nt(this, U, Zt).call(this);
        }
        _bindAttachment(R, j) {
          R.href = this.linkService.getAnchorUrl(""), R.onclick = () => {
            var B;
            return (B = this.downloadManager) === null || B === void 0 || B.openOrDownloadData(this.container, j.content, j.filename), false;
          }, nt(this, U, Zt).call(this);
        }
        _bindJSAction(R, j) {
          R.href = this.linkService.getAnchorUrl("");
          const B = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
          for (const Y of Object.keys(j.actions)) {
            const tt = B.get(Y);
            tt && (R[tt] = () => {
              var rt;
              return (rt = this.linkService.eventBus) === null || rt === void 0 || rt.dispatch("dispatcheventinsandbox", { source: this, detail: { id: j.id, name: Y } }), false;
            });
          }
          R.onclick || (R.onclick = () => false), nt(this, U, Zt).call(this);
        }
        _bindResetFormAction(R, j) {
          const B = R.onclick;
          B || (R.href = this.linkService.getAnchorUrl("")), nt(this, U, Zt).call(this), this._fieldObjects ? R.onclick = () => {
            B == null || B();
            const { fields: Y, refs: tt, include: rt } = j, it = [];
            if (Y.length !== 0 || tt.length !== 0) {
              const ht = new Set(tt);
              for (const mt of Y) {
                const yt = this._fieldObjects[mt] || [];
                for (const { id: _t } of yt)
                  ht.add(_t);
              }
              for (const mt of Object.values(this._fieldObjects))
                for (const yt of mt)
                  ht.has(yt.id) === rt && it.push(yt);
            } else
              for (const ht of Object.values(this._fieldObjects))
                it.push(...ht);
            const At = this.annotationStorage, ct = [];
            for (const ht of it) {
              const { id: mt } = ht;
              switch (ct.push(mt), ht.type) {
                case "text": {
                  const _t = ht.defaultValue || "";
                  At.setValue(mt, { value: _t });
                  break;
                }
                case "checkbox":
                case "radiobutton": {
                  const _t = ht.defaultValue === ht.exportValues;
                  At.setValue(mt, { value: _t });
                  break;
                }
                case "combobox":
                case "listbox": {
                  const _t = ht.defaultValue || "";
                  At.setValue(mt, { value: _t });
                  break;
                }
                default:
                  continue;
              }
              const yt = document.querySelector(`[data-element-id="${mt}"]`);
              yt && (h2.has(yt) ? yt.dispatchEvent(new Event("resetform")) : (0, e2.warn)(`_bindResetFormAction - element not allowed: ${mt}`));
            }
            if (this.enableScripting) {
              var vt;
              (vt = this.linkService.eventBus) === null || vt === void 0 || vt.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: ct, name: "ResetForm" } });
            }
            return false;
          } : ((0, e2.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), B || (R.onclick = () => false));
        }
      }
      U = /* @__PURE__ */ new WeakSet(), Zt = function() {
        this.container.setAttribute("data-internal-link", "");
      }, G = /* @__PURE__ */ new WeakSet(), gr = function(R, j) {
        R.href = this.linkService.getAnchorUrl(""), R.onclick = () => (this.linkService.executeSetOCGState(j), false), nt(this, U, Zt).call(this);
      };
      class m2 extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str) });
        }
        render() {
          this.container.classList.add("textAnnotation");
          const E = document.createElement("img");
          return E.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", E.alt = "[{{type}} Annotation]", E.dataset.l10nId = "text_annotation_type", E.dataset.l10nArgs = JSON.stringify({ type: this.data.name }), this.data.hasPopup || this._createPopup(E, this.data), this.container.append(E), this.container;
        }
      }
      class M extends b2 {
        render() {
          return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
        }
        showElementAndHideCanvas(E) {
          if (this.data.hasOwnCanvas) {
            var R;
            ((R = E.previousSibling) === null || R === void 0 ? void 0 : R.nodeName) === "CANVAS" && (E.previousSibling.hidden = true), E.hidden = false;
          }
        }
        _getKeyModifier(E) {
          const { isWin: R, isMac: j } = e2.FeatureTest.platform;
          return R && E.ctrlKey || j && E.metaKey;
        }
        _setEventListener(E, R, j, B) {
          R.includes("mouse") ? E.addEventListener(R, (Y) => {
            var tt;
            (tt = this.linkService.eventBus) === null || tt === void 0 || tt.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: j, value: B(Y), shift: Y.shiftKey, modifier: this._getKeyModifier(Y) } });
          }) : E.addEventListener(R, (Y) => {
            var tt;
            (tt = this.linkService.eventBus) === null || tt === void 0 || tt.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: j, value: B(Y) } });
          });
        }
        _setEventListeners(E, R, j) {
          for (const [Y, tt] of R) {
            var B;
            (tt === "Action" || (B = this.data.actions) !== null && B !== void 0 && B[tt]) && this._setEventListener(E, Y, tt, j);
          }
        }
        _setBackgroundColor(E) {
          const R = this.data.backgroundColor || null;
          E.style.backgroundColor = R === null ? "transparent" : e2.Util.makeHexColor(R[0], R[1], R[2]);
        }
        _setTextStyle(E) {
          const R = ["left", "center", "right"], { fontColor: j } = this.data.defaultAppearanceData, B = this.data.defaultAppearanceData.fontSize || 9, Y = E.style;
          let tt;
          const rt = (it) => Math.round(10 * it) / 10;
          if (this.data.multiLine) {
            const it = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), At = it / (Math.round(it / (e2.LINE_FACTOR * B)) || 1);
            tt = Math.min(B, rt(At / e2.LINE_FACTOR));
          } else {
            const it = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
            tt = Math.min(B, rt(it / e2.LINE_FACTOR));
          }
          Y.fontSize = `calc(${tt}px * var(--scale-factor))`, Y.color = e2.Util.makeHexColor(j[0], j[1], j[2]), this.data.textAlignment !== null && (Y.textAlign = R[this.data.textAlignment]);
        }
        _setRequired(E, R) {
          R ? E.setAttribute("required", true) : E.removeAttribute("required"), E.setAttribute("aria-required", R);
        }
      }
      class x2 extends M {
        constructor(E) {
          super(E, { isRenderable: E.renderForms || !E.data.hasAppearance && !!E.data.fieldValue });
        }
        setPropertyOnSiblings(E, R, j, B) {
          const Y = this.annotationStorage;
          for (const tt of this._getElementsByName(E.name, E.id))
            tt.domElement && (tt.domElement[R] = j), Y.setValue(tt.id, { [B]: j });
        }
        render() {
          const E = this.annotationStorage, R = this.data.id;
          this.container.classList.add("textWidgetAnnotation");
          let j = null;
          if (this.renderForms) {
            var B;
            const tt = E.getValue(R, { value: this.data.fieldValue });
            let rt = tt.value || "";
            const it = E.getValue(R, { charLimit: this.data.maxLen }).charLimit;
            it && rt.length > it && (rt = rt.slice(0, it));
            let At = tt.formattedValue || ((B = this.data.textContent) === null || B === void 0 ? void 0 : B.join(`
`)) || null;
            At && this.data.comb && (At = At.replaceAll(/\s+/g, ""));
            const ct = { userValue: rt, formattedValue: At, lastCommittedValue: null, commitKey: 1 };
            this.data.multiLine ? (j = document.createElement("textarea"), j.textContent = At ?? rt, this.data.doNotScroll && (j.style.overflowY = "hidden")) : (j = document.createElement("input"), j.type = "text", j.setAttribute("value", At ?? rt), this.data.doNotScroll && (j.style.overflowX = "hidden")), this.data.hasOwnCanvas && (j.hidden = true), h2.add(j), j.setAttribute("data-element-id", R), j.disabled = this.data.readOnly, j.name = this.data.fieldName, j.tabIndex = p2, this._setRequired(j, this.data.required), it && (j.maxLength = it), j.addEventListener("input", (ht) => {
              E.setValue(R, { value: ht.target.value }), this.setPropertyOnSiblings(j, "value", ht.target.value, "value"), ct.formattedValue = null;
            }), j.addEventListener("resetform", (ht) => {
              const mt = this.data.defaultFieldValue ?? "";
              j.value = ct.userValue = mt, ct.formattedValue = null;
            });
            let vt = (ht) => {
              const { formattedValue: mt } = ct;
              mt != null && (ht.target.value = mt), ht.target.scrollLeft = 0;
            };
            if (this.enableScripting && this.hasJSActions) {
              var Y;
              j.addEventListener("focus", (mt) => {
                const { target: yt } = mt;
                ct.userValue && (yt.value = ct.userValue), ct.lastCommittedValue = yt.value, ct.commitKey = 1;
              }), j.addEventListener("updatefromsandbox", (mt) => {
                this.showElementAndHideCanvas(mt.target);
                const yt = { value(_t) {
                  ct.userValue = _t.detail.value ?? "", E.setValue(R, { value: ct.userValue.toString() }), _t.target.value = ct.userValue;
                }, formattedValue(_t) {
                  const { formattedValue: Ct } = _t.detail;
                  ct.formattedValue = Ct, Ct != null && _t.target !== document.activeElement && (_t.target.value = Ct), E.setValue(R, { formattedValue: Ct });
                }, selRange(_t) {
                  _t.target.setSelectionRange(..._t.detail.selRange);
                }, charLimit: (_t) => {
                  var Ct;
                  const { charLimit: Q } = _t.detail, { target: pt } = _t;
                  if (Q === 0) {
                    pt.removeAttribute("maxLength");
                    return;
                  }
                  pt.setAttribute("maxLength", Q);
                  let xt = ct.userValue;
                  xt && !(xt.length <= Q) && (xt = xt.slice(0, Q), pt.value = ct.userValue = xt, E.setValue(R, { value: xt }), (Ct = this.linkService.eventBus) === null || Ct === void 0 || Ct.dispatch("dispatcheventinsandbox", { source: this, detail: { id: R, name: "Keystroke", value: xt, willCommit: true, commitKey: 1, selStart: pt.selectionStart, selEnd: pt.selectionEnd } }));
                } };
                this._dispatchEventFromSandbox(yt, mt);
              }), j.addEventListener("keydown", (mt) => {
                var yt;
                ct.commitKey = 1;
                let _t = -1;
                if (mt.key === "Escape" ? _t = 0 : mt.key !== "Enter" || this.data.multiLine ? mt.key === "Tab" && (ct.commitKey = 3) : _t = 2, _t === -1)
                  return;
                const { value: Ct } = mt.target;
                ct.lastCommittedValue !== Ct && (ct.lastCommittedValue = Ct, ct.userValue = Ct, (yt = this.linkService.eventBus) === null || yt === void 0 || yt.dispatch("dispatcheventinsandbox", { source: this, detail: { id: R, name: "Keystroke", value: Ct, willCommit: true, commitKey: _t, selStart: mt.target.selectionStart, selEnd: mt.target.selectionEnd } }));
              });
              const ht = vt;
              vt = null, j.addEventListener("blur", (mt) => {
                if (!mt.relatedTarget)
                  return;
                const { value: yt } = mt.target;
                if (ct.userValue = yt, ct.lastCommittedValue !== yt) {
                  var _t;
                  (_t = this.linkService.eventBus) === null || _t === void 0 || _t.dispatch("dispatcheventinsandbox", { source: this, detail: { id: R, name: "Keystroke", value: yt, willCommit: true, commitKey: ct.commitKey, selStart: mt.target.selectionStart, selEnd: mt.target.selectionEnd } });
                }
                ht(mt);
              }), (Y = this.data.actions) !== null && Y !== void 0 && Y.Keystroke && j.addEventListener("beforeinput", (mt) => {
                var yt;
                ct.lastCommittedValue = null;
                const { data: _t, target: Ct } = mt, { value: Q, selectionStart: pt, selectionEnd: xt } = Ct;
                let Mt = pt, Ft = xt;
                switch (mt.inputType) {
                  case "deleteWordBackward": {
                    const at = Q.substring(0, pt).match(/\w*[^\w]*$/);
                    at && (Mt -= at[0].length);
                    break;
                  }
                  case "deleteWordForward": {
                    const at = Q.substring(pt).match(/^[^\w]*\w*/);
                    at && (Ft += at[0].length);
                    break;
                  }
                  case "deleteContentBackward":
                    pt === xt && (Mt -= 1);
                    break;
                  case "deleteContentForward":
                    pt === xt && (Ft += 1);
                }
                mt.preventDefault(), (yt = this.linkService.eventBus) === null || yt === void 0 || yt.dispatch("dispatcheventinsandbox", { source: this, detail: { id: R, name: "Keystroke", value: Q, change: _t || "", willCommit: false, selStart: Mt, selEnd: Ft } });
              }), this._setEventListeners(j, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (mt) => mt.target.value);
            }
            if (vt && j.addEventListener("blur", vt), this.data.comb) {
              const ht = (this.data.rect[2] - this.data.rect[0]) / it;
              j.classList.add("comb"), j.style.letterSpacing = `calc(${ht}px * var(--scale-factor) - 1ch)`;
            }
          } else
            j = document.createElement("div"), j.textContent = this.data.fieldValue, j.style.verticalAlign = "middle", j.style.display = "table-cell";
          return this._setTextStyle(j), this._setBackgroundColor(j), this._setDefaultPropertiesFromJS(j), this.container.append(j), this.container;
        }
      }
      class I2 extends M {
        constructor(E) {
          super(E, { isRenderable: E.renderForms });
        }
        render() {
          const E = this.annotationStorage, R = this.data, j = R.id;
          let B = E.getValue(j, { value: R.exportValue === R.fieldValue }).value;
          typeof B == "string" && (B = B !== "Off", E.setValue(j, { value: B })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
          const Y = document.createElement("input");
          return h2.add(Y), Y.setAttribute("data-element-id", j), Y.disabled = R.readOnly, this._setRequired(Y, this.data.required), Y.type = "checkbox", Y.name = R.fieldName, B && Y.setAttribute("checked", true), Y.setAttribute("exportValue", R.exportValue), Y.tabIndex = p2, Y.addEventListener("change", (tt) => {
            const { name: rt, checked: it } = tt.target;
            for (const At of this._getElementsByName(rt, j)) {
              const ct = it && At.exportValue === R.exportValue;
              At.domElement && (At.domElement.checked = ct), E.setValue(At.id, { value: ct });
            }
            E.setValue(j, { value: it });
          }), Y.addEventListener("resetform", (tt) => {
            const rt = R.defaultFieldValue || "Off";
            tt.target.checked = rt === R.exportValue;
          }), this.enableScripting && this.hasJSActions && (Y.addEventListener("updatefromsandbox", (tt) => {
            const rt = { value(it) {
              it.target.checked = it.detail.value !== "Off", E.setValue(j, { value: it.target.checked });
            } };
            this._dispatchEventFromSandbox(rt, tt);
          }), this._setEventListeners(Y, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (tt) => tt.target.checked)), this._setBackgroundColor(Y), this._setDefaultPropertiesFromJS(Y), this.container.append(Y), this.container;
        }
      }
      class v extends M {
        constructor(E) {
          super(E, { isRenderable: E.renderForms });
        }
        render() {
          this.container.classList.add("buttonWidgetAnnotation", "radioButton");
          const E = this.annotationStorage, R = this.data, j = R.id;
          let B = E.getValue(j, { value: R.fieldValue === R.buttonValue }).value;
          typeof B == "string" && (B = B !== R.buttonValue, E.setValue(j, { value: B }));
          const Y = document.createElement("input");
          if (h2.add(Y), Y.setAttribute("data-element-id", j), Y.disabled = R.readOnly, this._setRequired(Y, this.data.required), Y.type = "radio", Y.name = R.fieldName, B && Y.setAttribute("checked", true), Y.tabIndex = p2, Y.addEventListener("change", (tt) => {
            const { name: rt, checked: it } = tt.target;
            for (const At of this._getElementsByName(rt, j))
              E.setValue(At.id, { value: false });
            E.setValue(j, { value: it });
          }), Y.addEventListener("resetform", (tt) => {
            const rt = R.defaultFieldValue;
            tt.target.checked = rt != null && rt === R.buttonValue;
          }), this.enableScripting && this.hasJSActions) {
            const tt = R.buttonValue;
            Y.addEventListener("updatefromsandbox", (rt) => {
              const it = { value: (At) => {
                const ct = tt === At.detail.value;
                for (const vt of this._getElementsByName(At.target.name)) {
                  const ht = ct && vt.id === j;
                  vt.domElement && (vt.domElement.checked = ht), E.setValue(vt.id, { value: ht });
                }
              } };
              this._dispatchEventFromSandbox(it, rt);
            }), this._setEventListeners(Y, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (rt) => rt.target.checked);
          }
          return this._setBackgroundColor(Y), this._setDefaultPropertiesFromJS(Y), this.container.append(Y), this.container;
        }
      }
      class i2 extends L2 {
        constructor(E) {
          super(E, { ignoreBorder: E.data.hasAppearance });
        }
        render() {
          const E = super.render();
          E.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (E.title = this.data.alternativeText);
          const R = E.lastChild;
          return this.enableScripting && this.hasJSActions && R && (this._setDefaultPropertiesFromJS(R), R.addEventListener("updatefromsandbox", (j) => {
            this._dispatchEventFromSandbox({}, j);
          })), E;
        }
      }
      class A2 extends M {
        constructor(E) {
          super(E, { isRenderable: E.renderForms });
        }
        render() {
          this.container.classList.add("choiceWidgetAnnotation");
          const E = this.annotationStorage, R = this.data.id, j = E.getValue(R, { value: this.data.fieldValue }), B = document.createElement("select");
          h2.add(B), B.setAttribute("data-element-id", R), B.disabled = this.data.readOnly, this._setRequired(B, this.data.required), B.name = this.data.fieldName, B.tabIndex = p2;
          let Y = this.data.combo && this.data.options.length > 0;
          this.data.combo || (B.size = this.data.options.length, this.data.multiSelect && (B.multiple = true)), B.addEventListener("resetform", (ct) => {
            const vt = this.data.defaultFieldValue;
            for (const ht of B.options)
              ht.selected = ht.value === vt;
          });
          for (const ct of this.data.options) {
            const vt = document.createElement("option");
            vt.textContent = ct.displayValue, vt.value = ct.exportValue, j.value.includes(ct.exportValue) && (vt.setAttribute("selected", true), Y = false), B.append(vt);
          }
          let tt = null;
          if (Y) {
            const ct = document.createElement("option");
            ct.value = " ", ct.setAttribute("hidden", true), ct.setAttribute("selected", true), B.prepend(ct), tt = () => {
              ct.remove(), B.removeEventListener("input", tt), tt = null;
            }, B.addEventListener("input", tt);
          }
          const rt = (ct) => {
            const vt = ct ? "value" : "textContent", { options: ht, multiple: mt } = B;
            return mt ? Array.prototype.filter.call(ht, (yt) => yt.selected).map((yt) => yt[vt]) : ht.selectedIndex === -1 ? null : ht[ht.selectedIndex][vt];
          };
          let it = rt(false);
          const At = (ct) => {
            const vt = ct.target.options;
            return Array.prototype.map.call(vt, (ht) => ({ displayValue: ht.textContent, exportValue: ht.value }));
          };
          return this.enableScripting && this.hasJSActions ? (B.addEventListener("updatefromsandbox", (ct) => {
            const vt = { value(ht) {
              var mt;
              (mt = tt) === null || mt === void 0 || mt();
              const yt = ht.detail.value, _t = new Set(Array.isArray(yt) ? yt : [yt]);
              for (const Ct of B.options)
                Ct.selected = _t.has(Ct.value);
              E.setValue(R, { value: rt(true) }), it = rt(false);
            }, multipleSelection(ht) {
              B.multiple = true;
            }, remove(ht) {
              const mt = B.options, yt = ht.detail.remove;
              mt[yt].selected = false, B.remove(yt), mt.length > 0 && Array.prototype.findIndex.call(mt, (_t) => _t.selected) === -1 && (mt[0].selected = true), E.setValue(R, { value: rt(true), items: At(ht) }), it = rt(false);
            }, clear(ht) {
              for (; B.length !== 0; )
                B.remove(0);
              E.setValue(R, { value: null, items: [] }), it = rt(false);
            }, insert(ht) {
              const { index: mt, displayValue: yt, exportValue: _t } = ht.detail.insert, Ct = B.children[mt], Q = document.createElement("option");
              Q.textContent = yt, Q.value = _t, Ct ? Ct.before(Q) : B.append(Q), E.setValue(R, { value: rt(true), items: At(ht) }), it = rt(false);
            }, items(ht) {
              const { items: mt } = ht.detail;
              for (; B.length !== 0; )
                B.remove(0);
              for (const yt of mt) {
                const { displayValue: _t, exportValue: Ct } = yt, Q = document.createElement("option");
                Q.textContent = _t, Q.value = Ct, B.append(Q);
              }
              B.options.length > 0 && (B.options[0].selected = true), E.setValue(R, { value: rt(true), items: At(ht) }), it = rt(false);
            }, indices(ht) {
              const mt = new Set(ht.detail.indices);
              for (const yt of ht.target.options)
                yt.selected = mt.has(yt.index);
              E.setValue(R, { value: rt(true) }), it = rt(false);
            }, editable(ht) {
              ht.target.disabled = !ht.detail.editable;
            } };
            this._dispatchEventFromSandbox(vt, ct);
          }), B.addEventListener("input", (ct) => {
            var vt;
            const ht = rt(true);
            E.setValue(R, { value: ht }), ct.preventDefault(), (vt = this.linkService.eventBus) === null || vt === void 0 || vt.dispatch("dispatcheventinsandbox", { source: this, detail: { id: R, name: "Keystroke", value: it, changeEx: ht, willCommit: false, commitKey: 1, keyDown: false } });
          }), this._setEventListeners(B, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (ct) => ct.target.value)) : B.addEventListener("input", function(ct) {
            E.setValue(R, { value: rt(true) });
          }), this.data.combo && this._setTextStyle(B), this._setBackgroundColor(B), this._setDefaultPropertiesFromJS(B), this.container.append(B), this.container;
        }
      }
      const W = class extends b2 {
        constructor(E) {
          var R, j, B;
          const { data: Y } = E;
          super(E, { isRenderable: !W.IGNORE_TYPES.has(Y.parentType) && !!((R = Y.titleObj) !== null && R !== void 0 && R.str || (j = Y.contentsObj) !== null && j !== void 0 && j.str || (B = Y.richText) !== null && B !== void 0 && B.str) });
        }
        render() {
          this.container.classList.add("popupAnnotation");
          const E = this.layer.querySelectorAll(`[data-annotation-id="${this.data.parentId}"]`);
          if (E.length === 0)
            return this.container;
          const R = new s({ container: this.container, trigger: Array.from(E), color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText }), j = this.page, B = e2.Util.normalizeRect([this.data.parentRect[0], j.view[3] - this.data.parentRect[1] + j.view[1], this.data.parentRect[2], j.view[3] - this.data.parentRect[3] + j.view[1]]), Y = B[0] + this.data.parentRect[2] - this.data.parentRect[0], tt = B[1], { pageWidth: rt, pageHeight: it, pageX: At, pageY: ct } = this.viewport.rawDims;
          return this.container.style.left = 100 * (Y - At) / rt + "%", this.container.style.top = 100 * (tt - ct) / it + "%", this.container.append(R.render()), this.container;
        }
      };
      let n2 = W;
      It(n2, "IGNORE_TYPES", /* @__PURE__ */ new Set(["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"]));
      class s {
        constructor(E) {
          this.container = E.container, this.trigger = E.trigger, this.color = E.color, this.titleObj = E.titleObj, this.modificationDate = E.modificationDate, this.contentsObj = E.contentsObj, this.richText = E.richText, this.hideWrapper = E.hideWrapper || false, this.pinned = false;
        }
        render() {
          var E, R;
          const j = document.createElement("div");
          j.classList.add("popupWrapper"), this.hideElement = this.hideWrapper ? j : this.container, this.hideElement.hidden = true;
          const B = document.createElement("div");
          B.classList.add("popup");
          const Y = this.color;
          if (Y) {
            const it = 0.7 * (255 - Y[0]) + Y[0], At = 0.7 * (255 - Y[1]) + Y[1], ct = 0.7 * (255 - Y[2]) + Y[2];
            B.style.backgroundColor = e2.Util.makeHexColor(0 | it, 0 | At, 0 | ct);
          }
          const tt = document.createElement("h1");
          tt.dir = this.titleObj.dir, tt.textContent = this.titleObj.str, B.append(tt);
          const rt = a2.PDFDateString.toDateObject(this.modificationDate);
          if (rt) {
            const it = document.createElement("span");
            it.classList.add("popupDate"), it.textContent = "{{date}}, {{time}}", it.dataset.l10nId = "annotation_date_string", it.dataset.l10nArgs = JSON.stringify({ date: rt.toLocaleDateString(), time: rt.toLocaleTimeString() }), B.append(it);
          }
          if ((E = this.richText) === null || E === void 0 || !E.str || (R = this.contentsObj) !== null && R !== void 0 && R.str && this.contentsObj.str !== this.richText.str) {
            const it = this._formatContents(this.contentsObj);
            B.append(it);
          } else
            O.XfaLayer.render({ xfaHtml: this.richText.html, intent: "richText", div: B }), B.lastChild.classList.add("richText", "popupContent");
          Array.isArray(this.trigger) || (this.trigger = [this.trigger]);
          for (const it of this.trigger)
            it.addEventListener("click", this._toggle.bind(this)), it.addEventListener("mouseover", this._show.bind(this, false)), it.addEventListener("mouseout", this._hide.bind(this, false));
          return B.addEventListener("click", this._hide.bind(this, true)), j.append(B), j;
        }
        _formatContents(E) {
          let { str: R, dir: j } = E;
          const B = document.createElement("p");
          B.classList.add("popupContent"), B.dir = j;
          const Y = R.split(/(?:\r\n?|\n)/);
          for (let tt = 0, rt = Y.length; tt < rt; ++tt) {
            const it = Y[tt];
            B.append(document.createTextNode(it)), tt < rt - 1 && B.append(document.createElement("br"));
          }
          return B;
        }
        _toggle() {
          this.pinned ? this._hide(true) : this._show(true);
        }
        _show() {
          arguments.length > 0 && arguments[0] !== void 0 && arguments[0] && (this.pinned = true), this.hideElement.hidden && (this.hideElement.hidden = false, this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3);
        }
        _hide() {
          (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (this.pinned = false), !this.hideElement.hidden && !this.pinned && (this.hideElement.hidden = true, this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3);
        }
      }
      class r extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true }), this.textContent = E.data.textContent;
        }
        render() {
          if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
            const E = document.createElement("div");
            E.classList.add("annotationTextContent"), E.setAttribute("role", "comment");
            for (const R of this.textContent) {
              const j = document.createElement("span");
              j.textContent = R, E.append(j);
            }
            this.container.append(E);
          }
          return this.data.hasPopup || this._createPopup(null, this.data), this.container;
        }
      }
      class u extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true });
        }
        render() {
          this.container.classList.add("lineAnnotation");
          const E = this.data, { width: R, height: j } = l2(E.rect), B = this.svgFactory.create(R, j, true), Y = this.svgFactory.createElement("svg:line");
          return Y.setAttribute("x1", E.rect[2] - E.lineCoordinates[0]), Y.setAttribute("y1", E.rect[3] - E.lineCoordinates[1]), Y.setAttribute("x2", E.rect[2] - E.lineCoordinates[2]), Y.setAttribute("y2", E.rect[3] - E.lineCoordinates[3]), Y.setAttribute("stroke-width", E.borderStyle.width || 1), Y.setAttribute("stroke", "transparent"), Y.setAttribute("fill", "transparent"), B.append(Y), this.container.append(B), this._createPopup(Y, E), this.container;
        }
      }
      class C extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true });
        }
        render() {
          this.container.classList.add("squareAnnotation");
          const E = this.data, { width: R, height: j } = l2(E.rect), B = this.svgFactory.create(R, j, true), Y = E.borderStyle.width, tt = this.svgFactory.createElement("svg:rect");
          return tt.setAttribute("x", Y / 2), tt.setAttribute("y", Y / 2), tt.setAttribute("width", R - Y), tt.setAttribute("height", j - Y), tt.setAttribute("stroke-width", Y || 1), tt.setAttribute("stroke", "transparent"), tt.setAttribute("fill", "transparent"), B.append(tt), this.container.append(B), this._createPopup(tt, E), this.container;
        }
      }
      class D extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true });
        }
        render() {
          this.container.classList.add("circleAnnotation");
          const E = this.data, { width: R, height: j } = l2(E.rect), B = this.svgFactory.create(R, j, true), Y = E.borderStyle.width, tt = this.svgFactory.createElement("svg:ellipse");
          return tt.setAttribute("cx", R / 2), tt.setAttribute("cy", j / 2), tt.setAttribute("rx", R / 2 - Y / 2), tt.setAttribute("ry", j / 2 - Y / 2), tt.setAttribute("stroke-width", Y || 1), tt.setAttribute("stroke", "transparent"), tt.setAttribute("fill", "transparent"), B.append(tt), this.container.append(B), this._createPopup(tt, E), this.container;
        }
      }
      class o extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
        }
        render() {
          this.container.classList.add(this.containerClassName);
          const E = this.data, { width: R, height: j } = l2(E.rect), B = this.svgFactory.create(R, j, true);
          let Y = [];
          for (const rt of E.vertices) {
            const it = rt.x - E.rect[0], At = E.rect[3] - rt.y;
            Y.push(it + "," + At);
          }
          Y = Y.join(" ");
          const tt = this.svgFactory.createElement(this.svgElementName);
          return tt.setAttribute("points", Y), tt.setAttribute("stroke-width", E.borderStyle.width || 1), tt.setAttribute("stroke", "transparent"), tt.setAttribute("fill", "transparent"), B.append(tt), this.container.append(B), this._createPopup(tt, E), this.container;
        }
      }
      class F extends o {
        constructor(E) {
          super(E), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
        }
      }
      class z extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true });
        }
        render() {
          return this.container.classList.add("caretAnnotation"), this.data.hasPopup || this._createPopup(null, this.data), this.container;
        }
      }
      class q extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline";
        }
        render() {
          this.container.classList.add(this.containerClassName);
          const E = this.data, { width: R, height: j } = l2(E.rect), B = this.svgFactory.create(R, j, true);
          for (const Y of E.inkLists) {
            let tt = [];
            for (const it of Y) {
              const At = it.x - E.rect[0], ct = E.rect[3] - it.y;
              tt.push(`${At},${ct}`);
            }
            tt = tt.join(" ");
            const rt = this.svgFactory.createElement(this.svgElementName);
            rt.setAttribute("points", tt), rt.setAttribute("stroke-width", E.borderStyle.width || 1), rt.setAttribute("stroke", "transparent"), rt.setAttribute("fill", "transparent"), this._createPopup(rt, E), B.append(rt);
          }
          return this.container.append(B), this.container;
        }
      }
      class J extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true, createQuadrilaterals: true });
        }
        render() {
          return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("highlightAnnotation") : (this.container.classList.add("highlightAnnotation"), this.container);
        }
      }
      class $ extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true, createQuadrilaterals: true });
        }
        render() {
          return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("underlineAnnotation") : (this.container.classList.add("underlineAnnotation"), this.container);
        }
      }
      class S extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true, createQuadrilaterals: true });
        }
        render() {
          return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("squigglyAnnotation") : (this.container.classList.add("squigglyAnnotation"), this.container);
        }
      }
      class f extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true, createQuadrilaterals: true });
        }
        render() {
          return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("strikeoutAnnotation") : (this.container.classList.add("strikeoutAnnotation"), this.container);
        }
      }
      class P extends b2 {
        constructor(E) {
          var R, j, B;
          super(E, { isRenderable: !!(E.data.hasPopup || (R = E.data.titleObj) !== null && R !== void 0 && R.str || (j = E.data.contentsObj) !== null && j !== void 0 && j.str || (B = E.data.richText) !== null && B !== void 0 && B.str), ignoreBorder: true });
        }
        render() {
          return this.container.classList.add("stampAnnotation"), this.data.hasPopup || this._createPopup(null, this.data), this.container;
        }
      }
      class g extends b2 {
        constructor(E) {
          var R;
          super(E, { isRenderable: true });
          const { filename: j, content: B } = this.data.file;
          this.filename = (0, a2.getFilenameFromUrl)(j, true), this.content = B, (R = this.linkService.eventBus) === null || R === void 0 || R.dispatch("fileattachmentannotation", { source: this, filename: j, content: B });
        }
        render() {
          var E, R;
          this.container.classList.add("fileAttachmentAnnotation");
          let j;
          return this.data.hasAppearance ? j = document.createElement("div") : (j = document.createElement("img"), j.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(this.data.name) ? "paperclip" : "pushpin"}.svg`), j.classList.add("popupTriggerArea"), j.addEventListener("dblclick", this._download.bind(this)), !this.data.hasPopup && ((E = this.data.titleObj) !== null && E !== void 0 && E.str || (R = this.data.contentsObj) !== null && R !== void 0 && R.str || this.data.richText) && this._createPopup(j, this.data), this.container.append(j), this.container;
        }
        _download() {
          var E;
          (E = this.downloadManager) === null || E === void 0 || E.openOrDownloadData(this.container, this.content, this.filename);
        }
      }
      const dt = class {
        static render(E) {
          var it, At;
          const { annotations: R, div: j, viewport: B, accessibilityManager: Y } = E;
          (0, a2.setLayerDimensions)(j, B);
          const tt = { data: null, layer: j, page: E.page, viewport: B, linkService: E.linkService, downloadManager: E.downloadManager, imageResourcesPath: E.imageResourcesPath || "", renderForms: E.renderForms !== false, svgFactory: new a2.DOMSVGFactory(), annotationStorage: E.annotationStorage || new y.AnnotationStorage(), enableScripting: E.enableScripting === true, hasJSActions: E.hasJSActions, fieldObjects: E.fieldObjects };
          let rt = 0;
          for (const ct of R) {
            if (ct.noHTML)
              continue;
            if (ct.annotationType !== e2.AnnotationType.POPUP) {
              const { width: mt, height: yt } = l2(ct.rect);
              if (mt <= 0 || yt <= 0)
                continue;
            }
            tt.data = ct;
            const vt = c2.create(tt);
            if (!vt.isRenderable)
              continue;
            const ht = vt.render();
            if (ct.hidden && (ht.style.visibility = "hidden"), Array.isArray(ht))
              for (const mt of ht)
                mt.style.zIndex = rt++, nt(it = dt, X, je).call(it, mt, ct.id, j, Y);
            else
              ht.style.zIndex = rt++, vt instanceof n2 ? j.prepend(ht) : nt(At = dt, X, je).call(At, ht, ct.id, j, Y);
          }
          nt(this, H, Be).call(this, j, E.annotationCanvasMap);
        }
        static update(E) {
          const { annotationCanvasMap: R, div: j, viewport: B } = E;
          (0, a2.setLayerDimensions)(j, { rotation: B.rotation }), nt(this, H, Be).call(this, j, R), j.hidden = false;
        }
      };
      let _ = dt;
      X = /* @__PURE__ */ new WeakSet(), je = function(E, R, j, B) {
        const Y = E.firstChild || E;
        Y.id = `${a2.AnnotationPrefix}${R}`, j.append(E), B == null || B.moveElementInDOM(j, E, Y, false);
      }, H = /* @__PURE__ */ new WeakSet(), Be = function(E, R) {
        if (R) {
          for (const [j, B] of R) {
            const Y = E.querySelector(`[data-annotation-id="${j}"]`);
            if (!Y)
              continue;
            const { firstChild: tt } = Y;
            tt ? tt.nodeName === "CANVAS" ? tt.replaceWith(B) : tt.before(B) : Y.append(B);
          }
          R.clear();
        }
      }, et(_, X), et(_, H), d2.AnnotationLayer = _;
    }, (k2, d2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.ColorConverters = void 0;
      function t2(e2) {
        return Math.floor(255 * Math.max(0, Math.min(1, e2))).toString(16).padStart(2, "0");
      }
      d2.ColorConverters = class {
        static CMYK_G(a2) {
          let [y, w2, O, p2] = a2;
          return ["G", 1 - Math.min(1, 0.3 * y + 0.59 * O + 0.11 * w2 + p2)];
        }
        static G_CMYK(a2) {
          let [y] = a2;
          return ["CMYK", 0, 0, 0, 1 - y];
        }
        static G_RGB(a2) {
          let [y] = a2;
          return ["RGB", y, y, y];
        }
        static G_HTML(a2) {
          let [y] = a2;
          const w2 = t2(y);
          return `#${w2}${w2}${w2}`;
        }
        static RGB_G(a2) {
          let [y, w2, O] = a2;
          return ["G", 0.3 * y + 0.59 * w2 + 0.11 * O];
        }
        static RGB_HTML(a2) {
          let [y, w2, O] = a2;
          return `#${t2(y)}${t2(w2)}${t2(O)}`;
        }
        static T_HTML() {
          return "#00000000";
        }
        static CMYK_RGB(a2) {
          let [y, w2, O, p2] = a2;
          return ["RGB", 1 - Math.min(1, y + p2), 1 - Math.min(1, O + p2), 1 - Math.min(1, w2 + p2)];
        }
        static CMYK_HTML(a2) {
          const y = this.CMYK_RGB(a2).slice(1);
          return this.RGB_HTML(y);
        }
        static RGB_CMYK(a2) {
          let [y, w2, O] = a2;
          const p2 = 1 - y, h2 = 1 - w2, l2 = 1 - O;
          return ["CMYK", p2, h2, l2, Math.min(p2, h2, l2)];
        }
      };
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.XfaLayer = void 0;
      var e2 = t2(154);
      d2.XfaLayer = class {
        static setupStorage(y, w2, O, p2, h2) {
          const l2 = p2.getValue(w2, { value: null });
          switch (O.name) {
            case "textarea":
              if (l2.value !== null && (y.textContent = l2.value), h2 === "print")
                break;
              y.addEventListener("input", (c2) => {
                p2.setValue(w2, { value: c2.target.value });
              });
              break;
            case "input":
              if (O.attributes.type === "radio" || O.attributes.type === "checkbox") {
                if (l2.value === O.attributes.xfaOn ? y.setAttribute("checked", true) : l2.value === O.attributes.xfaOff && y.removeAttribute("checked"), h2 === "print")
                  break;
                y.addEventListener("change", (c2) => {
                  p2.setValue(w2, { value: c2.target.checked ? c2.target.getAttribute("xfaOn") : c2.target.getAttribute("xfaOff") });
                });
              } else {
                if (l2.value !== null && y.setAttribute("value", l2.value), h2 === "print")
                  break;
                y.addEventListener("input", (c2) => {
                  p2.setValue(w2, { value: c2.target.value });
                });
              }
              break;
            case "select":
              if (l2.value !== null)
                for (const c2 of O.children)
                  c2.attributes.value === l2.value && (c2.attributes.selected = true);
              y.addEventListener("input", (c2) => {
                const b2 = c2.target.options, L2 = b2.selectedIndex === -1 ? "" : b2[b2.selectedIndex].value;
                p2.setValue(w2, { value: L2 });
              });
          }
        }
        static setAttributes(y) {
          let { html: w2, element: O, storage: p2 = null, intent: h2, linkService: l2 } = y;
          const { attributes: c2 } = O, b2 = w2 instanceof HTMLAnchorElement;
          c2.type === "radio" && (c2.name = `${c2.name}-${h2}`);
          for (const [L2, m2] of Object.entries(c2))
            if (m2 != null)
              switch (L2) {
                case "class":
                  m2.length && w2.setAttribute(L2, m2.join(" "));
                  break;
                case "dataId":
                  break;
                case "id":
                  w2.setAttribute("data-element-id", m2);
                  break;
                case "style":
                  Object.assign(w2.style, m2);
                  break;
                case "textContent":
                  w2.textContent = m2;
                  break;
                default:
                  (!b2 || L2 !== "href" && L2 !== "newWindow") && w2.setAttribute(L2, m2);
              }
          b2 && l2.addLinkAttributes(w2, c2.href, c2.newWindow), p2 && c2.dataId && this.setupStorage(w2, c2.dataId, O, p2);
        }
        static render(y) {
          const w2 = y.annotationStorage, O = y.linkService, p2 = y.xfaHtml, h2 = y.intent || "display", l2 = document.createElement(p2.name);
          p2.attributes && this.setAttributes({ html: l2, element: p2, intent: h2, linkService: O });
          const c2 = [[p2, -1, l2]], b2 = y.div;
          if (b2.append(l2), y.viewport) {
            const M = `matrix(${y.viewport.transform.join(",")})`;
            b2.style.transform = M;
          }
          h2 !== "richText" && b2.setAttribute("class", "xfaLayer xfaFont");
          const L2 = [];
          for (; c2.length > 0; ) {
            var m2;
            const [M, x2, I2] = c2.at(-1);
            if (x2 + 1 === M.children.length) {
              c2.pop();
              continue;
            }
            const v = M.children[++c2.at(-1)[1]];
            if (v === null)
              continue;
            const { name: i2 } = v;
            if (i2 === "#text") {
              const n2 = document.createTextNode(v.value);
              L2.push(n2), I2.append(n2);
              continue;
            }
            let A2;
            if (A2 = v != null && (m2 = v.attributes) !== null && m2 !== void 0 && m2.xmlns ? document.createElementNS(v.attributes.xmlns, i2) : document.createElement(i2), I2.append(A2), v.attributes && this.setAttributes({ html: A2, element: v, storage: w2, intent: h2, linkService: O }), v.children && v.children.length > 0)
              c2.push([v, -1, A2]);
            else if (v.value) {
              const n2 = document.createTextNode(v.value);
              e2.XfaText.shouldBuildText(i2) && L2.push(n2), A2.append(n2);
            }
          }
          for (const M of b2.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
            M.setAttribute("readOnly", true);
          return { textDivs: L2 };
        }
        static update(y) {
          const w2 = `matrix(${y.viewport.transform.join(",")})`;
          y.div.style.transform = w2, y.div.hidden = false;
        }
      };
    }, (k2, d2, t2) => {
      Object.defineProperty(d2, "__esModule", { value: true }), d2.SVGGraphics = void 0;
      var e2 = t2(142), a2 = t2(1), y = t2(3);
      let w2 = class {
        constructor() {
          (0, a2.unreachable)("Not implemented: SVGGraphics");
        }
      };
      d2.SVGGraphics = w2;
      {
        let M = function(n2) {
          let s = [];
          const r = [];
          for (const u of n2)
            u.fn !== "save" ? u.fn === "restore" ? s = r.pop() : s.push(u) : (s.push({ fnId: 92, fn: "group", items: [] }), r.push(s), s = s.at(-1).items);
          return s;
        }, x2 = function(n2) {
          if (Number.isInteger(n2))
            return n2.toString();
          const s = n2.toFixed(10);
          let r = s.length - 1;
          if (s[r] !== "0")
            return s;
          do
            r--;
          while (s[r] === "0");
          return s.substring(0, s[r] === "." ? r : r + 1);
        }, I2 = function(n2) {
          if (n2[4] === 0 && n2[5] === 0) {
            if (n2[1] === 0 && n2[2] === 0)
              return n2[0] === 1 && n2[3] === 1 ? "" : `scale(${x2(n2[0])} ${x2(n2[3])})`;
            if (n2[0] === n2[3] && n2[1] === -n2[2])
              return `rotate(${x2(180 * Math.acos(n2[0]) / Math.PI)})`;
          } else if (n2[0] === 1 && n2[1] === 0 && n2[2] === 0 && n2[3] === 1)
            return `translate(${x2(n2[4])} ${x2(n2[5])})`;
          return `matrix(${x2(n2[0])} ${x2(n2[1])} ${x2(n2[2])} ${x2(n2[3])} ${x2(n2[4])} ${x2(n2[5])})`;
        };
        const O = { fontStyle: "normal", fontWeight: "normal", fillColor: "#000000" }, p2 = "http://www.w3.org/XML/1998/namespace", h2 = "http://www.w3.org/1999/xlink", l2 = ["butt", "round", "square"], c2 = ["miter", "round", "bevel"], b2 = function(n2) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          if (URL.createObjectURL && typeof Blob < "u" && !r)
            return URL.createObjectURL(new Blob([n2], { type: s }));
          const u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          let C = `data:${s};base64,`;
          for (let D = 0, o = n2.length; D < o; D += 3) {
            const F = 255 & n2[D], z = 255 & n2[D + 1], q = 255 & n2[D + 2];
            C += u[F >> 2] + u[(3 & F) << 4 | z >> 4] + u[D + 1 < o ? (15 & z) << 2 | q >> 6 : 64] + u[D + 2 < o ? 63 & q : 64];
          }
          return C;
        }, L2 = function() {
          const n2 = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), s = new Int32Array(256);
          for (let D = 0; D < 256; D++) {
            let o = D;
            for (let F = 0; F < 8; F++)
              o = 1 & o ? 3988292384 ^ o >> 1 & 2147483647 : o >> 1 & 2147483647;
            s[D] = o;
          }
          function r(D, o, F, z) {
            let q = z;
            const J = o.length;
            F[q] = J >> 24 & 255, F[q + 1] = J >> 16 & 255, F[q + 2] = J >> 8 & 255, F[q + 3] = 255 & J, q += 4, F[q] = 255 & D.charCodeAt(0), F[q + 1] = 255 & D.charCodeAt(1), F[q + 2] = 255 & D.charCodeAt(2), F[q + 3] = 255 & D.charCodeAt(3), q += 4, F.set(o, q), q += o.length;
            const $ = function(f, P, g) {
              let _ = -1;
              for (let U = P; U < g; U++) {
                const N = 255 & (_ ^ f[U]);
                _ = _ >>> 8 ^ s[N];
              }
              return -1 ^ _;
            }(F, z + 4, q);
            F[q] = $ >> 24 & 255, F[q + 1] = $ >> 16 & 255, F[q + 2] = $ >> 8 & 255, F[q + 3] = 255 & $;
          }
          function u(D) {
            let o = D.length;
            const F = 65535, z = Math.ceil(o / F), q = new Uint8Array(2 + o + 5 * z + 4);
            let J = 0;
            q[J++] = 120, q[J++] = 156;
            let $ = 0;
            for (; o > F; )
              q[J++] = 0, q[J++] = 255, q[J++] = 255, q[J++] = 0, q[J++] = 0, q.set(D.subarray($, $ + F), J), J += F, $ += F, o -= F;
            q[J++] = 1, q[J++] = 255 & o, q[J++] = o >> 8 & 255, q[J++] = 255 & ~o, q[J++] = (65535 & ~o) >> 8 & 255, q.set(D.subarray($), J), J += D.length - $;
            const S = function(P, g, _) {
              let U = 1, N = 0;
              for (let G = g; G < _; ++G)
                U = (U + (255 & P[G])) % 65521, N = (N + U) % 65521;
              return N << 16 | U;
            }(D, 0, D.length);
            return q[J++] = S >> 24 & 255, q[J++] = S >> 16 & 255, q[J++] = S >> 8 & 255, q[J++] = 255 & S, q;
          }
          function C(D, o, F, z) {
            const q = D.width, J = D.height;
            let $, S, f;
            const P = D.data;
            switch (o) {
              case a2.ImageKind.GRAYSCALE_1BPP:
                S = 0, $ = 1, f = q + 7 >> 3;
                break;
              case a2.ImageKind.RGB_24BPP:
                S = 2, $ = 8, f = 3 * q;
                break;
              case a2.ImageKind.RGBA_32BPP:
                S = 6, $ = 8, f = 4 * q;
                break;
              default:
                throw new Error("invalid format");
            }
            const g = new Uint8Array((1 + f) * J);
            let _ = 0, U = 0;
            for (let K = 0; K < J; ++K)
              g[_++] = 0, g.set(P.subarray(U, U + f), _), U += f, _ += f;
            if (o === a2.ImageKind.GRAYSCALE_1BPP && z) {
              _ = 0;
              for (let K = 0; K < J; K++) {
                _++;
                for (let H = 0; H < f; H++)
                  g[_++] ^= 255;
              }
            }
            const N = new Uint8Array([q >> 24 & 255, q >> 16 & 255, q >> 8 & 255, 255 & q, J >> 24 & 255, J >> 16 & 255, J >> 8 & 255, 255 & J, $, S, 0, 0, 0]), G = function(H) {
              if (!y.isNodeJS)
                return u(H);
              try {
                let Z;
                Z = parseInt(process.versions.node) >= 8 ? H : Buffer.from(H);
                const dt = require$$6.deflateSync(Z, { level: 9 });
                return dt instanceof Uint8Array ? dt : new Uint8Array(dt);
              } catch (Z) {
                (0, a2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + Z);
              }
              return u(H);
            }(g), V = n2.length + 36 + N.length + G.length, W = new Uint8Array(V);
            let X = 0;
            return W.set(n2, X), X += n2.length, r("IHDR", N, W, X), X += 12 + N.length, r("IDATA", G, W, X), X += 12 + G.length, r("IEND", new Uint8Array(0), W, X), b2(W, "image/png", F);
          }
          return function(o, F, z) {
            return C(o, o.kind === void 0 ? a2.ImageKind.GRAYSCALE_1BPP : o.kind, F, z);
          };
        }();
        class m2 {
          constructor() {
            this.fontSizeScale = 1, this.fontWeight = O.fontWeight, this.fontSize = 0, this.textMatrix = a2.IDENTITY_MATRIX, this.fontMatrix = a2.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = a2.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = O.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
          }
          clone() {
            return Object.create(this);
          }
          setCurrentPoint(s, r) {
            this.x = s, this.y = r;
          }
        }
        let v = 0, i2 = 0, A2 = 0;
        d2.SVGGraphics = w2 = class {
          constructor(n2, s) {
            let r = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            (0, e2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new e2.DOMSVGFactory(), this.current = new m2(), this.transformMatrix = a2.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = n2, this.objs = s, this.pendingClip = null, this.pendingEOFill = false, this.embedFonts = false, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!r, this._operatorIdMapping = [];
            for (const u in a2.OPS)
              this._operatorIdMapping[a2.OPS[u]] = u;
          }
          getObject(n2) {
            let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            return typeof n2 == "string" ? n2.startsWith("g_") ? this.commonObjs.get(n2) : this.objs.get(n2) : s;
          }
          save() {
            this.transformStack.push(this.transformMatrix);
            const n2 = this.current;
            this.extraStack.push(n2), this.current = n2.clone();
          }
          restore() {
            this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
          }
          group(n2) {
            this.save(), this.executeOpTree(n2), this.restore();
          }
          loadDependencies(n2) {
            const s = n2.fnArray, r = n2.argsArray;
            for (let u = 0, C = s.length; u < C; u++)
              if (s[u] === a2.OPS.dependency)
                for (const D of r[u]) {
                  const o = D.startsWith("g_") ? this.commonObjs : this.objs, F = new Promise((z) => {
                    o.get(D, z);
                  });
                  this.current.dependencies.push(F);
                }
            return Promise.all(this.current.dependencies);
          }
          transform(n2, s, r, u, C, D) {
            const o = [n2, s, r, u, C, D];
            this.transformMatrix = a2.Util.transform(this.transformMatrix, o), this.tgrp = null;
          }
          getSVG(n2, s) {
            this.viewport = s;
            const r = this._initialize(s);
            return this.loadDependencies(n2).then(() => (this.transformMatrix = a2.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(n2)), r));
          }
          convertOpList(n2) {
            const s = this._operatorIdMapping, r = n2.argsArray, u = n2.fnArray, C = [];
            for (let D = 0, o = u.length; D < o; D++) {
              const F = u[D];
              C.push({ fnId: F, fn: s[F], args: r[D] });
            }
            return M(C);
          }
          executeOpTree(n2) {
            for (const s of n2) {
              const r = s.fn, u = s.fnId, C = s.args;
              switch (0 | u) {
                case a2.OPS.beginText:
                  this.beginText();
                  break;
                case a2.OPS.dependency:
                  break;
                case a2.OPS.setLeading:
                  this.setLeading(C);
                  break;
                case a2.OPS.setLeadingMoveText:
                  this.setLeadingMoveText(C[0], C[1]);
                  break;
                case a2.OPS.setFont:
                  this.setFont(C);
                  break;
                case a2.OPS.showText:
                case a2.OPS.showSpacedText:
                  this.showText(C[0]);
                  break;
                case a2.OPS.endText:
                  this.endText();
                  break;
                case a2.OPS.moveText:
                  this.moveText(C[0], C[1]);
                  break;
                case a2.OPS.setCharSpacing:
                  this.setCharSpacing(C[0]);
                  break;
                case a2.OPS.setWordSpacing:
                  this.setWordSpacing(C[0]);
                  break;
                case a2.OPS.setHScale:
                  this.setHScale(C[0]);
                  break;
                case a2.OPS.setTextMatrix:
                  this.setTextMatrix(C[0], C[1], C[2], C[3], C[4], C[5]);
                  break;
                case a2.OPS.setTextRise:
                  this.setTextRise(C[0]);
                  break;
                case a2.OPS.setTextRenderingMode:
                  this.setTextRenderingMode(C[0]);
                  break;
                case a2.OPS.setLineWidth:
                  this.setLineWidth(C[0]);
                  break;
                case a2.OPS.setLineJoin:
                  this.setLineJoin(C[0]);
                  break;
                case a2.OPS.setLineCap:
                  this.setLineCap(C[0]);
                  break;
                case a2.OPS.setMiterLimit:
                  this.setMiterLimit(C[0]);
                  break;
                case a2.OPS.setFillRGBColor:
                  this.setFillRGBColor(C[0], C[1], C[2]);
                  break;
                case a2.OPS.setStrokeRGBColor:
                  this.setStrokeRGBColor(C[0], C[1], C[2]);
                  break;
                case a2.OPS.setStrokeColorN:
                  this.setStrokeColorN(C);
                  break;
                case a2.OPS.setFillColorN:
                  this.setFillColorN(C);
                  break;
                case a2.OPS.shadingFill:
                  this.shadingFill(C[0]);
                  break;
                case a2.OPS.setDash:
                  this.setDash(C[0], C[1]);
                  break;
                case a2.OPS.setRenderingIntent:
                  this.setRenderingIntent(C[0]);
                  break;
                case a2.OPS.setFlatness:
                  this.setFlatness(C[0]);
                  break;
                case a2.OPS.setGState:
                  this.setGState(C[0]);
                  break;
                case a2.OPS.fill:
                  this.fill();
                  break;
                case a2.OPS.eoFill:
                  this.eoFill();
                  break;
                case a2.OPS.stroke:
                  this.stroke();
                  break;
                case a2.OPS.fillStroke:
                  this.fillStroke();
                  break;
                case a2.OPS.eoFillStroke:
                  this.eoFillStroke();
                  break;
                case a2.OPS.clip:
                  this.clip("nonzero");
                  break;
                case a2.OPS.eoClip:
                  this.clip("evenodd");
                  break;
                case a2.OPS.paintSolidColorImageMask:
                  this.paintSolidColorImageMask();
                  break;
                case a2.OPS.paintImageXObject:
                  this.paintImageXObject(C[0]);
                  break;
                case a2.OPS.paintInlineImageXObject:
                  this.paintInlineImageXObject(C[0]);
                  break;
                case a2.OPS.paintImageMaskXObject:
                  this.paintImageMaskXObject(C[0]);
                  break;
                case a2.OPS.paintFormXObjectBegin:
                  this.paintFormXObjectBegin(C[0], C[1]);
                  break;
                case a2.OPS.paintFormXObjectEnd:
                  this.paintFormXObjectEnd();
                  break;
                case a2.OPS.closePath:
                  this.closePath();
                  break;
                case a2.OPS.closeStroke:
                  this.closeStroke();
                  break;
                case a2.OPS.closeFillStroke:
                  this.closeFillStroke();
                  break;
                case a2.OPS.closeEOFillStroke:
                  this.closeEOFillStroke();
                  break;
                case a2.OPS.nextLine:
                  this.nextLine();
                  break;
                case a2.OPS.transform:
                  this.transform(C[0], C[1], C[2], C[3], C[4], C[5]);
                  break;
                case a2.OPS.constructPath:
                  this.constructPath(C[0], C[1]);
                  break;
                case a2.OPS.endPath:
                  this.endPath();
                  break;
                case 92:
                  this.group(s.items);
                  break;
                default:
                  (0, a2.warn)(`Unimplemented operator ${r}`);
              }
            }
          }
          setWordSpacing(n2) {
            this.current.wordSpacing = n2;
          }
          setCharSpacing(n2) {
            this.current.charSpacing = n2;
          }
          nextLine() {
            this.moveText(0, this.current.leading);
          }
          setTextMatrix(n2, s, r, u, C, D) {
            const o = this.current;
            o.textMatrix = o.lineMatrix = [n2, s, r, u, C, D], o.textMatrixScale = Math.hypot(n2, s), o.x = o.lineX = 0, o.y = o.lineY = 0, o.xcoords = [], o.ycoords = [], o.tspan = this.svgFactory.createElement("svg:tspan"), o.tspan.setAttributeNS(null, "font-family", o.fontFamily), o.tspan.setAttributeNS(null, "font-size", `${x2(o.fontSize)}px`), o.tspan.setAttributeNS(null, "y", x2(-o.y)), o.txtElement = this.svgFactory.createElement("svg:text"), o.txtElement.append(o.tspan);
          }
          beginText() {
            const n2 = this.current;
            n2.x = n2.lineX = 0, n2.y = n2.lineY = 0, n2.textMatrix = a2.IDENTITY_MATRIX, n2.lineMatrix = a2.IDENTITY_MATRIX, n2.textMatrixScale = 1, n2.tspan = this.svgFactory.createElement("svg:tspan"), n2.txtElement = this.svgFactory.createElement("svg:text"), n2.txtgrp = this.svgFactory.createElement("svg:g"), n2.xcoords = [], n2.ycoords = [];
          }
          moveText(n2, s) {
            const r = this.current;
            r.x = r.lineX += n2, r.y = r.lineY += s, r.xcoords = [], r.ycoords = [], r.tspan = this.svgFactory.createElement("svg:tspan"), r.tspan.setAttributeNS(null, "font-family", r.fontFamily), r.tspan.setAttributeNS(null, "font-size", `${x2(r.fontSize)}px`), r.tspan.setAttributeNS(null, "y", x2(-r.y));
          }
          showText(n2) {
            const s = this.current, r = s.font, u = s.fontSize;
            if (u === 0)
              return;
            const C = s.fontSizeScale, D = s.charSpacing, o = s.wordSpacing, F = s.fontDirection, z = s.textHScale * F, q = r.vertical, J = q ? 1 : -1, $ = r.defaultVMetrics, S = u * s.fontMatrix[0];
            let f = 0;
            for (const _ of n2) {
              if (_ === null) {
                f += F * o;
                continue;
              }
              if (typeof _ == "number") {
                f += J * _ * u / 1e3;
                continue;
              }
              const U = (_.isSpace ? o : 0) + D, N = _.fontChar;
              let G, V, W, X = _.width;
              if (q) {
                let K;
                const H = _.vmetric || $;
                K = _.vmetric ? H[1] : 0.5 * X, K = -K * S;
                const Z = H[2] * S;
                X = H ? -H[0] : X, G = K / C, V = (f + Z) / C;
              } else
                G = f / C, V = 0;
              (_.isInFont || r.missingFile) && (s.xcoords.push(s.x + G), q && s.ycoords.push(-s.y + V), s.tspan.textContent += N), W = q ? X * S - U * F : X * S + U * F, f += W;
            }
            s.tspan.setAttributeNS(null, "x", s.xcoords.map(x2).join(" ")), q ? s.tspan.setAttributeNS(null, "y", s.ycoords.map(x2).join(" ")) : s.tspan.setAttributeNS(null, "y", x2(-s.y)), q ? s.y -= f : s.x += f * z, s.tspan.setAttributeNS(null, "font-family", s.fontFamily), s.tspan.setAttributeNS(null, "font-size", `${x2(s.fontSize)}px`), s.fontStyle !== O.fontStyle && s.tspan.setAttributeNS(null, "font-style", s.fontStyle), s.fontWeight !== O.fontWeight && s.tspan.setAttributeNS(null, "font-weight", s.fontWeight);
            const P = s.textRenderingMode & a2.TextRenderingMode.FILL_STROKE_MASK;
            if (P === a2.TextRenderingMode.FILL || P === a2.TextRenderingMode.FILL_STROKE ? (s.fillColor !== O.fillColor && s.tspan.setAttributeNS(null, "fill", s.fillColor), s.fillAlpha < 1 && s.tspan.setAttributeNS(null, "fill-opacity", s.fillAlpha)) : s.textRenderingMode === a2.TextRenderingMode.ADD_TO_PATH ? s.tspan.setAttributeNS(null, "fill", "transparent") : s.tspan.setAttributeNS(null, "fill", "none"), P === a2.TextRenderingMode.STROKE || P === a2.TextRenderingMode.FILL_STROKE) {
              const _ = 1 / (s.textMatrixScale || 1);
              this._setStrokeAttributes(s.tspan, _);
            }
            let g = s.textMatrix;
            s.textRise !== 0 && (g = g.slice(), g[5] += s.textRise), s.txtElement.setAttributeNS(null, "transform", `${I2(g)} scale(${x2(z)}, -1)`), s.txtElement.setAttributeNS(p2, "xml:space", "preserve"), s.txtElement.append(s.tspan), s.txtgrp.append(s.txtElement), this._ensureTransformGroup().append(s.txtElement);
          }
          setLeadingMoveText(n2, s) {
            this.setLeading(-s), this.moveText(n2, s);
          }
          addFontStyle(n2) {
            if (!n2.data)
              throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
            this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
            const s = b2(n2.data, n2.mimetype, this.forceDataSchema);
            this.cssStyle.textContent += `@font-face { font-family: "${n2.loadedName}"; src: url(${s}); }
`;
          }
          setFont(n2) {
            const s = this.current, r = this.commonObjs.get(n2[0]);
            let u = n2[1];
            s.font = r, this.embedFonts && !r.missingFile && !this.embeddedFonts[r.loadedName] && (this.addFontStyle(r), this.embeddedFonts[r.loadedName] = r), s.fontMatrix = r.fontMatrix || a2.FONT_IDENTITY_MATRIX;
            let C = "normal";
            r.black ? C = "900" : r.bold && (C = "bold");
            const D = r.italic ? "italic" : "normal";
            u < 0 ? (u = -u, s.fontDirection = -1) : s.fontDirection = 1, s.fontSize = u, s.fontFamily = r.loadedName, s.fontWeight = C, s.fontStyle = D, s.tspan = this.svgFactory.createElement("svg:tspan"), s.tspan.setAttributeNS(null, "y", x2(-s.y)), s.xcoords = [], s.ycoords = [];
          }
          endText() {
            var n2;
            const s = this.current;
            s.textRenderingMode & a2.TextRenderingMode.ADD_TO_PATH_FLAG && (n2 = s.txtElement) !== null && n2 !== void 0 && n2.hasChildNodes() && (s.element = s.txtElement, this.clip("nonzero"), this.endPath());
          }
          setLineWidth(n2) {
            n2 > 0 && (this.current.lineWidth = n2);
          }
          setLineCap(n2) {
            this.current.lineCap = l2[n2];
          }
          setLineJoin(n2) {
            this.current.lineJoin = c2[n2];
          }
          setMiterLimit(n2) {
            this.current.miterLimit = n2;
          }
          setStrokeAlpha(n2) {
            this.current.strokeAlpha = n2;
          }
          setStrokeRGBColor(n2, s, r) {
            this.current.strokeColor = a2.Util.makeHexColor(n2, s, r);
          }
          setFillAlpha(n2) {
            this.current.fillAlpha = n2;
          }
          setFillRGBColor(n2, s, r) {
            this.current.fillColor = a2.Util.makeHexColor(n2, s, r), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
          }
          setStrokeColorN(n2) {
            this.current.strokeColor = this._makeColorN_Pattern(n2);
          }
          setFillColorN(n2) {
            this.current.fillColor = this._makeColorN_Pattern(n2);
          }
          shadingFill(n2) {
            const s = this.viewport.width, r = this.viewport.height, u = a2.Util.inverseTransform(this.transformMatrix), C = a2.Util.applyTransform([0, 0], u), D = a2.Util.applyTransform([0, r], u), o = a2.Util.applyTransform([s, 0], u), F = a2.Util.applyTransform([s, r], u), z = Math.min(C[0], D[0], o[0], F[0]), q = Math.min(C[1], D[1], o[1], F[1]), J = Math.max(C[0], D[0], o[0], F[0]), $ = Math.max(C[1], D[1], o[1], F[1]), S = this.svgFactory.createElement("svg:rect");
            S.setAttributeNS(null, "x", z), S.setAttributeNS(null, "y", q), S.setAttributeNS(null, "width", J - z), S.setAttributeNS(null, "height", $ - q), S.setAttributeNS(null, "fill", this._makeShadingPattern(n2)), this.current.fillAlpha < 1 && S.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(S);
          }
          _makeColorN_Pattern(n2) {
            return n2[0] === "TilingPattern" ? this._makeTilingPattern(n2) : this._makeShadingPattern(n2);
          }
          _makeTilingPattern(n2) {
            const s = n2[1], r = n2[2], u = n2[3] || a2.IDENTITY_MATRIX, [C, D, o, F] = n2[4], z = n2[5], q = n2[6], J = n2[7], $ = "shading" + A2++, [S, f, P, g] = a2.Util.normalizeRect([...a2.Util.applyTransform([C, D], u), ...a2.Util.applyTransform([o, F], u)]), [_, U] = a2.Util.singularValueDecompose2dScale(u), N = z * _, G = q * U, V = this.svgFactory.createElement("svg:pattern");
            V.setAttributeNS(null, "id", $), V.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), V.setAttributeNS(null, "width", N), V.setAttributeNS(null, "height", G), V.setAttributeNS(null, "x", `${S}`), V.setAttributeNS(null, "y", `${f}`);
            const W = this.svg, X = this.transformMatrix, K = this.current.fillColor, H = this.current.strokeColor, Z = this.svgFactory.create(P - S, g - f);
            if (this.svg = Z, this.transformMatrix = u, J === 2) {
              const dt = a2.Util.makeHexColor(...s);
              this.current.fillColor = dt, this.current.strokeColor = dt;
            }
            return this.executeOpTree(this.convertOpList(r)), this.svg = W, this.transformMatrix = X, this.current.fillColor = K, this.current.strokeColor = H, V.append(Z.childNodes[0]), this.defs.append(V), `url(#${$})`;
          }
          _makeShadingPattern(n2) {
            switch (typeof n2 == "string" && (n2 = this.objs.get(n2)), n2[0]) {
              case "RadialAxial":
                const s = "shading" + A2++, r = n2[3];
                let u;
                switch (n2[1]) {
                  case "axial":
                    const C = n2[4], D = n2[5];
                    u = this.svgFactory.createElement("svg:linearGradient"), u.setAttributeNS(null, "id", s), u.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), u.setAttributeNS(null, "x1", C[0]), u.setAttributeNS(null, "y1", C[1]), u.setAttributeNS(null, "x2", D[0]), u.setAttributeNS(null, "y2", D[1]);
                    break;
                  case "radial":
                    const o = n2[4], F = n2[5], z = n2[6], q = n2[7];
                    u = this.svgFactory.createElement("svg:radialGradient"), u.setAttributeNS(null, "id", s), u.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), u.setAttributeNS(null, "cx", F[0]), u.setAttributeNS(null, "cy", F[1]), u.setAttributeNS(null, "r", q), u.setAttributeNS(null, "fx", o[0]), u.setAttributeNS(null, "fy", o[1]), u.setAttributeNS(null, "fr", z);
                    break;
                  default:
                    throw new Error(`Unknown RadialAxial type: ${n2[1]}`);
                }
                for (const C of r) {
                  const D = this.svgFactory.createElement("svg:stop");
                  D.setAttributeNS(null, "offset", C[0]), D.setAttributeNS(null, "stop-color", C[1]), u.append(D);
                }
                return this.defs.append(u), `url(#${s})`;
              case "Mesh":
                return (0, a2.warn)("Unimplemented pattern Mesh"), null;
              case "Dummy":
                return "hotpink";
              default:
                throw new Error(`Unknown IR type: ${n2[0]}`);
            }
          }
          setDash(n2, s) {
            this.current.dashArray = n2, this.current.dashPhase = s;
          }
          constructPath(n2, s) {
            const r = this.current;
            let u = r.x, C = r.y, D = [], o = 0;
            for (const F of n2)
              switch (0 | F) {
                case a2.OPS.rectangle:
                  u = s[o++], C = s[o++];
                  const z = u + s[o++], q = C + s[o++];
                  D.push("M", x2(u), x2(C), "L", x2(z), x2(C), "L", x2(z), x2(q), "L", x2(u), x2(q), "Z");
                  break;
                case a2.OPS.moveTo:
                  u = s[o++], C = s[o++], D.push("M", x2(u), x2(C));
                  break;
                case a2.OPS.lineTo:
                  u = s[o++], C = s[o++], D.push("L", x2(u), x2(C));
                  break;
                case a2.OPS.curveTo:
                  u = s[o + 4], C = s[o + 5], D.push("C", x2(s[o]), x2(s[o + 1]), x2(s[o + 2]), x2(s[o + 3]), x2(u), x2(C)), o += 6;
                  break;
                case a2.OPS.curveTo2:
                  D.push("C", x2(u), x2(C), x2(s[o]), x2(s[o + 1]), x2(s[o + 2]), x2(s[o + 3])), u = s[o + 2], C = s[o + 3], o += 4;
                  break;
                case a2.OPS.curveTo3:
                  u = s[o + 2], C = s[o + 3], D.push("C", x2(s[o]), x2(s[o + 1]), x2(u), x2(C), x2(u), x2(C)), o += 4;
                  break;
                case a2.OPS.closePath:
                  D.push("Z");
              }
            D = D.join(" "), r.path && n2.length > 0 && n2[0] !== a2.OPS.rectangle && n2[0] !== a2.OPS.moveTo ? D = r.path.getAttributeNS(null, "d") + D : (r.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(r.path)), r.path.setAttributeNS(null, "d", D), r.path.setAttributeNS(null, "fill", "none"), r.element = r.path, r.setCurrentPoint(u, C);
          }
          endPath() {
            const n2 = this.current;
            if (n2.path = null, !this.pendingClip)
              return;
            if (!n2.element) {
              this.pendingClip = null;
              return;
            }
            const s = "clippath" + v++, r = this.svgFactory.createElement("svg:clipPath");
            r.setAttributeNS(null, "id", s), r.setAttributeNS(null, "transform", I2(this.transformMatrix));
            const u = n2.element.cloneNode(true);
            if (this.pendingClip === "evenodd" ? u.setAttributeNS(null, "clip-rule", "evenodd") : u.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, r.append(u), this.defs.append(r), n2.activeClipUrl) {
              n2.clipGroup = null;
              for (const C of this.extraStack)
                C.clipGroup = null;
              r.setAttributeNS(null, "clip-path", n2.activeClipUrl);
            }
            n2.activeClipUrl = `url(#${s})`, this.tgrp = null;
          }
          clip(n2) {
            this.pendingClip = n2;
          }
          closePath() {
            const n2 = this.current;
            if (n2.path) {
              const s = `${n2.path.getAttributeNS(null, "d")}Z`;
              n2.path.setAttributeNS(null, "d", s);
            }
          }
          setLeading(n2) {
            this.current.leading = -n2;
          }
          setTextRise(n2) {
            this.current.textRise = n2;
          }
          setTextRenderingMode(n2) {
            this.current.textRenderingMode = n2;
          }
          setHScale(n2) {
            this.current.textHScale = n2 / 100;
          }
          setRenderingIntent(n2) {
          }
          setFlatness(n2) {
          }
          setGState(n2) {
            for (const [s, r] of n2)
              switch (s) {
                case "LW":
                  this.setLineWidth(r);
                  break;
                case "LC":
                  this.setLineCap(r);
                  break;
                case "LJ":
                  this.setLineJoin(r);
                  break;
                case "ML":
                  this.setMiterLimit(r);
                  break;
                case "D":
                  this.setDash(r[0], r[1]);
                  break;
                case "RI":
                  this.setRenderingIntent(r);
                  break;
                case "FL":
                  this.setFlatness(r);
                  break;
                case "Font":
                  this.setFont(r);
                  break;
                case "CA":
                  this.setStrokeAlpha(r);
                  break;
                case "ca":
                  this.setFillAlpha(r);
                  break;
                default:
                  (0, a2.warn)(`Unimplemented graphic state operator ${s}`);
              }
          }
          fill() {
            const n2 = this.current;
            n2.element && (n2.element.setAttributeNS(null, "fill", n2.fillColor), n2.element.setAttributeNS(null, "fill-opacity", n2.fillAlpha), this.endPath());
          }
          stroke() {
            const n2 = this.current;
            n2.element && (this._setStrokeAttributes(n2.element), n2.element.setAttributeNS(null, "fill", "none"), this.endPath());
          }
          _setStrokeAttributes(n2) {
            let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            const r = this.current;
            let u = r.dashArray;
            s !== 1 && u.length > 0 && (u = u.map(function(C) {
              return s * C;
            })), n2.setAttributeNS(null, "stroke", r.strokeColor), n2.setAttributeNS(null, "stroke-opacity", r.strokeAlpha), n2.setAttributeNS(null, "stroke-miterlimit", x2(r.miterLimit)), n2.setAttributeNS(null, "stroke-linecap", r.lineCap), n2.setAttributeNS(null, "stroke-linejoin", r.lineJoin), n2.setAttributeNS(null, "stroke-width", x2(s * r.lineWidth) + "px"), n2.setAttributeNS(null, "stroke-dasharray", u.map(x2).join(" ")), n2.setAttributeNS(null, "stroke-dashoffset", x2(s * r.dashPhase) + "px");
          }
          eoFill() {
            var n2;
            (n2 = this.current.element) === null || n2 === void 0 || n2.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
          }
          fillStroke() {
            this.stroke(), this.fill();
          }
          eoFillStroke() {
            var n2;
            (n2 = this.current.element) === null || n2 === void 0 || n2.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
          }
          closeStroke() {
            this.closePath(), this.stroke();
          }
          closeFillStroke() {
            this.closePath(), this.fillStroke();
          }
          closeEOFillStroke() {
            this.closePath(), this.eoFillStroke();
          }
          paintSolidColorImageMask() {
            const n2 = this.svgFactory.createElement("svg:rect");
            n2.setAttributeNS(null, "x", "0"), n2.setAttributeNS(null, "y", "0"), n2.setAttributeNS(null, "width", "1px"), n2.setAttributeNS(null, "height", "1px"), n2.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(n2);
          }
          paintImageXObject(n2) {
            const s = this.getObject(n2);
            s ? this.paintInlineImageXObject(s) : (0, a2.warn)(`Dependent image with object ID ${n2} is not ready yet`);
          }
          paintInlineImageXObject(n2, s) {
            const r = n2.width, u = n2.height, C = L2(n2, this.forceDataSchema, !!s), D = this.svgFactory.createElement("svg:rect");
            D.setAttributeNS(null, "x", "0"), D.setAttributeNS(null, "y", "0"), D.setAttributeNS(null, "width", x2(r)), D.setAttributeNS(null, "height", x2(u)), this.current.element = D, this.clip("nonzero");
            const o = this.svgFactory.createElement("svg:image");
            o.setAttributeNS(h2, "xlink:href", C), o.setAttributeNS(null, "x", "0"), o.setAttributeNS(null, "y", x2(-u)), o.setAttributeNS(null, "width", x2(r) + "px"), o.setAttributeNS(null, "height", x2(u) + "px"), o.setAttributeNS(null, "transform", `scale(${x2(1 / r)} ${x2(-1 / u)})`), s ? s.append(o) : this._ensureTransformGroup().append(o);
          }
          paintImageMaskXObject(n2) {
            const s = this.getObject(n2.data, n2);
            if (s.bitmap) {
              (0, a2.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
              return;
            }
            const r = this.current, u = s.width, C = s.height, D = r.fillColor;
            r.maskId = "mask" + i2++;
            const o = this.svgFactory.createElement("svg:mask");
            o.setAttributeNS(null, "id", r.maskId);
            const F = this.svgFactory.createElement("svg:rect");
            F.setAttributeNS(null, "x", "0"), F.setAttributeNS(null, "y", "0"), F.setAttributeNS(null, "width", x2(u)), F.setAttributeNS(null, "height", x2(C)), F.setAttributeNS(null, "fill", D), F.setAttributeNS(null, "mask", `url(#${r.maskId})`), this.defs.append(o), this._ensureTransformGroup().append(F), this.paintInlineImageXObject(s, o);
          }
          paintFormXObjectBegin(n2, s) {
            if (Array.isArray(n2) && n2.length === 6 && this.transform(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]), s) {
              const r = s[2] - s[0], u = s[3] - s[1], C = this.svgFactory.createElement("svg:rect");
              C.setAttributeNS(null, "x", s[0]), C.setAttributeNS(null, "y", s[1]), C.setAttributeNS(null, "width", x2(r)), C.setAttributeNS(null, "height", x2(u)), this.current.element = C, this.clip("nonzero"), this.endPath();
            }
          }
          paintFormXObjectEnd() {
          }
          _initialize(n2) {
            const s = this.svgFactory.create(n2.width, n2.height), r = this.svgFactory.createElement("svg:defs");
            s.append(r), this.defs = r;
            const u = this.svgFactory.createElement("svg:g");
            return u.setAttributeNS(null, "transform", I2(n2.transform)), s.append(u), this.svg = u, s;
          }
          _ensureClipGroup() {
            if (!this.current.clipGroup) {
              const n2 = this.svgFactory.createElement("svg:g");
              n2.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(n2), this.current.clipGroup = n2;
            }
            return this.current.clipGroup;
          }
          _ensureTransformGroup() {
            return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", I2(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
          }
        };
      }
    }], __webpack_module_cache__ = {};
    function __w_pdfjs_require__(k2) {
      var d2 = __webpack_module_cache__[k2];
      if (d2 !== void 0)
        return d2.exports;
      var t2 = __webpack_module_cache__[k2] = { exports: {} };
      return __webpack_modules__[k2].call(t2.exports, t2, t2.exports, __w_pdfjs_require__), t2.exports;
    }
    var __webpack_exports__ = {};
    return (() => {
      var k2 = __webpack_exports__;
      Object.defineProperty(k2, "__esModule", { value: true }), Object.defineProperty(k2, "AbortException", { enumerable: true, get: function() {
        return d2.AbortException;
      } }), Object.defineProperty(k2, "AnnotationEditorLayer", { enumerable: true, get: function() {
        return y.AnnotationEditorLayer;
      } }), Object.defineProperty(k2, "AnnotationEditorParamsType", { enumerable: true, get: function() {
        return d2.AnnotationEditorParamsType;
      } }), Object.defineProperty(k2, "AnnotationEditorType", { enumerable: true, get: function() {
        return d2.AnnotationEditorType;
      } }), Object.defineProperty(k2, "AnnotationEditorUIManager", { enumerable: true, get: function() {
        return w2.AnnotationEditorUIManager;
      } }), Object.defineProperty(k2, "AnnotationLayer", { enumerable: true, get: function() {
        return O.AnnotationLayer;
      } }), Object.defineProperty(k2, "AnnotationMode", { enumerable: true, get: function() {
        return d2.AnnotationMode;
      } }), Object.defineProperty(k2, "CMapCompressionType", { enumerable: true, get: function() {
        return d2.CMapCompressionType;
      } }), Object.defineProperty(k2, "FeatureTest", { enumerable: true, get: function() {
        return d2.FeatureTest;
      } }), Object.defineProperty(k2, "GlobalWorkerOptions", { enumerable: true, get: function() {
        return p2.GlobalWorkerOptions;
      } }), Object.defineProperty(k2, "InvalidPDFException", { enumerable: true, get: function() {
        return d2.InvalidPDFException;
      } }), Object.defineProperty(k2, "MissingPDFException", { enumerable: true, get: function() {
        return d2.MissingPDFException;
      } }), Object.defineProperty(k2, "OPS", { enumerable: true, get: function() {
        return d2.OPS;
      } }), Object.defineProperty(k2, "PDFDataRangeTransport", { enumerable: true, get: function() {
        return t2.PDFDataRangeTransport;
      } }), Object.defineProperty(k2, "PDFDateString", { enumerable: true, get: function() {
        return e2.PDFDateString;
      } }), Object.defineProperty(k2, "PDFWorker", { enumerable: true, get: function() {
        return t2.PDFWorker;
      } }), Object.defineProperty(k2, "PasswordResponses", { enumerable: true, get: function() {
        return d2.PasswordResponses;
      } }), Object.defineProperty(k2, "PermissionFlag", { enumerable: true, get: function() {
        return d2.PermissionFlag;
      } }), Object.defineProperty(k2, "PixelsPerInch", { enumerable: true, get: function() {
        return e2.PixelsPerInch;
      } }), Object.defineProperty(k2, "PromiseCapability", { enumerable: true, get: function() {
        return d2.PromiseCapability;
      } }), Object.defineProperty(k2, "RenderingCancelledException", { enumerable: true, get: function() {
        return e2.RenderingCancelledException;
      } }), Object.defineProperty(k2, "SVGGraphics", { enumerable: true, get: function() {
        return h2.SVGGraphics;
      } }), Object.defineProperty(k2, "UnexpectedResponseException", { enumerable: true, get: function() {
        return d2.UnexpectedResponseException;
      } }), Object.defineProperty(k2, "Util", { enumerable: true, get: function() {
        return d2.Util;
      } }), Object.defineProperty(k2, "VerbosityLevel", { enumerable: true, get: function() {
        return d2.VerbosityLevel;
      } }), Object.defineProperty(k2, "XfaLayer", { enumerable: true, get: function() {
        return l2.XfaLayer;
      } }), Object.defineProperty(k2, "build", { enumerable: true, get: function() {
        return t2.build;
      } }), Object.defineProperty(k2, "createValidAbsoluteUrl", { enumerable: true, get: function() {
        return d2.createValidAbsoluteUrl;
      } }), Object.defineProperty(k2, "getDocument", { enumerable: true, get: function() {
        return t2.getDocument;
      } }), Object.defineProperty(k2, "getFilenameFromUrl", { enumerable: true, get: function() {
        return e2.getFilenameFromUrl;
      } }), Object.defineProperty(k2, "getPdfFilenameFromUrl", { enumerable: true, get: function() {
        return e2.getPdfFilenameFromUrl;
      } }), Object.defineProperty(k2, "getXfaPageViewport", { enumerable: true, get: function() {
        return e2.getXfaPageViewport;
      } }), Object.defineProperty(k2, "isDataScheme", { enumerable: true, get: function() {
        return e2.isDataScheme;
      } }), Object.defineProperty(k2, "isPdfFile", { enumerable: true, get: function() {
        return e2.isPdfFile;
      } }), Object.defineProperty(k2, "loadScript", { enumerable: true, get: function() {
        return e2.loadScript;
      } }), Object.defineProperty(k2, "normalizeUnicode", { enumerable: true, get: function() {
        return d2.normalizeUnicode;
      } }), Object.defineProperty(k2, "renderTextLayer", { enumerable: true, get: function() {
        return a2.renderTextLayer;
      } }), Object.defineProperty(k2, "setLayerDimensions", { enumerable: true, get: function() {
        return e2.setLayerDimensions;
      } }), Object.defineProperty(k2, "shadow", { enumerable: true, get: function() {
        return d2.shadow;
      } }), Object.defineProperty(k2, "updateTextLayer", { enumerable: true, get: function() {
        return a2.updateTextLayer;
      } }), Object.defineProperty(k2, "version", { enumerable: true, get: function() {
        return t2.version;
      } });
      var d2 = __w_pdfjs_require__(1), t2 = __w_pdfjs_require__(138), e2 = __w_pdfjs_require__(142), a2 = __w_pdfjs_require__(161), y = __w_pdfjs_require__(162), w2 = __w_pdfjs_require__(141), O = __w_pdfjs_require__(165), p2 = __w_pdfjs_require__(149), h2 = __w_pdfjs_require__(168), l2 = __w_pdfjs_require__(167);
    })(), __webpack_exports__;
  })());
})(pdf_min$2);
var pdf_minExports = pdf_min$2.exports;
var pdf_min = getDefaultExportFromCjs(pdf_minExports);
var pdf_min$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: pdf_min
}, Symbol.toStringTag, { value: "Module" }));
export {
  pdf_min$1 as p
};
//# sourceMappingURL=pdf.min-f72cfa08-PNORG7ES.js.map
